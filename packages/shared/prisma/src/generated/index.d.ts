// This file was overwritten by prisma-json-types-generator
// Report any issues to https://github.com/arthurfiorette/prisma-json-types-generator

declare global {
  namespace PrismaJson {
    // This namespace will always be empty. Definitions should be done by
    // you manually, and merged automatically by typescript. Make sure that
    // your declaration merging file is included in your tsconfig.json
    //
    // Learn more: https://github.com/arthurfiorette/prisma-json-types-generator/issues/143
    // Declaration Merging: https://www.typescriptlang.org/docs/handbook/declaration-merging.html
  }
}

/** A filter to be used against nullable List types. */
export type NullableListFilter<T> = {
  equals?: T | T[] | null;
  has?: T | null;
  hasEvery?: T[];
  hasSome?: T[];
  isEmpty?: boolean;
};

/** A type to determine how to update a json field */
export type UpdateInput<T> = T extends object ? { [P in keyof T]?: UpdateInput<T[P]> } : T;

/** A type to determine how to update a json[] field */
export type UpdateManyInput<T> = T | T[] | { set?: T[]; push?: T | T[] };

/** A type to determine how to create a json[] input */
export type CreateManyInput<T> = T | T[] | { set?: T[] };

/**
 * A typed version of NestedStringFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedNestedStringFilter<S extends string> =
  //@ts-ignore - When Prisma.StringFilter is not present, this type is not used
  Prisma.StringFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringFilter<S> | S;
  };

/**
 * A typed version of StringFilter, allowing narrowing of string types to discriminated
 * unions.
 */
export type TypedStringFilter<S extends string> =
  //@ts-ignore - When Prisma.StringFilter is not present, this type is not used
  Prisma.StringFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringFilter<S> | S;
  };

/**
 * A typed version of NestedStringNullableFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedNestedStringNullableFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableFilter is not present, this type is not used
  Prisma.StringNullableFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableFilter<S> | S | null;
  };

/**
 * A typed version of StringNullableFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringNullableFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableFilter is not present, this type is not used
  Prisma.StringNullableFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableFilter<S> | S | null;
  };

/**
 * A typed version of NestedStringWithAggregatesFilter, allowing narrowing of string types
 * to discriminated unions.
 */
export type TypedNestedStringWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.NestedStringWithAggregatesFilter is not present, this type is not used
  Prisma.NestedStringWithAggregatesFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringWithAggregatesFilter<S> | S;
  };

/**
 * A typed version of StringWithAggregatesFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.StringWithAggregatesFilter is not present, this type is not used
  Prisma.StringWithAggregatesFilter & {
    equals?: S;
    in?: S[];
    notIn?: S[];
    not?: TypedNestedStringWithAggregatesFilter<S> | S;
  };

/**
 * A typed version of NestedStringNullableWithAggregatesFilter, allowing narrowing of
 * string types to discriminated unions.
 */
export type TypedNestedStringNullableWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.NestedStringNullableWithAggregatesFilter is not present, this type is not used
  Prisma.NestedStringNullableWithAggregatesFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableWithAggregatesFilter<S> | S | null;
  };

/**
 * A typed version of StringNullableWithAggregatesFilter, allowing narrowing of string
 * types to discriminated unions.
 */
export type TypedStringNullableWithAggregatesFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableWithAggregatesFilter is not present, this type is not used
  Prisma.StringNullableWithAggregatesFilter & {
    equals?: S | null;
    in?: S[] | null;
    notIn?: S[] | null;
    not?: TypedNestedStringNullableWithAggregatesFilter<S> | S | null;
  };

/**
 * A typed version of StringFieldUpdateOperationsInput, allowing narrowing of string types
 * to discriminated unions.
 */
export type TypedStringFieldUpdateOperationsInput<S extends string> =
  //@ts-ignore - When Prisma.StringFieldUpdateOperationsInput is not present, this type is not used
  Prisma.StringFieldUpdateOperationsInput & {
    set?: S;
  };

/**
 * A typed version of NullableStringFieldUpdateOperationsInput, allowing narrowing of
 * string types to discriminated unions.
 */
export type TypedNullableStringFieldUpdateOperationsInput<S extends string> =
  //@ts-ignore - When Prisma.NullableStringFieldUpdateOperationsInput is not present, this type is not used
  Prisma.NullableStringFieldUpdateOperationsInput & {
    set?: S | null;
  };

/**
 * A typed version of StringNullableListFilter, allowing narrowing of string types to
 * discriminated unions.
 */
export type TypedStringNullableListFilter<S extends string> =
  //@ts-ignore - When Prisma.StringNullableListFilter is not present, this type is not used
  Prisma.StringNullableListFilter & {
    equals?: S[] | null;
    has?: S | null;
    hasEvery?: S[];
    hasSome?: S[];
  };

/**
 * A typed version of the input type to update a string[] field, allowing narrowing of
 * string types to discriminated unions.
 */
export type UpdateStringArrayInput<S extends string> = {
  set?: S[];
  push?: S | S[];
};

/**
 * A typed version of the input type to create a string[] field, allowing narrowing of
 * string types to discriminated unions.
 */
export type CreateStringArrayInput<S extends string> = {
  set?: S[];
};

/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model CallBreakGame
 * 
 */
export type CallBreakGame = $Result.DefaultSelection<Prisma.$CallBreakGamePayload>
/**
 * Model CallBreakPlayer
 * 
 */
export type CallBreakPlayer = $Result.DefaultSelection<Prisma.$CallBreakPlayerPayload>
/**
 * Model CallBreakDeal
 * 
 */
export type CallBreakDeal = $Result.DefaultSelection<Prisma.$CallBreakDealPayload>
/**
 * Model CallBreakCardMapping
 * 
 */
export type CallBreakCardMapping = $Result.DefaultSelection<Prisma.$CallBreakCardMappingPayload>
/**
 * Model CallBreakRound
 * 
 */
export type CallBreakRound = $Result.DefaultSelection<Prisma.$CallBreakRoundPayload>
/**
 * Model LiteraturePlayer
 * 
 */
export type LiteraturePlayer = $Result.DefaultSelection<Prisma.$LiteraturePlayerPayload>
/**
 * Model LiteratureTeam
 * 
 */
export type LiteratureTeam = $Result.DefaultSelection<Prisma.$LiteratureTeamPayload>
/**
 * Model LiteratureCardMapping
 * 
 */
export type LiteratureCardMapping = $Result.DefaultSelection<Prisma.$LiteratureCardMappingPayload>
/**
 * Model LiteratureCardLocation
 * 
 */
export type LiteratureCardLocation = $Result.DefaultSelection<Prisma.$LiteratureCardLocationPayload>
/**
 * Model LiteratureAsk
 * 
 */
export type LiteratureAsk = $Result.DefaultSelection<Prisma.$LiteratureAskPayload>
/**
 * Model LiteratureCall
 * 
 */
export type LiteratureCall = $Result.DefaultSelection<Prisma.$LiteratureCallPayload>
/**
 * Model LiteratureTransfer
 * 
 */
export type LiteratureTransfer = $Result.DefaultSelection<Prisma.$LiteratureTransferPayload>
/**
 * Model LiteratureGame
 * 
 */
export type LiteratureGame = $Result.DefaultSelection<Prisma.$LiteratureGamePayload>
/**
 * Model WordleGame
 * 
 */
export type WordleGame = $Result.DefaultSelection<Prisma.$WordleGamePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CallBreakStatus: {
  CREATED: 'CREATED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type CallBreakStatus = (typeof CallBreakStatus)[keyof typeof CallBreakStatus]


export const LiteratureGameStatus: {
  CREATED: 'CREATED',
  PLAYERS_READY: 'PLAYERS_READY',
  TEAMS_CREATED: 'TEAMS_CREATED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type LiteratureGameStatus = (typeof LiteratureGameStatus)[keyof typeof LiteratureGameStatus]

}

export type CallBreakStatus = $Enums.CallBreakStatus

export const CallBreakStatus: typeof $Enums.CallBreakStatus

export type LiteratureGameStatus = $Enums.LiteratureGameStatus

export const LiteratureGameStatus: typeof $Enums.LiteratureGameStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callBreakGame`: Exposes CRUD operations for the **CallBreakGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallBreakGames
    * const callBreakGames = await prisma.callBreakGame.findMany()
    * ```
    */
  get callBreakGame(): Prisma.CallBreakGameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callBreakPlayer`: Exposes CRUD operations for the **CallBreakPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallBreakPlayers
    * const callBreakPlayers = await prisma.callBreakPlayer.findMany()
    * ```
    */
  get callBreakPlayer(): Prisma.CallBreakPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callBreakDeal`: Exposes CRUD operations for the **CallBreakDeal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallBreakDeals
    * const callBreakDeals = await prisma.callBreakDeal.findMany()
    * ```
    */
  get callBreakDeal(): Prisma.CallBreakDealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callBreakCardMapping`: Exposes CRUD operations for the **CallBreakCardMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallBreakCardMappings
    * const callBreakCardMappings = await prisma.callBreakCardMapping.findMany()
    * ```
    */
  get callBreakCardMapping(): Prisma.CallBreakCardMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callBreakRound`: Exposes CRUD operations for the **CallBreakRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallBreakRounds
    * const callBreakRounds = await prisma.callBreakRound.findMany()
    * ```
    */
  get callBreakRound(): Prisma.CallBreakRoundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literaturePlayer`: Exposes CRUD operations for the **LiteraturePlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteraturePlayers
    * const literaturePlayers = await prisma.literaturePlayer.findMany()
    * ```
    */
  get literaturePlayer(): Prisma.LiteraturePlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureTeam`: Exposes CRUD operations for the **LiteratureTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureTeams
    * const literatureTeams = await prisma.literatureTeam.findMany()
    * ```
    */
  get literatureTeam(): Prisma.LiteratureTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureCardMapping`: Exposes CRUD operations for the **LiteratureCardMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureCardMappings
    * const literatureCardMappings = await prisma.literatureCardMapping.findMany()
    * ```
    */
  get literatureCardMapping(): Prisma.LiteratureCardMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureCardLocation`: Exposes CRUD operations for the **LiteratureCardLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureCardLocations
    * const literatureCardLocations = await prisma.literatureCardLocation.findMany()
    * ```
    */
  get literatureCardLocation(): Prisma.LiteratureCardLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureAsk`: Exposes CRUD operations for the **LiteratureAsk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureAsks
    * const literatureAsks = await prisma.literatureAsk.findMany()
    * ```
    */
  get literatureAsk(): Prisma.LiteratureAskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureCall`: Exposes CRUD operations for the **LiteratureCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureCalls
    * const literatureCalls = await prisma.literatureCall.findMany()
    * ```
    */
  get literatureCall(): Prisma.LiteratureCallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureTransfer`: Exposes CRUD operations for the **LiteratureTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureTransfers
    * const literatureTransfers = await prisma.literatureTransfer.findMany()
    * ```
    */
  get literatureTransfer(): Prisma.LiteratureTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.literatureGame`: Exposes CRUD operations for the **LiteratureGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiteratureGames
    * const literatureGames = await prisma.literatureGame.findMany()
    * ```
    */
  get literatureGame(): Prisma.LiteratureGameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wordleGame`: Exposes CRUD operations for the **WordleGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WordleGames
    * const wordleGames = await prisma.wordleGame.findMany()
    * ```
    */
  get wordleGame(): Prisma.WordleGameDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    CallBreakGame: 'CallBreakGame',
    CallBreakPlayer: 'CallBreakPlayer',
    CallBreakDeal: 'CallBreakDeal',
    CallBreakCardMapping: 'CallBreakCardMapping',
    CallBreakRound: 'CallBreakRound',
    LiteraturePlayer: 'LiteraturePlayer',
    LiteratureTeam: 'LiteratureTeam',
    LiteratureCardMapping: 'LiteratureCardMapping',
    LiteratureCardLocation: 'LiteratureCardLocation',
    LiteratureAsk: 'LiteratureAsk',
    LiteratureCall: 'LiteratureCall',
    LiteratureTransfer: 'LiteratureTransfer',
    LiteratureGame: 'LiteratureGame',
    WordleGame: 'WordleGame'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "callBreakGame" | "callBreakPlayer" | "callBreakDeal" | "callBreakCardMapping" | "callBreakRound" | "literaturePlayer" | "literatureTeam" | "literatureCardMapping" | "literatureCardLocation" | "literatureAsk" | "literatureCall" | "literatureTransfer" | "literatureGame" | "wordleGame"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      CallBreakGame: {
        payload: Prisma.$CallBreakGamePayload<ExtArgs>
        fields: Prisma.CallBreakGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallBreakGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallBreakGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          findFirst: {
            args: Prisma.CallBreakGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallBreakGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          findMany: {
            args: Prisma.CallBreakGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>[]
          }
          create: {
            args: Prisma.CallBreakGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          createMany: {
            args: Prisma.CallBreakGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallBreakGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>[]
          }
          delete: {
            args: Prisma.CallBreakGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          update: {
            args: Prisma.CallBreakGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          deleteMany: {
            args: Prisma.CallBreakGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallBreakGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallBreakGameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>[]
          }
          upsert: {
            args: Prisma.CallBreakGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakGamePayload>
          }
          aggregate: {
            args: Prisma.CallBreakGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallBreakGame>
          }
          groupBy: {
            args: Prisma.CallBreakGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallBreakGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallBreakGameCountArgs<ExtArgs>
            result: $Utils.Optional<CallBreakGameCountAggregateOutputType> | number
          }
        }
      }
      CallBreakPlayer: {
        payload: Prisma.$CallBreakPlayerPayload<ExtArgs>
        fields: Prisma.CallBreakPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallBreakPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallBreakPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          findFirst: {
            args: Prisma.CallBreakPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallBreakPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          findMany: {
            args: Prisma.CallBreakPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>[]
          }
          create: {
            args: Prisma.CallBreakPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          createMany: {
            args: Prisma.CallBreakPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallBreakPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>[]
          }
          delete: {
            args: Prisma.CallBreakPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          update: {
            args: Prisma.CallBreakPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          deleteMany: {
            args: Prisma.CallBreakPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallBreakPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallBreakPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>[]
          }
          upsert: {
            args: Prisma.CallBreakPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakPlayerPayload>
          }
          aggregate: {
            args: Prisma.CallBreakPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallBreakPlayer>
          }
          groupBy: {
            args: Prisma.CallBreakPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallBreakPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallBreakPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<CallBreakPlayerCountAggregateOutputType> | number
          }
        }
      }
      CallBreakDeal: {
        payload: Prisma.$CallBreakDealPayload<ExtArgs>
        fields: Prisma.CallBreakDealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallBreakDealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallBreakDealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          findFirst: {
            args: Prisma.CallBreakDealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallBreakDealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          findMany: {
            args: Prisma.CallBreakDealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>[]
          }
          create: {
            args: Prisma.CallBreakDealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          createMany: {
            args: Prisma.CallBreakDealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallBreakDealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>[]
          }
          delete: {
            args: Prisma.CallBreakDealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          update: {
            args: Prisma.CallBreakDealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          deleteMany: {
            args: Prisma.CallBreakDealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallBreakDealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallBreakDealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>[]
          }
          upsert: {
            args: Prisma.CallBreakDealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakDealPayload>
          }
          aggregate: {
            args: Prisma.CallBreakDealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallBreakDeal>
          }
          groupBy: {
            args: Prisma.CallBreakDealGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallBreakDealGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallBreakDealCountArgs<ExtArgs>
            result: $Utils.Optional<CallBreakDealCountAggregateOutputType> | number
          }
        }
      }
      CallBreakCardMapping: {
        payload: Prisma.$CallBreakCardMappingPayload<ExtArgs>
        fields: Prisma.CallBreakCardMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallBreakCardMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallBreakCardMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          findFirst: {
            args: Prisma.CallBreakCardMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallBreakCardMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          findMany: {
            args: Prisma.CallBreakCardMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>[]
          }
          create: {
            args: Prisma.CallBreakCardMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          createMany: {
            args: Prisma.CallBreakCardMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallBreakCardMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>[]
          }
          delete: {
            args: Prisma.CallBreakCardMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          update: {
            args: Prisma.CallBreakCardMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          deleteMany: {
            args: Prisma.CallBreakCardMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallBreakCardMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallBreakCardMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>[]
          }
          upsert: {
            args: Prisma.CallBreakCardMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakCardMappingPayload>
          }
          aggregate: {
            args: Prisma.CallBreakCardMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallBreakCardMapping>
          }
          groupBy: {
            args: Prisma.CallBreakCardMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallBreakCardMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallBreakCardMappingCountArgs<ExtArgs>
            result: $Utils.Optional<CallBreakCardMappingCountAggregateOutputType> | number
          }
        }
      }
      CallBreakRound: {
        payload: Prisma.$CallBreakRoundPayload<ExtArgs>
        fields: Prisma.CallBreakRoundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallBreakRoundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallBreakRoundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          findFirst: {
            args: Prisma.CallBreakRoundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallBreakRoundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          findMany: {
            args: Prisma.CallBreakRoundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>[]
          }
          create: {
            args: Prisma.CallBreakRoundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          createMany: {
            args: Prisma.CallBreakRoundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallBreakRoundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>[]
          }
          delete: {
            args: Prisma.CallBreakRoundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          update: {
            args: Prisma.CallBreakRoundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          deleteMany: {
            args: Prisma.CallBreakRoundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallBreakRoundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallBreakRoundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>[]
          }
          upsert: {
            args: Prisma.CallBreakRoundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallBreakRoundPayload>
          }
          aggregate: {
            args: Prisma.CallBreakRoundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallBreakRound>
          }
          groupBy: {
            args: Prisma.CallBreakRoundGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallBreakRoundGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallBreakRoundCountArgs<ExtArgs>
            result: $Utils.Optional<CallBreakRoundCountAggregateOutputType> | number
          }
        }
      }
      LiteraturePlayer: {
        payload: Prisma.$LiteraturePlayerPayload<ExtArgs>
        fields: Prisma.LiteraturePlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteraturePlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteraturePlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          findFirst: {
            args: Prisma.LiteraturePlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteraturePlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          findMany: {
            args: Prisma.LiteraturePlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>[]
          }
          create: {
            args: Prisma.LiteraturePlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          createMany: {
            args: Prisma.LiteraturePlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteraturePlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>[]
          }
          delete: {
            args: Prisma.LiteraturePlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          update: {
            args: Prisma.LiteraturePlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          deleteMany: {
            args: Prisma.LiteraturePlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteraturePlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteraturePlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>[]
          }
          upsert: {
            args: Prisma.LiteraturePlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteraturePlayerPayload>
          }
          aggregate: {
            args: Prisma.LiteraturePlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteraturePlayer>
          }
          groupBy: {
            args: Prisma.LiteraturePlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteraturePlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteraturePlayerCountArgs<ExtArgs>
            result: $Utils.Optional<LiteraturePlayerCountAggregateOutputType> | number
          }
        }
      }
      LiteratureTeam: {
        payload: Prisma.$LiteratureTeamPayload<ExtArgs>
        fields: Prisma.LiteratureTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          findFirst: {
            args: Prisma.LiteratureTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          findMany: {
            args: Prisma.LiteratureTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>[]
          }
          create: {
            args: Prisma.LiteratureTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          createMany: {
            args: Prisma.LiteratureTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>[]
          }
          delete: {
            args: Prisma.LiteratureTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          update: {
            args: Prisma.LiteratureTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTeamPayload>
          }
          aggregate: {
            args: Prisma.LiteratureTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureTeam>
          }
          groupBy: {
            args: Prisma.LiteratureTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureTeamCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureTeamCountAggregateOutputType> | number
          }
        }
      }
      LiteratureCardMapping: {
        payload: Prisma.$LiteratureCardMappingPayload<ExtArgs>
        fields: Prisma.LiteratureCardMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureCardMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureCardMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          findFirst: {
            args: Prisma.LiteratureCardMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureCardMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          findMany: {
            args: Prisma.LiteratureCardMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>[]
          }
          create: {
            args: Prisma.LiteratureCardMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          createMany: {
            args: Prisma.LiteratureCardMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureCardMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>[]
          }
          delete: {
            args: Prisma.LiteratureCardMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          update: {
            args: Prisma.LiteratureCardMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureCardMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureCardMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureCardMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureCardMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardMappingPayload>
          }
          aggregate: {
            args: Prisma.LiteratureCardMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureCardMapping>
          }
          groupBy: {
            args: Prisma.LiteratureCardMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCardMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureCardMappingCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCardMappingCountAggregateOutputType> | number
          }
        }
      }
      LiteratureCardLocation: {
        payload: Prisma.$LiteratureCardLocationPayload<ExtArgs>
        fields: Prisma.LiteratureCardLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureCardLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureCardLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          findFirst: {
            args: Prisma.LiteratureCardLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureCardLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          findMany: {
            args: Prisma.LiteratureCardLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>[]
          }
          create: {
            args: Prisma.LiteratureCardLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          createMany: {
            args: Prisma.LiteratureCardLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureCardLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>[]
          }
          delete: {
            args: Prisma.LiteratureCardLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          update: {
            args: Prisma.LiteratureCardLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureCardLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureCardLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureCardLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureCardLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCardLocationPayload>
          }
          aggregate: {
            args: Prisma.LiteratureCardLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureCardLocation>
          }
          groupBy: {
            args: Prisma.LiteratureCardLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCardLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureCardLocationCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCardLocationCountAggregateOutputType> | number
          }
        }
      }
      LiteratureAsk: {
        payload: Prisma.$LiteratureAskPayload<ExtArgs>
        fields: Prisma.LiteratureAskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureAskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureAskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          findFirst: {
            args: Prisma.LiteratureAskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureAskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          findMany: {
            args: Prisma.LiteratureAskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>[]
          }
          create: {
            args: Prisma.LiteratureAskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          createMany: {
            args: Prisma.LiteratureAskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureAskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>[]
          }
          delete: {
            args: Prisma.LiteratureAskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          update: {
            args: Prisma.LiteratureAskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureAskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureAskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureAskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureAskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureAskPayload>
          }
          aggregate: {
            args: Prisma.LiteratureAskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureAsk>
          }
          groupBy: {
            args: Prisma.LiteratureAskGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureAskGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureAskCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureAskCountAggregateOutputType> | number
          }
        }
      }
      LiteratureCall: {
        payload: Prisma.$LiteratureCallPayload<ExtArgs>
        fields: Prisma.LiteratureCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          findFirst: {
            args: Prisma.LiteratureCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          findMany: {
            args: Prisma.LiteratureCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>[]
          }
          create: {
            args: Prisma.LiteratureCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          createMany: {
            args: Prisma.LiteratureCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>[]
          }
          delete: {
            args: Prisma.LiteratureCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          update: {
            args: Prisma.LiteratureCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureCallUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureCallPayload>
          }
          aggregate: {
            args: Prisma.LiteratureCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureCall>
          }
          groupBy: {
            args: Prisma.LiteratureCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureCallCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureCallCountAggregateOutputType> | number
          }
        }
      }
      LiteratureTransfer: {
        payload: Prisma.$LiteratureTransferPayload<ExtArgs>
        fields: Prisma.LiteratureTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          findFirst: {
            args: Prisma.LiteratureTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          findMany: {
            args: Prisma.LiteratureTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>[]
          }
          create: {
            args: Prisma.LiteratureTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          createMany: {
            args: Prisma.LiteratureTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>[]
          }
          delete: {
            args: Prisma.LiteratureTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          update: {
            args: Prisma.LiteratureTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          deleteMany: {
            args: Prisma.LiteratureTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>[]
          }
          upsert: {
            args: Prisma.LiteratureTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureTransferPayload>
          }
          aggregate: {
            args: Prisma.LiteratureTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureTransfer>
          }
          groupBy: {
            args: Prisma.LiteratureTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureTransferCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureTransferCountAggregateOutputType> | number
          }
        }
      }
      LiteratureGame: {
        payload: Prisma.$LiteratureGamePayload<ExtArgs>
        fields: Prisma.LiteratureGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiteratureGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiteratureGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          findFirst: {
            args: Prisma.LiteratureGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiteratureGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          findMany: {
            args: Prisma.LiteratureGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>[]
          }
          create: {
            args: Prisma.LiteratureGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          createMany: {
            args: Prisma.LiteratureGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiteratureGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>[]
          }
          delete: {
            args: Prisma.LiteratureGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          update: {
            args: Prisma.LiteratureGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          deleteMany: {
            args: Prisma.LiteratureGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiteratureGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiteratureGameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>[]
          }
          upsert: {
            args: Prisma.LiteratureGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiteratureGamePayload>
          }
          aggregate: {
            args: Prisma.LiteratureGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiteratureGame>
          }
          groupBy: {
            args: Prisma.LiteratureGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiteratureGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiteratureGameCountArgs<ExtArgs>
            result: $Utils.Optional<LiteratureGameCountAggregateOutputType> | number
          }
        }
      }
      WordleGame: {
        payload: Prisma.$WordleGamePayload<ExtArgs>
        fields: Prisma.WordleGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WordleGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WordleGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          findFirst: {
            args: Prisma.WordleGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WordleGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          findMany: {
            args: Prisma.WordleGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>[]
          }
          create: {
            args: Prisma.WordleGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          createMany: {
            args: Prisma.WordleGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WordleGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>[]
          }
          delete: {
            args: Prisma.WordleGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          update: {
            args: Prisma.WordleGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          deleteMany: {
            args: Prisma.WordleGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WordleGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WordleGameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>[]
          }
          upsert: {
            args: Prisma.WordleGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WordleGamePayload>
          }
          aggregate: {
            args: Prisma.WordleGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWordleGame>
          }
          groupBy: {
            args: Prisma.WordleGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<WordleGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.WordleGameCountArgs<ExtArgs>
            result: $Utils.Optional<WordleGameCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    callBreakGame?: CallBreakGameOmit
    callBreakPlayer?: CallBreakPlayerOmit
    callBreakDeal?: CallBreakDealOmit
    callBreakCardMapping?: CallBreakCardMappingOmit
    callBreakRound?: CallBreakRoundOmit
    literaturePlayer?: LiteraturePlayerOmit
    literatureTeam?: LiteratureTeamOmit
    literatureCardMapping?: LiteratureCardMappingOmit
    literatureCardLocation?: LiteratureCardLocationOmit
    literatureAsk?: LiteratureAskOmit
    literatureCall?: LiteratureCallOmit
    literatureTransfer?: LiteratureTransferOmit
    literatureGame?: LiteratureGameOmit
    wordleGame?: WordleGameOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type CallBreakGameCountOutputType
   */

  export type CallBreakGameCountOutputType = {
    players: number
    deals: number
    cardMappings: number
    rounds: number
  }

  export type CallBreakGameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | CallBreakGameCountOutputTypeCountPlayersArgs
    deals?: boolean | CallBreakGameCountOutputTypeCountDealsArgs
    cardMappings?: boolean | CallBreakGameCountOutputTypeCountCardMappingsArgs
    rounds?: boolean | CallBreakGameCountOutputTypeCountRoundsArgs
  }

  // Custom InputTypes
  /**
   * CallBreakGameCountOutputType without action
   */
  export type CallBreakGameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGameCountOutputType
     */
    select?: CallBreakGameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CallBreakGameCountOutputType without action
   */
  export type CallBreakGameCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakPlayerWhereInput
  }

  /**
   * CallBreakGameCountOutputType without action
   */
  export type CallBreakGameCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakDealWhereInput
  }

  /**
   * CallBreakGameCountOutputType without action
   */
  export type CallBreakGameCountOutputTypeCountCardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakCardMappingWhereInput
  }

  /**
   * CallBreakGameCountOutputType without action
   */
  export type CallBreakGameCountOutputTypeCountRoundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakRoundWhereInput
  }


  /**
   * Count Type CallBreakPlayerCountOutputType
   */

  export type CallBreakPlayerCountOutputType = {
    cardMappings: number
  }

  export type CallBreakPlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardMappings?: boolean | CallBreakPlayerCountOutputTypeCountCardMappingsArgs
  }

  // Custom InputTypes
  /**
   * CallBreakPlayerCountOutputType without action
   */
  export type CallBreakPlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayerCountOutputType
     */
    select?: CallBreakPlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CallBreakPlayerCountOutputType without action
   */
  export type CallBreakPlayerCountOutputTypeCountCardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakCardMappingWhereInput
  }


  /**
   * Count Type CallBreakDealCountOutputType
   */

  export type CallBreakDealCountOutputType = {
    cardMappings: number
    rounds: number
  }

  export type CallBreakDealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardMappings?: boolean | CallBreakDealCountOutputTypeCountCardMappingsArgs
    rounds?: boolean | CallBreakDealCountOutputTypeCountRoundsArgs
  }

  // Custom InputTypes
  /**
   * CallBreakDealCountOutputType without action
   */
  export type CallBreakDealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDealCountOutputType
     */
    select?: CallBreakDealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CallBreakDealCountOutputType without action
   */
  export type CallBreakDealCountOutputTypeCountCardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakCardMappingWhereInput
  }

  /**
   * CallBreakDealCountOutputType without action
   */
  export type CallBreakDealCountOutputTypeCountRoundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakRoundWhereInput
  }


  /**
   * Count Type LiteraturePlayerCountOutputType
   */

  export type LiteraturePlayerCountOutputType = {
    cardMappings: number
    cardLocations: number
    asks: number
    calls: number
    transfers: number
  }

  export type LiteraturePlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardMappings?: boolean | LiteraturePlayerCountOutputTypeCountCardMappingsArgs
    cardLocations?: boolean | LiteraturePlayerCountOutputTypeCountCardLocationsArgs
    asks?: boolean | LiteraturePlayerCountOutputTypeCountAsksArgs
    calls?: boolean | LiteraturePlayerCountOutputTypeCountCallsArgs
    transfers?: boolean | LiteraturePlayerCountOutputTypeCountTransfersArgs
  }

  // Custom InputTypes
  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayerCountOutputType
     */
    select?: LiteraturePlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeCountCardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardMappingWhereInput
  }

  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeCountCardLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardLocationWhereInput
  }

  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeCountAsksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureAskWhereInput
  }

  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCallWhereInput
  }

  /**
   * LiteraturePlayerCountOutputType without action
   */
  export type LiteraturePlayerCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureTransferWhereInput
  }


  /**
   * Count Type LiteratureTeamCountOutputType
   */

  export type LiteratureTeamCountOutputType = {
    members: number
  }

  export type LiteratureTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | LiteratureTeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * LiteratureTeamCountOutputType without action
   */
  export type LiteratureTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeamCountOutputType
     */
    select?: LiteratureTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiteratureTeamCountOutputType without action
   */
  export type LiteratureTeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteraturePlayerWhereInput
  }


  /**
   * Count Type LiteratureGameCountOutputType
   */

  export type LiteratureGameCountOutputType = {
    players: number
    teams: number
    cardMappings: number
    cardLocations: number
    asks: number
    calls: number
    transfers: number
  }

  export type LiteratureGameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | LiteratureGameCountOutputTypeCountPlayersArgs
    teams?: boolean | LiteratureGameCountOutputTypeCountTeamsArgs
    cardMappings?: boolean | LiteratureGameCountOutputTypeCountCardMappingsArgs
    cardLocations?: boolean | LiteratureGameCountOutputTypeCountCardLocationsArgs
    asks?: boolean | LiteratureGameCountOutputTypeCountAsksArgs
    calls?: boolean | LiteratureGameCountOutputTypeCountCallsArgs
    transfers?: boolean | LiteratureGameCountOutputTypeCountTransfersArgs
  }

  // Custom InputTypes
  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGameCountOutputType
     */
    select?: LiteratureGameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteraturePlayerWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureTeamWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountCardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardMappingWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountCardLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardLocationWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountAsksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureAskWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCallWhereInput
  }

  /**
   * LiteratureGameCountOutputType without action
   */
  export type LiteratureGameCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureTransferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string
    userAgent: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string
      userAgent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    providerId: string | null
    accountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    providerId: string | null
    accountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    providerId: number
    accountId: number
    refreshToken: number
    accessToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    idToken: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    accountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    accountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    accountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    providerId: string
    accountId: string
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerId?: boolean
    accountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerId?: boolean
    accountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerId?: boolean
    accountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    providerId?: boolean
    accountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "providerId" | "accountId" | "refreshToken" | "accessToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "idToken" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      providerId: string
      accountId: string
      refreshToken: string | null
      accessToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      idToken: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model CallBreakGame
   */

  export type AggregateCallBreakGame = {
    _count: CallBreakGameCountAggregateOutputType | null
    _avg: CallBreakGameAvgAggregateOutputType | null
    _sum: CallBreakGameSumAggregateOutputType | null
    _min: CallBreakGameMinAggregateOutputType | null
    _max: CallBreakGameMaxAggregateOutputType | null
  }

  export type CallBreakGameAvgAggregateOutputType = {
    dealCount: number | null
  }

  export type CallBreakGameSumAggregateOutputType = {
    dealCount: number | null
  }

  export type CallBreakGameMinAggregateOutputType = {
    id: string | null
    code: string | null
    dealCount: number | null
    trumpSuit: string | null
    status: $Enums.CallBreakStatus | null
    createdBy: string | null
  }

  export type CallBreakGameMaxAggregateOutputType = {
    id: string | null
    code: string | null
    dealCount: number | null
    trumpSuit: string | null
    status: $Enums.CallBreakStatus | null
    createdBy: string | null
  }

  export type CallBreakGameCountAggregateOutputType = {
    id: number
    code: number
    dealCount: number
    trumpSuit: number
    status: number
    createdBy: number
    scores: number
    _all: number
  }


  export type CallBreakGameAvgAggregateInputType = {
    dealCount?: true
  }

  export type CallBreakGameSumAggregateInputType = {
    dealCount?: true
  }

  export type CallBreakGameMinAggregateInputType = {
    id?: true
    code?: true
    dealCount?: true
    trumpSuit?: true
    status?: true
    createdBy?: true
  }

  export type CallBreakGameMaxAggregateInputType = {
    id?: true
    code?: true
    dealCount?: true
    trumpSuit?: true
    status?: true
    createdBy?: true
  }

  export type CallBreakGameCountAggregateInputType = {
    id?: true
    code?: true
    dealCount?: true
    trumpSuit?: true
    status?: true
    createdBy?: true
    scores?: true
    _all?: true
  }

  export type CallBreakGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakGame to aggregate.
     */
    where?: CallBreakGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakGames to fetch.
     */
    orderBy?: CallBreakGameOrderByWithRelationInput | CallBreakGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallBreakGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallBreakGames
    **/
    _count?: true | CallBreakGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallBreakGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallBreakGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallBreakGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallBreakGameMaxAggregateInputType
  }

  export type GetCallBreakGameAggregateType<T extends CallBreakGameAggregateArgs> = {
        [P in keyof T & keyof AggregateCallBreakGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallBreakGame[P]>
      : GetScalarType<T[P], AggregateCallBreakGame[P]>
  }




  export type CallBreakGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakGameWhereInput
    orderBy?: CallBreakGameOrderByWithAggregationInput | CallBreakGameOrderByWithAggregationInput[]
    by: CallBreakGameScalarFieldEnum[] | CallBreakGameScalarFieldEnum
    having?: CallBreakGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallBreakGameCountAggregateInputType | true
    _avg?: CallBreakGameAvgAggregateInputType
    _sum?: CallBreakGameSumAggregateInputType
    _min?: CallBreakGameMinAggregateInputType
    _max?: CallBreakGameMaxAggregateInputType
  }

  export type CallBreakGameGroupByOutputType = {
    id: string
    code: string
    dealCount: number
    trumpSuit: string
    status: $Enums.CallBreakStatus
    createdBy: string
    scores: (Array<Record<string, number>>)
    _count: CallBreakGameCountAggregateOutputType | null
    _avg: CallBreakGameAvgAggregateOutputType | null
    _sum: CallBreakGameSumAggregateOutputType | null
    _min: CallBreakGameMinAggregateOutputType | null
    _max: CallBreakGameMaxAggregateOutputType | null
  }

  type GetCallBreakGameGroupByPayload<T extends CallBreakGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallBreakGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallBreakGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallBreakGameGroupByOutputType[P]>
            : GetScalarType<T[P], CallBreakGameGroupByOutputType[P]>
        }
      >
    >


  export type CallBreakGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    dealCount?: boolean
    trumpSuit?: boolean
    status?: boolean
    createdBy?: boolean
    scores?: boolean
    players?: boolean | CallBreakGame$playersArgs<ExtArgs>
    deals?: boolean | CallBreakGame$dealsArgs<ExtArgs>
    cardMappings?: boolean | CallBreakGame$cardMappingsArgs<ExtArgs>
    rounds?: boolean | CallBreakGame$roundsArgs<ExtArgs>
    _count?: boolean | CallBreakGameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakGame"]>

  export type CallBreakGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    dealCount?: boolean
    trumpSuit?: boolean
    status?: boolean
    createdBy?: boolean
    scores?: boolean
  }, ExtArgs["result"]["callBreakGame"]>

  export type CallBreakGameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    dealCount?: boolean
    trumpSuit?: boolean
    status?: boolean
    createdBy?: boolean
    scores?: boolean
  }, ExtArgs["result"]["callBreakGame"]>

  export type CallBreakGameSelectScalar = {
    id?: boolean
    code?: boolean
    dealCount?: boolean
    trumpSuit?: boolean
    status?: boolean
    createdBy?: boolean
    scores?: boolean
  }

  export type CallBreakGameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "dealCount" | "trumpSuit" | "status" | "createdBy" | "scores", ExtArgs["result"]["callBreakGame"]>
  export type CallBreakGameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | CallBreakGame$playersArgs<ExtArgs>
    deals?: boolean | CallBreakGame$dealsArgs<ExtArgs>
    cardMappings?: boolean | CallBreakGame$cardMappingsArgs<ExtArgs>
    rounds?: boolean | CallBreakGame$roundsArgs<ExtArgs>
    _count?: boolean | CallBreakGameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CallBreakGameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CallBreakGameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CallBreakGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallBreakGame"
    objects: {
      players: Prisma.$CallBreakPlayerPayload<ExtArgs>[]
      deals: Prisma.$CallBreakDealPayload<ExtArgs>[]
      cardMappings: Prisma.$CallBreakCardMappingPayload<ExtArgs>[]
      rounds: Prisma.$CallBreakRoundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      dealCount: number
      trumpSuit: string
      status: $Enums.CallBreakStatus
      createdBy: string
      /**
       * ![Array<Record<string, number>>]
       */
      scores: (Array<Record<string, number>>)
    }, ExtArgs["result"]["callBreakGame"]>
    composites: {}
  }

  type CallBreakGameGetPayload<S extends boolean | null | undefined | CallBreakGameDefaultArgs> = $Result.GetResult<Prisma.$CallBreakGamePayload, S>

  type CallBreakGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallBreakGameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallBreakGameCountAggregateInputType | true
    }

  export interface CallBreakGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallBreakGame'], meta: { name: 'CallBreakGame' } }
    /**
     * Find zero or one CallBreakGame that matches the filter.
     * @param {CallBreakGameFindUniqueArgs} args - Arguments to find a CallBreakGame
     * @example
     * // Get one CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallBreakGameFindUniqueArgs>(args: SelectSubset<T, CallBreakGameFindUniqueArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CallBreakGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallBreakGameFindUniqueOrThrowArgs} args - Arguments to find a CallBreakGame
     * @example
     * // Get one CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallBreakGameFindUniqueOrThrowArgs>(args: SelectSubset<T, CallBreakGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameFindFirstArgs} args - Arguments to find a CallBreakGame
     * @example
     * // Get one CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallBreakGameFindFirstArgs>(args?: SelectSubset<T, CallBreakGameFindFirstArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameFindFirstOrThrowArgs} args - Arguments to find a CallBreakGame
     * @example
     * // Get one CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallBreakGameFindFirstOrThrowArgs>(args?: SelectSubset<T, CallBreakGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CallBreakGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallBreakGames
     * const callBreakGames = await prisma.callBreakGame.findMany()
     * 
     * // Get first 10 CallBreakGames
     * const callBreakGames = await prisma.callBreakGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callBreakGameWithIdOnly = await prisma.callBreakGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallBreakGameFindManyArgs>(args?: SelectSubset<T, CallBreakGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CallBreakGame.
     * @param {CallBreakGameCreateArgs} args - Arguments to create a CallBreakGame.
     * @example
     * // Create one CallBreakGame
     * const CallBreakGame = await prisma.callBreakGame.create({
     *   data: {
     *     // ... data to create a CallBreakGame
     *   }
     * })
     * 
     */
    create<T extends CallBreakGameCreateArgs>(args: SelectSubset<T, CallBreakGameCreateArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CallBreakGames.
     * @param {CallBreakGameCreateManyArgs} args - Arguments to create many CallBreakGames.
     * @example
     * // Create many CallBreakGames
     * const callBreakGame = await prisma.callBreakGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallBreakGameCreateManyArgs>(args?: SelectSubset<T, CallBreakGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallBreakGames and returns the data saved in the database.
     * @param {CallBreakGameCreateManyAndReturnArgs} args - Arguments to create many CallBreakGames.
     * @example
     * // Create many CallBreakGames
     * const callBreakGame = await prisma.callBreakGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallBreakGames and only return the `id`
     * const callBreakGameWithIdOnly = await prisma.callBreakGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallBreakGameCreateManyAndReturnArgs>(args?: SelectSubset<T, CallBreakGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CallBreakGame.
     * @param {CallBreakGameDeleteArgs} args - Arguments to delete one CallBreakGame.
     * @example
     * // Delete one CallBreakGame
     * const CallBreakGame = await prisma.callBreakGame.delete({
     *   where: {
     *     // ... filter to delete one CallBreakGame
     *   }
     * })
     * 
     */
    delete<T extends CallBreakGameDeleteArgs>(args: SelectSubset<T, CallBreakGameDeleteArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CallBreakGame.
     * @param {CallBreakGameUpdateArgs} args - Arguments to update one CallBreakGame.
     * @example
     * // Update one CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallBreakGameUpdateArgs>(args: SelectSubset<T, CallBreakGameUpdateArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CallBreakGames.
     * @param {CallBreakGameDeleteManyArgs} args - Arguments to filter CallBreakGames to delete.
     * @example
     * // Delete a few CallBreakGames
     * const { count } = await prisma.callBreakGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallBreakGameDeleteManyArgs>(args?: SelectSubset<T, CallBreakGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallBreakGames
     * const callBreakGame = await prisma.callBreakGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallBreakGameUpdateManyArgs>(args: SelectSubset<T, CallBreakGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakGames and returns the data updated in the database.
     * @param {CallBreakGameUpdateManyAndReturnArgs} args - Arguments to update many CallBreakGames.
     * @example
     * // Update many CallBreakGames
     * const callBreakGame = await prisma.callBreakGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallBreakGames and only return the `id`
     * const callBreakGameWithIdOnly = await prisma.callBreakGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallBreakGameUpdateManyAndReturnArgs>(args: SelectSubset<T, CallBreakGameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CallBreakGame.
     * @param {CallBreakGameUpsertArgs} args - Arguments to update or create a CallBreakGame.
     * @example
     * // Update or create a CallBreakGame
     * const callBreakGame = await prisma.callBreakGame.upsert({
     *   create: {
     *     // ... data to create a CallBreakGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallBreakGame we want to update
     *   }
     * })
     */
    upsert<T extends CallBreakGameUpsertArgs>(args: SelectSubset<T, CallBreakGameUpsertArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CallBreakGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameCountArgs} args - Arguments to filter CallBreakGames to count.
     * @example
     * // Count the number of CallBreakGames
     * const count = await prisma.callBreakGame.count({
     *   where: {
     *     // ... the filter for the CallBreakGames we want to count
     *   }
     * })
    **/
    count<T extends CallBreakGameCountArgs>(
      args?: Subset<T, CallBreakGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallBreakGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallBreakGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallBreakGameAggregateArgs>(args: Subset<T, CallBreakGameAggregateArgs>): Prisma.PrismaPromise<GetCallBreakGameAggregateType<T>>

    /**
     * Group by CallBreakGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallBreakGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallBreakGameGroupByArgs['orderBy'] }
        : { orderBy?: CallBreakGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallBreakGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallBreakGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallBreakGame model
   */
  readonly fields: CallBreakGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallBreakGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallBreakGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends CallBreakGame$playersArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGame$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    deals<T extends CallBreakGame$dealsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGame$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cardMappings<T extends CallBreakGame$cardMappingsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGame$cardMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rounds<T extends CallBreakGame$roundsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGame$roundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallBreakGame model
   */ 
  interface CallBreakGameFieldRefs {
    readonly id: FieldRef<"CallBreakGame", 'String'>
    readonly code: FieldRef<"CallBreakGame", 'String'>
    readonly dealCount: FieldRef<"CallBreakGame", 'Int'>
    readonly trumpSuit: FieldRef<"CallBreakGame", 'String'>
    readonly status: FieldRef<"CallBreakGame", 'CallBreakStatus'>
    readonly createdBy: FieldRef<"CallBreakGame", 'String'>
    readonly scores: FieldRef<"CallBreakGame", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CallBreakGame findUnique
   */
  export type CallBreakGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakGame to fetch.
     */
    where: CallBreakGameWhereUniqueInput
  }

  /**
   * CallBreakGame findUniqueOrThrow
   */
  export type CallBreakGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakGame to fetch.
     */
    where: CallBreakGameWhereUniqueInput
  }

  /**
   * CallBreakGame findFirst
   */
  export type CallBreakGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakGame to fetch.
     */
    where?: CallBreakGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakGames to fetch.
     */
    orderBy?: CallBreakGameOrderByWithRelationInput | CallBreakGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakGames.
     */
    cursor?: CallBreakGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakGames.
     */
    distinct?: CallBreakGameScalarFieldEnum | CallBreakGameScalarFieldEnum[]
  }

  /**
   * CallBreakGame findFirstOrThrow
   */
  export type CallBreakGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakGame to fetch.
     */
    where?: CallBreakGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakGames to fetch.
     */
    orderBy?: CallBreakGameOrderByWithRelationInput | CallBreakGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakGames.
     */
    cursor?: CallBreakGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakGames.
     */
    distinct?: CallBreakGameScalarFieldEnum | CallBreakGameScalarFieldEnum[]
  }

  /**
   * CallBreakGame findMany
   */
  export type CallBreakGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakGames to fetch.
     */
    where?: CallBreakGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakGames to fetch.
     */
    orderBy?: CallBreakGameOrderByWithRelationInput | CallBreakGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallBreakGames.
     */
    cursor?: CallBreakGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakGames.
     */
    skip?: number
    distinct?: CallBreakGameScalarFieldEnum | CallBreakGameScalarFieldEnum[]
  }

  /**
   * CallBreakGame create
   */
  export type CallBreakGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * The data needed to create a CallBreakGame.
     */
    data: XOR<CallBreakGameCreateInput, CallBreakGameUncheckedCreateInput>
  }

  /**
   * CallBreakGame createMany
   */
  export type CallBreakGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallBreakGames.
     */
    data: CallBreakGameCreateManyInput | CallBreakGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakGame createManyAndReturn
   */
  export type CallBreakGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * The data used to create many CallBreakGames.
     */
    data: CallBreakGameCreateManyInput | CallBreakGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakGame update
   */
  export type CallBreakGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * The data needed to update a CallBreakGame.
     */
    data: XOR<CallBreakGameUpdateInput, CallBreakGameUncheckedUpdateInput>
    /**
     * Choose, which CallBreakGame to update.
     */
    where: CallBreakGameWhereUniqueInput
  }

  /**
   * CallBreakGame updateMany
   */
  export type CallBreakGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallBreakGames.
     */
    data: XOR<CallBreakGameUpdateManyMutationInput, CallBreakGameUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakGames to update
     */
    where?: CallBreakGameWhereInput
    /**
     * Limit how many CallBreakGames to update.
     */
    limit?: number
  }

  /**
   * CallBreakGame updateManyAndReturn
   */
  export type CallBreakGameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * The data used to update CallBreakGames.
     */
    data: XOR<CallBreakGameUpdateManyMutationInput, CallBreakGameUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakGames to update
     */
    where?: CallBreakGameWhereInput
    /**
     * Limit how many CallBreakGames to update.
     */
    limit?: number
  }

  /**
   * CallBreakGame upsert
   */
  export type CallBreakGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * The filter to search for the CallBreakGame to update in case it exists.
     */
    where: CallBreakGameWhereUniqueInput
    /**
     * In case the CallBreakGame found by the `where` argument doesn't exist, create a new CallBreakGame with this data.
     */
    create: XOR<CallBreakGameCreateInput, CallBreakGameUncheckedCreateInput>
    /**
     * In case the CallBreakGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallBreakGameUpdateInput, CallBreakGameUncheckedUpdateInput>
  }

  /**
   * CallBreakGame delete
   */
  export type CallBreakGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
    /**
     * Filter which CallBreakGame to delete.
     */
    where: CallBreakGameWhereUniqueInput
  }

  /**
   * CallBreakGame deleteMany
   */
  export type CallBreakGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakGames to delete
     */
    where?: CallBreakGameWhereInput
    /**
     * Limit how many CallBreakGames to delete.
     */
    limit?: number
  }

  /**
   * CallBreakGame.players
   */
  export type CallBreakGame$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    where?: CallBreakPlayerWhereInput
    orderBy?: CallBreakPlayerOrderByWithRelationInput | CallBreakPlayerOrderByWithRelationInput[]
    cursor?: CallBreakPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakPlayerScalarFieldEnum | CallBreakPlayerScalarFieldEnum[]
  }

  /**
   * CallBreakGame.deals
   */
  export type CallBreakGame$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    where?: CallBreakDealWhereInput
    orderBy?: CallBreakDealOrderByWithRelationInput | CallBreakDealOrderByWithRelationInput[]
    cursor?: CallBreakDealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakDealScalarFieldEnum | CallBreakDealScalarFieldEnum[]
  }

  /**
   * CallBreakGame.cardMappings
   */
  export type CallBreakGame$cardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    where?: CallBreakCardMappingWhereInput
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    cursor?: CallBreakCardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakGame.rounds
   */
  export type CallBreakGame$roundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    where?: CallBreakRoundWhereInput
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    cursor?: CallBreakRoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakRoundScalarFieldEnum | CallBreakRoundScalarFieldEnum[]
  }

  /**
   * CallBreakGame without action
   */
  export type CallBreakGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakGame
     */
    select?: CallBreakGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakGame
     */
    omit?: CallBreakGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakGameInclude<ExtArgs> | null
  }


  /**
   * Model CallBreakPlayer
   */

  export type AggregateCallBreakPlayer = {
    _count: CallBreakPlayerCountAggregateOutputType | null
    _min: CallBreakPlayerMinAggregateOutputType | null
    _max: CallBreakPlayerMaxAggregateOutputType | null
  }

  export type CallBreakPlayerMinAggregateOutputType = {
    id: string | null
    name: string | null
    avatar: string | null
    gameId: string | null
    isBot: boolean | null
  }

  export type CallBreakPlayerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    avatar: string | null
    gameId: string | null
    isBot: boolean | null
  }

  export type CallBreakPlayerCountAggregateOutputType = {
    id: number
    name: number
    avatar: number
    gameId: number
    isBot: number
    _all: number
  }


  export type CallBreakPlayerMinAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    isBot?: true
  }

  export type CallBreakPlayerMaxAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    isBot?: true
  }

  export type CallBreakPlayerCountAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    isBot?: true
    _all?: true
  }

  export type CallBreakPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakPlayer to aggregate.
     */
    where?: CallBreakPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakPlayers to fetch.
     */
    orderBy?: CallBreakPlayerOrderByWithRelationInput | CallBreakPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallBreakPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallBreakPlayers
    **/
    _count?: true | CallBreakPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallBreakPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallBreakPlayerMaxAggregateInputType
  }

  export type GetCallBreakPlayerAggregateType<T extends CallBreakPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateCallBreakPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallBreakPlayer[P]>
      : GetScalarType<T[P], AggregateCallBreakPlayer[P]>
  }




  export type CallBreakPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakPlayerWhereInput
    orderBy?: CallBreakPlayerOrderByWithAggregationInput | CallBreakPlayerOrderByWithAggregationInput[]
    by: CallBreakPlayerScalarFieldEnum[] | CallBreakPlayerScalarFieldEnum
    having?: CallBreakPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallBreakPlayerCountAggregateInputType | true
    _min?: CallBreakPlayerMinAggregateInputType
    _max?: CallBreakPlayerMaxAggregateInputType
  }

  export type CallBreakPlayerGroupByOutputType = {
    id: string
    name: string
    avatar: string
    gameId: string
    isBot: boolean
    _count: CallBreakPlayerCountAggregateOutputType | null
    _min: CallBreakPlayerMinAggregateOutputType | null
    _max: CallBreakPlayerMaxAggregateOutputType | null
  }

  type GetCallBreakPlayerGroupByPayload<T extends CallBreakPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallBreakPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallBreakPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallBreakPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], CallBreakPlayerGroupByOutputType[P]>
        }
      >
    >


  export type CallBreakPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    isBot?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    cardMappings?: boolean | CallBreakPlayer$cardMappingsArgs<ExtArgs>
    _count?: boolean | CallBreakPlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakPlayer"]>

  export type CallBreakPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    isBot?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakPlayer"]>

  export type CallBreakPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    isBot?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakPlayer"]>

  export type CallBreakPlayerSelectScalar = {
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    isBot?: boolean
  }

  export type CallBreakPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "avatar" | "gameId" | "isBot", ExtArgs["result"]["callBreakPlayer"]>
  export type CallBreakPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    cardMappings?: boolean | CallBreakPlayer$cardMappingsArgs<ExtArgs>
    _count?: boolean | CallBreakPlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CallBreakPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }
  export type CallBreakPlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }

  export type $CallBreakPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallBreakPlayer"
    objects: {
      game: Prisma.$CallBreakGamePayload<ExtArgs>
      cardMappings: Prisma.$CallBreakCardMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      avatar: string
      gameId: string
      isBot: boolean
    }, ExtArgs["result"]["callBreakPlayer"]>
    composites: {}
  }

  type CallBreakPlayerGetPayload<S extends boolean | null | undefined | CallBreakPlayerDefaultArgs> = $Result.GetResult<Prisma.$CallBreakPlayerPayload, S>

  type CallBreakPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallBreakPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallBreakPlayerCountAggregateInputType | true
    }

  export interface CallBreakPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallBreakPlayer'], meta: { name: 'CallBreakPlayer' } }
    /**
     * Find zero or one CallBreakPlayer that matches the filter.
     * @param {CallBreakPlayerFindUniqueArgs} args - Arguments to find a CallBreakPlayer
     * @example
     * // Get one CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallBreakPlayerFindUniqueArgs>(args: SelectSubset<T, CallBreakPlayerFindUniqueArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CallBreakPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallBreakPlayerFindUniqueOrThrowArgs} args - Arguments to find a CallBreakPlayer
     * @example
     * // Get one CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallBreakPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, CallBreakPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerFindFirstArgs} args - Arguments to find a CallBreakPlayer
     * @example
     * // Get one CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallBreakPlayerFindFirstArgs>(args?: SelectSubset<T, CallBreakPlayerFindFirstArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerFindFirstOrThrowArgs} args - Arguments to find a CallBreakPlayer
     * @example
     * // Get one CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallBreakPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, CallBreakPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CallBreakPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallBreakPlayers
     * const callBreakPlayers = await prisma.callBreakPlayer.findMany()
     * 
     * // Get first 10 CallBreakPlayers
     * const callBreakPlayers = await prisma.callBreakPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callBreakPlayerWithIdOnly = await prisma.callBreakPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallBreakPlayerFindManyArgs>(args?: SelectSubset<T, CallBreakPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CallBreakPlayer.
     * @param {CallBreakPlayerCreateArgs} args - Arguments to create a CallBreakPlayer.
     * @example
     * // Create one CallBreakPlayer
     * const CallBreakPlayer = await prisma.callBreakPlayer.create({
     *   data: {
     *     // ... data to create a CallBreakPlayer
     *   }
     * })
     * 
     */
    create<T extends CallBreakPlayerCreateArgs>(args: SelectSubset<T, CallBreakPlayerCreateArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CallBreakPlayers.
     * @param {CallBreakPlayerCreateManyArgs} args - Arguments to create many CallBreakPlayers.
     * @example
     * // Create many CallBreakPlayers
     * const callBreakPlayer = await prisma.callBreakPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallBreakPlayerCreateManyArgs>(args?: SelectSubset<T, CallBreakPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallBreakPlayers and returns the data saved in the database.
     * @param {CallBreakPlayerCreateManyAndReturnArgs} args - Arguments to create many CallBreakPlayers.
     * @example
     * // Create many CallBreakPlayers
     * const callBreakPlayer = await prisma.callBreakPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallBreakPlayers and only return the `id`
     * const callBreakPlayerWithIdOnly = await prisma.callBreakPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallBreakPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, CallBreakPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CallBreakPlayer.
     * @param {CallBreakPlayerDeleteArgs} args - Arguments to delete one CallBreakPlayer.
     * @example
     * // Delete one CallBreakPlayer
     * const CallBreakPlayer = await prisma.callBreakPlayer.delete({
     *   where: {
     *     // ... filter to delete one CallBreakPlayer
     *   }
     * })
     * 
     */
    delete<T extends CallBreakPlayerDeleteArgs>(args: SelectSubset<T, CallBreakPlayerDeleteArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CallBreakPlayer.
     * @param {CallBreakPlayerUpdateArgs} args - Arguments to update one CallBreakPlayer.
     * @example
     * // Update one CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallBreakPlayerUpdateArgs>(args: SelectSubset<T, CallBreakPlayerUpdateArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CallBreakPlayers.
     * @param {CallBreakPlayerDeleteManyArgs} args - Arguments to filter CallBreakPlayers to delete.
     * @example
     * // Delete a few CallBreakPlayers
     * const { count } = await prisma.callBreakPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallBreakPlayerDeleteManyArgs>(args?: SelectSubset<T, CallBreakPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallBreakPlayers
     * const callBreakPlayer = await prisma.callBreakPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallBreakPlayerUpdateManyArgs>(args: SelectSubset<T, CallBreakPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakPlayers and returns the data updated in the database.
     * @param {CallBreakPlayerUpdateManyAndReturnArgs} args - Arguments to update many CallBreakPlayers.
     * @example
     * // Update many CallBreakPlayers
     * const callBreakPlayer = await prisma.callBreakPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallBreakPlayers and only return the `id`
     * const callBreakPlayerWithIdOnly = await prisma.callBreakPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallBreakPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, CallBreakPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CallBreakPlayer.
     * @param {CallBreakPlayerUpsertArgs} args - Arguments to update or create a CallBreakPlayer.
     * @example
     * // Update or create a CallBreakPlayer
     * const callBreakPlayer = await prisma.callBreakPlayer.upsert({
     *   create: {
     *     // ... data to create a CallBreakPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallBreakPlayer we want to update
     *   }
     * })
     */
    upsert<T extends CallBreakPlayerUpsertArgs>(args: SelectSubset<T, CallBreakPlayerUpsertArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CallBreakPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerCountArgs} args - Arguments to filter CallBreakPlayers to count.
     * @example
     * // Count the number of CallBreakPlayers
     * const count = await prisma.callBreakPlayer.count({
     *   where: {
     *     // ... the filter for the CallBreakPlayers we want to count
     *   }
     * })
    **/
    count<T extends CallBreakPlayerCountArgs>(
      args?: Subset<T, CallBreakPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallBreakPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallBreakPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallBreakPlayerAggregateArgs>(args: Subset<T, CallBreakPlayerAggregateArgs>): Prisma.PrismaPromise<GetCallBreakPlayerAggregateType<T>>

    /**
     * Group by CallBreakPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallBreakPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallBreakPlayerGroupByArgs['orderBy'] }
        : { orderBy?: CallBreakPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallBreakPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallBreakPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallBreakPlayer model
   */
  readonly fields: CallBreakPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallBreakPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallBreakPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends CallBreakGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGameDefaultArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    cardMappings<T extends CallBreakPlayer$cardMappingsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakPlayer$cardMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallBreakPlayer model
   */ 
  interface CallBreakPlayerFieldRefs {
    readonly id: FieldRef<"CallBreakPlayer", 'String'>
    readonly name: FieldRef<"CallBreakPlayer", 'String'>
    readonly avatar: FieldRef<"CallBreakPlayer", 'String'>
    readonly gameId: FieldRef<"CallBreakPlayer", 'String'>
    readonly isBot: FieldRef<"CallBreakPlayer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CallBreakPlayer findUnique
   */
  export type CallBreakPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakPlayer to fetch.
     */
    where: CallBreakPlayerWhereUniqueInput
  }

  /**
   * CallBreakPlayer findUniqueOrThrow
   */
  export type CallBreakPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakPlayer to fetch.
     */
    where: CallBreakPlayerWhereUniqueInput
  }

  /**
   * CallBreakPlayer findFirst
   */
  export type CallBreakPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakPlayer to fetch.
     */
    where?: CallBreakPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakPlayers to fetch.
     */
    orderBy?: CallBreakPlayerOrderByWithRelationInput | CallBreakPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakPlayers.
     */
    cursor?: CallBreakPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakPlayers.
     */
    distinct?: CallBreakPlayerScalarFieldEnum | CallBreakPlayerScalarFieldEnum[]
  }

  /**
   * CallBreakPlayer findFirstOrThrow
   */
  export type CallBreakPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakPlayer to fetch.
     */
    where?: CallBreakPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakPlayers to fetch.
     */
    orderBy?: CallBreakPlayerOrderByWithRelationInput | CallBreakPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakPlayers.
     */
    cursor?: CallBreakPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakPlayers.
     */
    distinct?: CallBreakPlayerScalarFieldEnum | CallBreakPlayerScalarFieldEnum[]
  }

  /**
   * CallBreakPlayer findMany
   */
  export type CallBreakPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakPlayers to fetch.
     */
    where?: CallBreakPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakPlayers to fetch.
     */
    orderBy?: CallBreakPlayerOrderByWithRelationInput | CallBreakPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallBreakPlayers.
     */
    cursor?: CallBreakPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakPlayers.
     */
    skip?: number
    distinct?: CallBreakPlayerScalarFieldEnum | CallBreakPlayerScalarFieldEnum[]
  }

  /**
   * CallBreakPlayer create
   */
  export type CallBreakPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a CallBreakPlayer.
     */
    data: XOR<CallBreakPlayerCreateInput, CallBreakPlayerUncheckedCreateInput>
  }

  /**
   * CallBreakPlayer createMany
   */
  export type CallBreakPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallBreakPlayers.
     */
    data: CallBreakPlayerCreateManyInput | CallBreakPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakPlayer createManyAndReturn
   */
  export type CallBreakPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many CallBreakPlayers.
     */
    data: CallBreakPlayerCreateManyInput | CallBreakPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakPlayer update
   */
  export type CallBreakPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a CallBreakPlayer.
     */
    data: XOR<CallBreakPlayerUpdateInput, CallBreakPlayerUncheckedUpdateInput>
    /**
     * Choose, which CallBreakPlayer to update.
     */
    where: CallBreakPlayerWhereUniqueInput
  }

  /**
   * CallBreakPlayer updateMany
   */
  export type CallBreakPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallBreakPlayers.
     */
    data: XOR<CallBreakPlayerUpdateManyMutationInput, CallBreakPlayerUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakPlayers to update
     */
    where?: CallBreakPlayerWhereInput
    /**
     * Limit how many CallBreakPlayers to update.
     */
    limit?: number
  }

  /**
   * CallBreakPlayer updateManyAndReturn
   */
  export type CallBreakPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * The data used to update CallBreakPlayers.
     */
    data: XOR<CallBreakPlayerUpdateManyMutationInput, CallBreakPlayerUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakPlayers to update
     */
    where?: CallBreakPlayerWhereInput
    /**
     * Limit how many CallBreakPlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakPlayer upsert
   */
  export type CallBreakPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the CallBreakPlayer to update in case it exists.
     */
    where: CallBreakPlayerWhereUniqueInput
    /**
     * In case the CallBreakPlayer found by the `where` argument doesn't exist, create a new CallBreakPlayer with this data.
     */
    create: XOR<CallBreakPlayerCreateInput, CallBreakPlayerUncheckedCreateInput>
    /**
     * In case the CallBreakPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallBreakPlayerUpdateInput, CallBreakPlayerUncheckedUpdateInput>
  }

  /**
   * CallBreakPlayer delete
   */
  export type CallBreakPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
    /**
     * Filter which CallBreakPlayer to delete.
     */
    where: CallBreakPlayerWhereUniqueInput
  }

  /**
   * CallBreakPlayer deleteMany
   */
  export type CallBreakPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakPlayers to delete
     */
    where?: CallBreakPlayerWhereInput
    /**
     * Limit how many CallBreakPlayers to delete.
     */
    limit?: number
  }

  /**
   * CallBreakPlayer.cardMappings
   */
  export type CallBreakPlayer$cardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    where?: CallBreakCardMappingWhereInput
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    cursor?: CallBreakCardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakPlayer without action
   */
  export type CallBreakPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakPlayer
     */
    select?: CallBreakPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakPlayer
     */
    omit?: CallBreakPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakPlayerInclude<ExtArgs> | null
  }


  /**
   * Model CallBreakDeal
   */

  export type AggregateCallBreakDeal = {
    _count: CallBreakDealCountAggregateOutputType | null
    _avg: CallBreakDealAvgAggregateOutputType | null
    _sum: CallBreakDealSumAggregateOutputType | null
    _min: CallBreakDealMinAggregateOutputType | null
    _max: CallBreakDealMaxAggregateOutputType | null
  }

  export type CallBreakDealAvgAggregateOutputType = {
    turnIdx: number | null
  }

  export type CallBreakDealSumAggregateOutputType = {
    turnIdx: number | null
  }

  export type CallBreakDealMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    turnIdx: number | null
    status: $Enums.CallBreakStatus | null
    createdAt: Date | null
  }

  export type CallBreakDealMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    turnIdx: number | null
    status: $Enums.CallBreakStatus | null
    createdAt: Date | null
  }

  export type CallBreakDealCountAggregateOutputType = {
    id: number
    gameId: number
    playerOrder: number
    declarations: number
    wins: number
    turnIdx: number
    status: number
    createdAt: number
    _all: number
  }


  export type CallBreakDealAvgAggregateInputType = {
    turnIdx?: true
  }

  export type CallBreakDealSumAggregateInputType = {
    turnIdx?: true
  }

  export type CallBreakDealMinAggregateInputType = {
    id?: true
    gameId?: true
    turnIdx?: true
    status?: true
    createdAt?: true
  }

  export type CallBreakDealMaxAggregateInputType = {
    id?: true
    gameId?: true
    turnIdx?: true
    status?: true
    createdAt?: true
  }

  export type CallBreakDealCountAggregateInputType = {
    id?: true
    gameId?: true
    playerOrder?: true
    declarations?: true
    wins?: true
    turnIdx?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type CallBreakDealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakDeal to aggregate.
     */
    where?: CallBreakDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakDeals to fetch.
     */
    orderBy?: CallBreakDealOrderByWithRelationInput | CallBreakDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallBreakDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallBreakDeals
    **/
    _count?: true | CallBreakDealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallBreakDealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallBreakDealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallBreakDealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallBreakDealMaxAggregateInputType
  }

  export type GetCallBreakDealAggregateType<T extends CallBreakDealAggregateArgs> = {
        [P in keyof T & keyof AggregateCallBreakDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallBreakDeal[P]>
      : GetScalarType<T[P], AggregateCallBreakDeal[P]>
  }




  export type CallBreakDealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakDealWhereInput
    orderBy?: CallBreakDealOrderByWithAggregationInput | CallBreakDealOrderByWithAggregationInput[]
    by: CallBreakDealScalarFieldEnum[] | CallBreakDealScalarFieldEnum
    having?: CallBreakDealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallBreakDealCountAggregateInputType | true
    _avg?: CallBreakDealAvgAggregateInputType
    _sum?: CallBreakDealSumAggregateInputType
    _min?: CallBreakDealMinAggregateInputType
    _max?: CallBreakDealMaxAggregateInputType
  }

  export type CallBreakDealGroupByOutputType = {
    id: string
    gameId: string
    playerOrder: string[]
    declarations: (Record<string, number>)
    wins: (Record<string, number>)
    turnIdx: number
    status: $Enums.CallBreakStatus
    createdAt: Date
    _count: CallBreakDealCountAggregateOutputType | null
    _avg: CallBreakDealAvgAggregateOutputType | null
    _sum: CallBreakDealSumAggregateOutputType | null
    _min: CallBreakDealMinAggregateOutputType | null
    _max: CallBreakDealMaxAggregateOutputType | null
  }

  type GetCallBreakDealGroupByPayload<T extends CallBreakDealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallBreakDealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallBreakDealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallBreakDealGroupByOutputType[P]>
            : GetScalarType<T[P], CallBreakDealGroupByOutputType[P]>
        }
      >
    >


  export type CallBreakDealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerOrder?: boolean
    declarations?: boolean
    wins?: boolean
    turnIdx?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    cardMappings?: boolean | CallBreakDeal$cardMappingsArgs<ExtArgs>
    rounds?: boolean | CallBreakDeal$roundsArgs<ExtArgs>
    _count?: boolean | CallBreakDealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakDeal"]>

  export type CallBreakDealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerOrder?: boolean
    declarations?: boolean
    wins?: boolean
    turnIdx?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakDeal"]>

  export type CallBreakDealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerOrder?: boolean
    declarations?: boolean
    wins?: boolean
    turnIdx?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakDeal"]>

  export type CallBreakDealSelectScalar = {
    id?: boolean
    gameId?: boolean
    playerOrder?: boolean
    declarations?: boolean
    wins?: boolean
    turnIdx?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type CallBreakDealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "playerOrder" | "declarations" | "wins" | "turnIdx" | "status" | "createdAt", ExtArgs["result"]["callBreakDeal"]>
  export type CallBreakDealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    cardMappings?: boolean | CallBreakDeal$cardMappingsArgs<ExtArgs>
    rounds?: boolean | CallBreakDeal$roundsArgs<ExtArgs>
    _count?: boolean | CallBreakDealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CallBreakDealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }
  export type CallBreakDealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }

  export type $CallBreakDealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallBreakDeal"
    objects: {
      game: Prisma.$CallBreakGamePayload<ExtArgs>
      cardMappings: Prisma.$CallBreakCardMappingPayload<ExtArgs>[]
      rounds: Prisma.$CallBreakRoundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      playerOrder: string[]
      /**
       * ![Record<string, number>]
       */
      declarations: (Record<string, number>)
      /**
       * ![Record<string, number>]
       */
      wins: (Record<string, number>)
      turnIdx: number
      status: $Enums.CallBreakStatus
      createdAt: Date
    }, ExtArgs["result"]["callBreakDeal"]>
    composites: {}
  }

  type CallBreakDealGetPayload<S extends boolean | null | undefined | CallBreakDealDefaultArgs> = $Result.GetResult<Prisma.$CallBreakDealPayload, S>

  type CallBreakDealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallBreakDealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallBreakDealCountAggregateInputType | true
    }

  export interface CallBreakDealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallBreakDeal'], meta: { name: 'CallBreakDeal' } }
    /**
     * Find zero or one CallBreakDeal that matches the filter.
     * @param {CallBreakDealFindUniqueArgs} args - Arguments to find a CallBreakDeal
     * @example
     * // Get one CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallBreakDealFindUniqueArgs>(args: SelectSubset<T, CallBreakDealFindUniqueArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CallBreakDeal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallBreakDealFindUniqueOrThrowArgs} args - Arguments to find a CallBreakDeal
     * @example
     * // Get one CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallBreakDealFindUniqueOrThrowArgs>(args: SelectSubset<T, CallBreakDealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakDeal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealFindFirstArgs} args - Arguments to find a CallBreakDeal
     * @example
     * // Get one CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallBreakDealFindFirstArgs>(args?: SelectSubset<T, CallBreakDealFindFirstArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakDeal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealFindFirstOrThrowArgs} args - Arguments to find a CallBreakDeal
     * @example
     * // Get one CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallBreakDealFindFirstOrThrowArgs>(args?: SelectSubset<T, CallBreakDealFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CallBreakDeals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallBreakDeals
     * const callBreakDeals = await prisma.callBreakDeal.findMany()
     * 
     * // Get first 10 CallBreakDeals
     * const callBreakDeals = await prisma.callBreakDeal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callBreakDealWithIdOnly = await prisma.callBreakDeal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallBreakDealFindManyArgs>(args?: SelectSubset<T, CallBreakDealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CallBreakDeal.
     * @param {CallBreakDealCreateArgs} args - Arguments to create a CallBreakDeal.
     * @example
     * // Create one CallBreakDeal
     * const CallBreakDeal = await prisma.callBreakDeal.create({
     *   data: {
     *     // ... data to create a CallBreakDeal
     *   }
     * })
     * 
     */
    create<T extends CallBreakDealCreateArgs>(args: SelectSubset<T, CallBreakDealCreateArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CallBreakDeals.
     * @param {CallBreakDealCreateManyArgs} args - Arguments to create many CallBreakDeals.
     * @example
     * // Create many CallBreakDeals
     * const callBreakDeal = await prisma.callBreakDeal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallBreakDealCreateManyArgs>(args?: SelectSubset<T, CallBreakDealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallBreakDeals and returns the data saved in the database.
     * @param {CallBreakDealCreateManyAndReturnArgs} args - Arguments to create many CallBreakDeals.
     * @example
     * // Create many CallBreakDeals
     * const callBreakDeal = await prisma.callBreakDeal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallBreakDeals and only return the `id`
     * const callBreakDealWithIdOnly = await prisma.callBreakDeal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallBreakDealCreateManyAndReturnArgs>(args?: SelectSubset<T, CallBreakDealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CallBreakDeal.
     * @param {CallBreakDealDeleteArgs} args - Arguments to delete one CallBreakDeal.
     * @example
     * // Delete one CallBreakDeal
     * const CallBreakDeal = await prisma.callBreakDeal.delete({
     *   where: {
     *     // ... filter to delete one CallBreakDeal
     *   }
     * })
     * 
     */
    delete<T extends CallBreakDealDeleteArgs>(args: SelectSubset<T, CallBreakDealDeleteArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CallBreakDeal.
     * @param {CallBreakDealUpdateArgs} args - Arguments to update one CallBreakDeal.
     * @example
     * // Update one CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallBreakDealUpdateArgs>(args: SelectSubset<T, CallBreakDealUpdateArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CallBreakDeals.
     * @param {CallBreakDealDeleteManyArgs} args - Arguments to filter CallBreakDeals to delete.
     * @example
     * // Delete a few CallBreakDeals
     * const { count } = await prisma.callBreakDeal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallBreakDealDeleteManyArgs>(args?: SelectSubset<T, CallBreakDealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakDeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallBreakDeals
     * const callBreakDeal = await prisma.callBreakDeal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallBreakDealUpdateManyArgs>(args: SelectSubset<T, CallBreakDealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakDeals and returns the data updated in the database.
     * @param {CallBreakDealUpdateManyAndReturnArgs} args - Arguments to update many CallBreakDeals.
     * @example
     * // Update many CallBreakDeals
     * const callBreakDeal = await prisma.callBreakDeal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallBreakDeals and only return the `id`
     * const callBreakDealWithIdOnly = await prisma.callBreakDeal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallBreakDealUpdateManyAndReturnArgs>(args: SelectSubset<T, CallBreakDealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CallBreakDeal.
     * @param {CallBreakDealUpsertArgs} args - Arguments to update or create a CallBreakDeal.
     * @example
     * // Update or create a CallBreakDeal
     * const callBreakDeal = await prisma.callBreakDeal.upsert({
     *   create: {
     *     // ... data to create a CallBreakDeal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallBreakDeal we want to update
     *   }
     * })
     */
    upsert<T extends CallBreakDealUpsertArgs>(args: SelectSubset<T, CallBreakDealUpsertArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CallBreakDeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealCountArgs} args - Arguments to filter CallBreakDeals to count.
     * @example
     * // Count the number of CallBreakDeals
     * const count = await prisma.callBreakDeal.count({
     *   where: {
     *     // ... the filter for the CallBreakDeals we want to count
     *   }
     * })
    **/
    count<T extends CallBreakDealCountArgs>(
      args?: Subset<T, CallBreakDealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallBreakDealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallBreakDeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallBreakDealAggregateArgs>(args: Subset<T, CallBreakDealAggregateArgs>): Prisma.PrismaPromise<GetCallBreakDealAggregateType<T>>

    /**
     * Group by CallBreakDeal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakDealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallBreakDealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallBreakDealGroupByArgs['orderBy'] }
        : { orderBy?: CallBreakDealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallBreakDealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallBreakDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallBreakDeal model
   */
  readonly fields: CallBreakDealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallBreakDeal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallBreakDealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends CallBreakGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGameDefaultArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    cardMappings<T extends CallBreakDeal$cardMappingsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakDeal$cardMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rounds<T extends CallBreakDeal$roundsArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakDeal$roundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallBreakDeal model
   */ 
  interface CallBreakDealFieldRefs {
    readonly id: FieldRef<"CallBreakDeal", 'String'>
    readonly gameId: FieldRef<"CallBreakDeal", 'String'>
    readonly playerOrder: FieldRef<"CallBreakDeal", 'String[]'>
    readonly declarations: FieldRef<"CallBreakDeal", 'Json'>
    readonly wins: FieldRef<"CallBreakDeal", 'Json'>
    readonly turnIdx: FieldRef<"CallBreakDeal", 'Int'>
    readonly status: FieldRef<"CallBreakDeal", 'CallBreakStatus'>
    readonly createdAt: FieldRef<"CallBreakDeal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallBreakDeal findUnique
   */
  export type CallBreakDealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakDeal to fetch.
     */
    where: CallBreakDealWhereUniqueInput
  }

  /**
   * CallBreakDeal findUniqueOrThrow
   */
  export type CallBreakDealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakDeal to fetch.
     */
    where: CallBreakDealWhereUniqueInput
  }

  /**
   * CallBreakDeal findFirst
   */
  export type CallBreakDealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakDeal to fetch.
     */
    where?: CallBreakDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakDeals to fetch.
     */
    orderBy?: CallBreakDealOrderByWithRelationInput | CallBreakDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakDeals.
     */
    cursor?: CallBreakDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakDeals.
     */
    distinct?: CallBreakDealScalarFieldEnum | CallBreakDealScalarFieldEnum[]
  }

  /**
   * CallBreakDeal findFirstOrThrow
   */
  export type CallBreakDealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakDeal to fetch.
     */
    where?: CallBreakDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakDeals to fetch.
     */
    orderBy?: CallBreakDealOrderByWithRelationInput | CallBreakDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakDeals.
     */
    cursor?: CallBreakDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakDeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakDeals.
     */
    distinct?: CallBreakDealScalarFieldEnum | CallBreakDealScalarFieldEnum[]
  }

  /**
   * CallBreakDeal findMany
   */
  export type CallBreakDealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakDeals to fetch.
     */
    where?: CallBreakDealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakDeals to fetch.
     */
    orderBy?: CallBreakDealOrderByWithRelationInput | CallBreakDealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallBreakDeals.
     */
    cursor?: CallBreakDealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakDeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakDeals.
     */
    skip?: number
    distinct?: CallBreakDealScalarFieldEnum | CallBreakDealScalarFieldEnum[]
  }

  /**
   * CallBreakDeal create
   */
  export type CallBreakDealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * The data needed to create a CallBreakDeal.
     */
    data: XOR<CallBreakDealCreateInput, CallBreakDealUncheckedCreateInput>
  }

  /**
   * CallBreakDeal createMany
   */
  export type CallBreakDealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallBreakDeals.
     */
    data: CallBreakDealCreateManyInput | CallBreakDealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakDeal createManyAndReturn
   */
  export type CallBreakDealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * The data used to create many CallBreakDeals.
     */
    data: CallBreakDealCreateManyInput | CallBreakDealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakDeal update
   */
  export type CallBreakDealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * The data needed to update a CallBreakDeal.
     */
    data: XOR<CallBreakDealUpdateInput, CallBreakDealUncheckedUpdateInput>
    /**
     * Choose, which CallBreakDeal to update.
     */
    where: CallBreakDealWhereUniqueInput
  }

  /**
   * CallBreakDeal updateMany
   */
  export type CallBreakDealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallBreakDeals.
     */
    data: XOR<CallBreakDealUpdateManyMutationInput, CallBreakDealUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakDeals to update
     */
    where?: CallBreakDealWhereInput
    /**
     * Limit how many CallBreakDeals to update.
     */
    limit?: number
  }

  /**
   * CallBreakDeal updateManyAndReturn
   */
  export type CallBreakDealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * The data used to update CallBreakDeals.
     */
    data: XOR<CallBreakDealUpdateManyMutationInput, CallBreakDealUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakDeals to update
     */
    where?: CallBreakDealWhereInput
    /**
     * Limit how many CallBreakDeals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakDeal upsert
   */
  export type CallBreakDealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * The filter to search for the CallBreakDeal to update in case it exists.
     */
    where: CallBreakDealWhereUniqueInput
    /**
     * In case the CallBreakDeal found by the `where` argument doesn't exist, create a new CallBreakDeal with this data.
     */
    create: XOR<CallBreakDealCreateInput, CallBreakDealUncheckedCreateInput>
    /**
     * In case the CallBreakDeal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallBreakDealUpdateInput, CallBreakDealUncheckedUpdateInput>
  }

  /**
   * CallBreakDeal delete
   */
  export type CallBreakDealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
    /**
     * Filter which CallBreakDeal to delete.
     */
    where: CallBreakDealWhereUniqueInput
  }

  /**
   * CallBreakDeal deleteMany
   */
  export type CallBreakDealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakDeals to delete
     */
    where?: CallBreakDealWhereInput
    /**
     * Limit how many CallBreakDeals to delete.
     */
    limit?: number
  }

  /**
   * CallBreakDeal.cardMappings
   */
  export type CallBreakDeal$cardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    where?: CallBreakCardMappingWhereInput
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    cursor?: CallBreakCardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakDeal.rounds
   */
  export type CallBreakDeal$roundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    where?: CallBreakRoundWhereInput
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    cursor?: CallBreakRoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallBreakRoundScalarFieldEnum | CallBreakRoundScalarFieldEnum[]
  }

  /**
   * CallBreakDeal without action
   */
  export type CallBreakDealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakDeal
     */
    select?: CallBreakDealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakDeal
     */
    omit?: CallBreakDealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakDealInclude<ExtArgs> | null
  }


  /**
   * Model CallBreakCardMapping
   */

  export type AggregateCallBreakCardMapping = {
    _count: CallBreakCardMappingCountAggregateOutputType | null
    _min: CallBreakCardMappingMinAggregateOutputType | null
    _max: CallBreakCardMappingMaxAggregateOutputType | null
  }

  export type CallBreakCardMappingMinAggregateOutputType = {
    cardId: string | null
    dealId: string | null
    gameId: string | null
    playerId: string | null
  }

  export type CallBreakCardMappingMaxAggregateOutputType = {
    cardId: string | null
    dealId: string | null
    gameId: string | null
    playerId: string | null
  }

  export type CallBreakCardMappingCountAggregateOutputType = {
    cardId: number
    dealId: number
    gameId: number
    playerId: number
    _all: number
  }


  export type CallBreakCardMappingMinAggregateInputType = {
    cardId?: true
    dealId?: true
    gameId?: true
    playerId?: true
  }

  export type CallBreakCardMappingMaxAggregateInputType = {
    cardId?: true
    dealId?: true
    gameId?: true
    playerId?: true
  }

  export type CallBreakCardMappingCountAggregateInputType = {
    cardId?: true
    dealId?: true
    gameId?: true
    playerId?: true
    _all?: true
  }

  export type CallBreakCardMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakCardMapping to aggregate.
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakCardMappings to fetch.
     */
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallBreakCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallBreakCardMappings
    **/
    _count?: true | CallBreakCardMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallBreakCardMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallBreakCardMappingMaxAggregateInputType
  }

  export type GetCallBreakCardMappingAggregateType<T extends CallBreakCardMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateCallBreakCardMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallBreakCardMapping[P]>
      : GetScalarType<T[P], AggregateCallBreakCardMapping[P]>
  }




  export type CallBreakCardMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakCardMappingWhereInput
    orderBy?: CallBreakCardMappingOrderByWithAggregationInput | CallBreakCardMappingOrderByWithAggregationInput[]
    by: CallBreakCardMappingScalarFieldEnum[] | CallBreakCardMappingScalarFieldEnum
    having?: CallBreakCardMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallBreakCardMappingCountAggregateInputType | true
    _min?: CallBreakCardMappingMinAggregateInputType
    _max?: CallBreakCardMappingMaxAggregateInputType
  }

  export type CallBreakCardMappingGroupByOutputType = {
    cardId: string
    dealId: string
    gameId: string
    playerId: string
    _count: CallBreakCardMappingCountAggregateOutputType | null
    _min: CallBreakCardMappingMinAggregateOutputType | null
    _max: CallBreakCardMappingMaxAggregateOutputType | null
  }

  type GetCallBreakCardMappingGroupByPayload<T extends CallBreakCardMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallBreakCardMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallBreakCardMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallBreakCardMappingGroupByOutputType[P]>
            : GetScalarType<T[P], CallBreakCardMappingGroupByOutputType[P]>
        }
      >
    >


  export type CallBreakCardMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    dealId?: boolean
    gameId?: boolean
    playerId?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakCardMapping"]>

  export type CallBreakCardMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    dealId?: boolean
    gameId?: boolean
    playerId?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakCardMapping"]>

  export type CallBreakCardMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    dealId?: boolean
    gameId?: boolean
    playerId?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakCardMapping"]>

  export type CallBreakCardMappingSelectScalar = {
    cardId?: boolean
    dealId?: boolean
    gameId?: boolean
    playerId?: boolean
  }

  export type CallBreakCardMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cardId" | "dealId" | "gameId" | "playerId", ExtArgs["result"]["callBreakCardMapping"]>
  export type CallBreakCardMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }
  export type CallBreakCardMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }
  export type CallBreakCardMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
    player?: boolean | CallBreakPlayerDefaultArgs<ExtArgs>
  }

  export type $CallBreakCardMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallBreakCardMapping"
    objects: {
      deal: Prisma.$CallBreakDealPayload<ExtArgs>
      game: Prisma.$CallBreakGamePayload<ExtArgs>
      player: Prisma.$CallBreakPlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cardId: string
      dealId: string
      gameId: string
      playerId: string
    }, ExtArgs["result"]["callBreakCardMapping"]>
    composites: {}
  }

  type CallBreakCardMappingGetPayload<S extends boolean | null | undefined | CallBreakCardMappingDefaultArgs> = $Result.GetResult<Prisma.$CallBreakCardMappingPayload, S>

  type CallBreakCardMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallBreakCardMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallBreakCardMappingCountAggregateInputType | true
    }

  export interface CallBreakCardMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallBreakCardMapping'], meta: { name: 'CallBreakCardMapping' } }
    /**
     * Find zero or one CallBreakCardMapping that matches the filter.
     * @param {CallBreakCardMappingFindUniqueArgs} args - Arguments to find a CallBreakCardMapping
     * @example
     * // Get one CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallBreakCardMappingFindUniqueArgs>(args: SelectSubset<T, CallBreakCardMappingFindUniqueArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CallBreakCardMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallBreakCardMappingFindUniqueOrThrowArgs} args - Arguments to find a CallBreakCardMapping
     * @example
     * // Get one CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallBreakCardMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, CallBreakCardMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakCardMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingFindFirstArgs} args - Arguments to find a CallBreakCardMapping
     * @example
     * // Get one CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallBreakCardMappingFindFirstArgs>(args?: SelectSubset<T, CallBreakCardMappingFindFirstArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakCardMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingFindFirstOrThrowArgs} args - Arguments to find a CallBreakCardMapping
     * @example
     * // Get one CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallBreakCardMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, CallBreakCardMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CallBreakCardMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallBreakCardMappings
     * const callBreakCardMappings = await prisma.callBreakCardMapping.findMany()
     * 
     * // Get first 10 CallBreakCardMappings
     * const callBreakCardMappings = await prisma.callBreakCardMapping.findMany({ take: 10 })
     * 
     * // Only select the `cardId`
     * const callBreakCardMappingWithCardIdOnly = await prisma.callBreakCardMapping.findMany({ select: { cardId: true } })
     * 
     */
    findMany<T extends CallBreakCardMappingFindManyArgs>(args?: SelectSubset<T, CallBreakCardMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CallBreakCardMapping.
     * @param {CallBreakCardMappingCreateArgs} args - Arguments to create a CallBreakCardMapping.
     * @example
     * // Create one CallBreakCardMapping
     * const CallBreakCardMapping = await prisma.callBreakCardMapping.create({
     *   data: {
     *     // ... data to create a CallBreakCardMapping
     *   }
     * })
     * 
     */
    create<T extends CallBreakCardMappingCreateArgs>(args: SelectSubset<T, CallBreakCardMappingCreateArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CallBreakCardMappings.
     * @param {CallBreakCardMappingCreateManyArgs} args - Arguments to create many CallBreakCardMappings.
     * @example
     * // Create many CallBreakCardMappings
     * const callBreakCardMapping = await prisma.callBreakCardMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallBreakCardMappingCreateManyArgs>(args?: SelectSubset<T, CallBreakCardMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallBreakCardMappings and returns the data saved in the database.
     * @param {CallBreakCardMappingCreateManyAndReturnArgs} args - Arguments to create many CallBreakCardMappings.
     * @example
     * // Create many CallBreakCardMappings
     * const callBreakCardMapping = await prisma.callBreakCardMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallBreakCardMappings and only return the `cardId`
     * const callBreakCardMappingWithCardIdOnly = await prisma.callBreakCardMapping.createManyAndReturn({
     *   select: { cardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallBreakCardMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, CallBreakCardMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CallBreakCardMapping.
     * @param {CallBreakCardMappingDeleteArgs} args - Arguments to delete one CallBreakCardMapping.
     * @example
     * // Delete one CallBreakCardMapping
     * const CallBreakCardMapping = await prisma.callBreakCardMapping.delete({
     *   where: {
     *     // ... filter to delete one CallBreakCardMapping
     *   }
     * })
     * 
     */
    delete<T extends CallBreakCardMappingDeleteArgs>(args: SelectSubset<T, CallBreakCardMappingDeleteArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CallBreakCardMapping.
     * @param {CallBreakCardMappingUpdateArgs} args - Arguments to update one CallBreakCardMapping.
     * @example
     * // Update one CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallBreakCardMappingUpdateArgs>(args: SelectSubset<T, CallBreakCardMappingUpdateArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CallBreakCardMappings.
     * @param {CallBreakCardMappingDeleteManyArgs} args - Arguments to filter CallBreakCardMappings to delete.
     * @example
     * // Delete a few CallBreakCardMappings
     * const { count } = await prisma.callBreakCardMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallBreakCardMappingDeleteManyArgs>(args?: SelectSubset<T, CallBreakCardMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakCardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallBreakCardMappings
     * const callBreakCardMapping = await prisma.callBreakCardMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallBreakCardMappingUpdateManyArgs>(args: SelectSubset<T, CallBreakCardMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakCardMappings and returns the data updated in the database.
     * @param {CallBreakCardMappingUpdateManyAndReturnArgs} args - Arguments to update many CallBreakCardMappings.
     * @example
     * // Update many CallBreakCardMappings
     * const callBreakCardMapping = await prisma.callBreakCardMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallBreakCardMappings and only return the `cardId`
     * const callBreakCardMappingWithCardIdOnly = await prisma.callBreakCardMapping.updateManyAndReturn({
     *   select: { cardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallBreakCardMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, CallBreakCardMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CallBreakCardMapping.
     * @param {CallBreakCardMappingUpsertArgs} args - Arguments to update or create a CallBreakCardMapping.
     * @example
     * // Update or create a CallBreakCardMapping
     * const callBreakCardMapping = await prisma.callBreakCardMapping.upsert({
     *   create: {
     *     // ... data to create a CallBreakCardMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallBreakCardMapping we want to update
     *   }
     * })
     */
    upsert<T extends CallBreakCardMappingUpsertArgs>(args: SelectSubset<T, CallBreakCardMappingUpsertArgs<ExtArgs>>): Prisma__CallBreakCardMappingClient<$Result.GetResult<Prisma.$CallBreakCardMappingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CallBreakCardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingCountArgs} args - Arguments to filter CallBreakCardMappings to count.
     * @example
     * // Count the number of CallBreakCardMappings
     * const count = await prisma.callBreakCardMapping.count({
     *   where: {
     *     // ... the filter for the CallBreakCardMappings we want to count
     *   }
     * })
    **/
    count<T extends CallBreakCardMappingCountArgs>(
      args?: Subset<T, CallBreakCardMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallBreakCardMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallBreakCardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallBreakCardMappingAggregateArgs>(args: Subset<T, CallBreakCardMappingAggregateArgs>): Prisma.PrismaPromise<GetCallBreakCardMappingAggregateType<T>>

    /**
     * Group by CallBreakCardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakCardMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallBreakCardMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallBreakCardMappingGroupByArgs['orderBy'] }
        : { orderBy?: CallBreakCardMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallBreakCardMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallBreakCardMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallBreakCardMapping model
   */
  readonly fields: CallBreakCardMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallBreakCardMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallBreakCardMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deal<T extends CallBreakDealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakDealDefaultArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    game<T extends CallBreakGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGameDefaultArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends CallBreakPlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakPlayerDefaultArgs<ExtArgs>>): Prisma__CallBreakPlayerClient<$Result.GetResult<Prisma.$CallBreakPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallBreakCardMapping model
   */ 
  interface CallBreakCardMappingFieldRefs {
    readonly cardId: FieldRef<"CallBreakCardMapping", 'String'>
    readonly dealId: FieldRef<"CallBreakCardMapping", 'String'>
    readonly gameId: FieldRef<"CallBreakCardMapping", 'String'>
    readonly playerId: FieldRef<"CallBreakCardMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CallBreakCardMapping findUnique
   */
  export type CallBreakCardMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakCardMapping to fetch.
     */
    where: CallBreakCardMappingWhereUniqueInput
  }

  /**
   * CallBreakCardMapping findUniqueOrThrow
   */
  export type CallBreakCardMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakCardMapping to fetch.
     */
    where: CallBreakCardMappingWhereUniqueInput
  }

  /**
   * CallBreakCardMapping findFirst
   */
  export type CallBreakCardMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakCardMapping to fetch.
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakCardMappings to fetch.
     */
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakCardMappings.
     */
    cursor?: CallBreakCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakCardMappings.
     */
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakCardMapping findFirstOrThrow
   */
  export type CallBreakCardMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakCardMapping to fetch.
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakCardMappings to fetch.
     */
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakCardMappings.
     */
    cursor?: CallBreakCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakCardMappings.
     */
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakCardMapping findMany
   */
  export type CallBreakCardMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakCardMappings to fetch.
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakCardMappings to fetch.
     */
    orderBy?: CallBreakCardMappingOrderByWithRelationInput | CallBreakCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallBreakCardMappings.
     */
    cursor?: CallBreakCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakCardMappings.
     */
    skip?: number
    distinct?: CallBreakCardMappingScalarFieldEnum | CallBreakCardMappingScalarFieldEnum[]
  }

  /**
   * CallBreakCardMapping create
   */
  export type CallBreakCardMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a CallBreakCardMapping.
     */
    data: XOR<CallBreakCardMappingCreateInput, CallBreakCardMappingUncheckedCreateInput>
  }

  /**
   * CallBreakCardMapping createMany
   */
  export type CallBreakCardMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallBreakCardMappings.
     */
    data: CallBreakCardMappingCreateManyInput | CallBreakCardMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakCardMapping createManyAndReturn
   */
  export type CallBreakCardMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * The data used to create many CallBreakCardMappings.
     */
    data: CallBreakCardMappingCreateManyInput | CallBreakCardMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakCardMapping update
   */
  export type CallBreakCardMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a CallBreakCardMapping.
     */
    data: XOR<CallBreakCardMappingUpdateInput, CallBreakCardMappingUncheckedUpdateInput>
    /**
     * Choose, which CallBreakCardMapping to update.
     */
    where: CallBreakCardMappingWhereUniqueInput
  }

  /**
   * CallBreakCardMapping updateMany
   */
  export type CallBreakCardMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallBreakCardMappings.
     */
    data: XOR<CallBreakCardMappingUpdateManyMutationInput, CallBreakCardMappingUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakCardMappings to update
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * Limit how many CallBreakCardMappings to update.
     */
    limit?: number
  }

  /**
   * CallBreakCardMapping updateManyAndReturn
   */
  export type CallBreakCardMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * The data used to update CallBreakCardMappings.
     */
    data: XOR<CallBreakCardMappingUpdateManyMutationInput, CallBreakCardMappingUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakCardMappings to update
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * Limit how many CallBreakCardMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakCardMapping upsert
   */
  export type CallBreakCardMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the CallBreakCardMapping to update in case it exists.
     */
    where: CallBreakCardMappingWhereUniqueInput
    /**
     * In case the CallBreakCardMapping found by the `where` argument doesn't exist, create a new CallBreakCardMapping with this data.
     */
    create: XOR<CallBreakCardMappingCreateInput, CallBreakCardMappingUncheckedCreateInput>
    /**
     * In case the CallBreakCardMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallBreakCardMappingUpdateInput, CallBreakCardMappingUncheckedUpdateInput>
  }

  /**
   * CallBreakCardMapping delete
   */
  export type CallBreakCardMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
    /**
     * Filter which CallBreakCardMapping to delete.
     */
    where: CallBreakCardMappingWhereUniqueInput
  }

  /**
   * CallBreakCardMapping deleteMany
   */
  export type CallBreakCardMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakCardMappings to delete
     */
    where?: CallBreakCardMappingWhereInput
    /**
     * Limit how many CallBreakCardMappings to delete.
     */
    limit?: number
  }

  /**
   * CallBreakCardMapping without action
   */
  export type CallBreakCardMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakCardMapping
     */
    select?: CallBreakCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakCardMapping
     */
    omit?: CallBreakCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakCardMappingInclude<ExtArgs> | null
  }


  /**
   * Model CallBreakRound
   */

  export type AggregateCallBreakRound = {
    _count: CallBreakRoundCountAggregateOutputType | null
    _avg: CallBreakRoundAvgAggregateOutputType | null
    _sum: CallBreakRoundSumAggregateOutputType | null
    _min: CallBreakRoundMinAggregateOutputType | null
    _max: CallBreakRoundMaxAggregateOutputType | null
  }

  export type CallBreakRoundAvgAggregateOutputType = {
    turnIdx: number | null
  }

  export type CallBreakRoundSumAggregateOutputType = {
    turnIdx: number | null
  }

  export type CallBreakRoundMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    dealId: string | null
    winner: string | null
    turnIdx: number | null
    suit: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type CallBreakRoundMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    dealId: string | null
    winner: string | null
    turnIdx: number | null
    suit: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type CallBreakRoundCountAggregateOutputType = {
    id: number
    gameId: number
    dealId: number
    winner: number
    playerOrder: number
    cards: number
    turnIdx: number
    suit: number
    completed: number
    createdAt: number
    _all: number
  }


  export type CallBreakRoundAvgAggregateInputType = {
    turnIdx?: true
  }

  export type CallBreakRoundSumAggregateInputType = {
    turnIdx?: true
  }

  export type CallBreakRoundMinAggregateInputType = {
    id?: true
    gameId?: true
    dealId?: true
    winner?: true
    turnIdx?: true
    suit?: true
    completed?: true
    createdAt?: true
  }

  export type CallBreakRoundMaxAggregateInputType = {
    id?: true
    gameId?: true
    dealId?: true
    winner?: true
    turnIdx?: true
    suit?: true
    completed?: true
    createdAt?: true
  }

  export type CallBreakRoundCountAggregateInputType = {
    id?: true
    gameId?: true
    dealId?: true
    winner?: true
    playerOrder?: true
    cards?: true
    turnIdx?: true
    suit?: true
    completed?: true
    createdAt?: true
    _all?: true
  }

  export type CallBreakRoundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakRound to aggregate.
     */
    where?: CallBreakRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakRounds to fetch.
     */
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallBreakRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallBreakRounds
    **/
    _count?: true | CallBreakRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallBreakRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallBreakRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallBreakRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallBreakRoundMaxAggregateInputType
  }

  export type GetCallBreakRoundAggregateType<T extends CallBreakRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateCallBreakRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallBreakRound[P]>
      : GetScalarType<T[P], AggregateCallBreakRound[P]>
  }




  export type CallBreakRoundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallBreakRoundWhereInput
    orderBy?: CallBreakRoundOrderByWithAggregationInput | CallBreakRoundOrderByWithAggregationInput[]
    by: CallBreakRoundScalarFieldEnum[] | CallBreakRoundScalarFieldEnum
    having?: CallBreakRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallBreakRoundCountAggregateInputType | true
    _avg?: CallBreakRoundAvgAggregateInputType
    _sum?: CallBreakRoundSumAggregateInputType
    _min?: CallBreakRoundMinAggregateInputType
    _max?: CallBreakRoundMaxAggregateInputType
  }

  export type CallBreakRoundGroupByOutputType = {
    id: string
    gameId: string
    dealId: string
    winner: string | null
    playerOrder: string[]
    cards: (Record<string, string>)
    turnIdx: number
    suit: string | null
    completed: boolean
    createdAt: Date
    _count: CallBreakRoundCountAggregateOutputType | null
    _avg: CallBreakRoundAvgAggregateOutputType | null
    _sum: CallBreakRoundSumAggregateOutputType | null
    _min: CallBreakRoundMinAggregateOutputType | null
    _max: CallBreakRoundMaxAggregateOutputType | null
  }

  type GetCallBreakRoundGroupByPayload<T extends CallBreakRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallBreakRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallBreakRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallBreakRoundGroupByOutputType[P]>
            : GetScalarType<T[P], CallBreakRoundGroupByOutputType[P]>
        }
      >
    >


  export type CallBreakRoundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    dealId?: boolean
    winner?: boolean
    playerOrder?: boolean
    cards?: boolean
    turnIdx?: boolean
    suit?: boolean
    completed?: boolean
    createdAt?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakRound"]>

  export type CallBreakRoundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    dealId?: boolean
    winner?: boolean
    playerOrder?: boolean
    cards?: boolean
    turnIdx?: boolean
    suit?: boolean
    completed?: boolean
    createdAt?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakRound"]>

  export type CallBreakRoundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    dealId?: boolean
    winner?: boolean
    playerOrder?: boolean
    cards?: boolean
    turnIdx?: boolean
    suit?: boolean
    completed?: boolean
    createdAt?: boolean
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callBreakRound"]>

  export type CallBreakRoundSelectScalar = {
    id?: boolean
    gameId?: boolean
    dealId?: boolean
    winner?: boolean
    playerOrder?: boolean
    cards?: boolean
    turnIdx?: boolean
    suit?: boolean
    completed?: boolean
    createdAt?: boolean
  }

  export type CallBreakRoundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "dealId" | "winner" | "playerOrder" | "cards" | "turnIdx" | "suit" | "completed" | "createdAt", ExtArgs["result"]["callBreakRound"]>
  export type CallBreakRoundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }
  export type CallBreakRoundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }
  export type CallBreakRoundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | CallBreakDealDefaultArgs<ExtArgs>
    game?: boolean | CallBreakGameDefaultArgs<ExtArgs>
  }

  export type $CallBreakRoundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallBreakRound"
    objects: {
      deal: Prisma.$CallBreakDealPayload<ExtArgs>
      game: Prisma.$CallBreakGamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      dealId: string
      winner: string | null
      playerOrder: string[]
      /**
       * ![Record<string, string>]
       */
      cards: (Record<string, string>)
      turnIdx: number
      suit: string | null
      completed: boolean
      createdAt: Date
    }, ExtArgs["result"]["callBreakRound"]>
    composites: {}
  }

  type CallBreakRoundGetPayload<S extends boolean | null | undefined | CallBreakRoundDefaultArgs> = $Result.GetResult<Prisma.$CallBreakRoundPayload, S>

  type CallBreakRoundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallBreakRoundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallBreakRoundCountAggregateInputType | true
    }

  export interface CallBreakRoundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallBreakRound'], meta: { name: 'CallBreakRound' } }
    /**
     * Find zero or one CallBreakRound that matches the filter.
     * @param {CallBreakRoundFindUniqueArgs} args - Arguments to find a CallBreakRound
     * @example
     * // Get one CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallBreakRoundFindUniqueArgs>(args: SelectSubset<T, CallBreakRoundFindUniqueArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CallBreakRound that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallBreakRoundFindUniqueOrThrowArgs} args - Arguments to find a CallBreakRound
     * @example
     * // Get one CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallBreakRoundFindUniqueOrThrowArgs>(args: SelectSubset<T, CallBreakRoundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundFindFirstArgs} args - Arguments to find a CallBreakRound
     * @example
     * // Get one CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallBreakRoundFindFirstArgs>(args?: SelectSubset<T, CallBreakRoundFindFirstArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CallBreakRound that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundFindFirstOrThrowArgs} args - Arguments to find a CallBreakRound
     * @example
     * // Get one CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallBreakRoundFindFirstOrThrowArgs>(args?: SelectSubset<T, CallBreakRoundFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CallBreakRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallBreakRounds
     * const callBreakRounds = await prisma.callBreakRound.findMany()
     * 
     * // Get first 10 CallBreakRounds
     * const callBreakRounds = await prisma.callBreakRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callBreakRoundWithIdOnly = await prisma.callBreakRound.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallBreakRoundFindManyArgs>(args?: SelectSubset<T, CallBreakRoundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CallBreakRound.
     * @param {CallBreakRoundCreateArgs} args - Arguments to create a CallBreakRound.
     * @example
     * // Create one CallBreakRound
     * const CallBreakRound = await prisma.callBreakRound.create({
     *   data: {
     *     // ... data to create a CallBreakRound
     *   }
     * })
     * 
     */
    create<T extends CallBreakRoundCreateArgs>(args: SelectSubset<T, CallBreakRoundCreateArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CallBreakRounds.
     * @param {CallBreakRoundCreateManyArgs} args - Arguments to create many CallBreakRounds.
     * @example
     * // Create many CallBreakRounds
     * const callBreakRound = await prisma.callBreakRound.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallBreakRoundCreateManyArgs>(args?: SelectSubset<T, CallBreakRoundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallBreakRounds and returns the data saved in the database.
     * @param {CallBreakRoundCreateManyAndReturnArgs} args - Arguments to create many CallBreakRounds.
     * @example
     * // Create many CallBreakRounds
     * const callBreakRound = await prisma.callBreakRound.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallBreakRounds and only return the `id`
     * const callBreakRoundWithIdOnly = await prisma.callBreakRound.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallBreakRoundCreateManyAndReturnArgs>(args?: SelectSubset<T, CallBreakRoundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CallBreakRound.
     * @param {CallBreakRoundDeleteArgs} args - Arguments to delete one CallBreakRound.
     * @example
     * // Delete one CallBreakRound
     * const CallBreakRound = await prisma.callBreakRound.delete({
     *   where: {
     *     // ... filter to delete one CallBreakRound
     *   }
     * })
     * 
     */
    delete<T extends CallBreakRoundDeleteArgs>(args: SelectSubset<T, CallBreakRoundDeleteArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CallBreakRound.
     * @param {CallBreakRoundUpdateArgs} args - Arguments to update one CallBreakRound.
     * @example
     * // Update one CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallBreakRoundUpdateArgs>(args: SelectSubset<T, CallBreakRoundUpdateArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CallBreakRounds.
     * @param {CallBreakRoundDeleteManyArgs} args - Arguments to filter CallBreakRounds to delete.
     * @example
     * // Delete a few CallBreakRounds
     * const { count } = await prisma.callBreakRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallBreakRoundDeleteManyArgs>(args?: SelectSubset<T, CallBreakRoundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallBreakRounds
     * const callBreakRound = await prisma.callBreakRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallBreakRoundUpdateManyArgs>(args: SelectSubset<T, CallBreakRoundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallBreakRounds and returns the data updated in the database.
     * @param {CallBreakRoundUpdateManyAndReturnArgs} args - Arguments to update many CallBreakRounds.
     * @example
     * // Update many CallBreakRounds
     * const callBreakRound = await prisma.callBreakRound.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallBreakRounds and only return the `id`
     * const callBreakRoundWithIdOnly = await prisma.callBreakRound.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallBreakRoundUpdateManyAndReturnArgs>(args: SelectSubset<T, CallBreakRoundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CallBreakRound.
     * @param {CallBreakRoundUpsertArgs} args - Arguments to update or create a CallBreakRound.
     * @example
     * // Update or create a CallBreakRound
     * const callBreakRound = await prisma.callBreakRound.upsert({
     *   create: {
     *     // ... data to create a CallBreakRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallBreakRound we want to update
     *   }
     * })
     */
    upsert<T extends CallBreakRoundUpsertArgs>(args: SelectSubset<T, CallBreakRoundUpsertArgs<ExtArgs>>): Prisma__CallBreakRoundClient<$Result.GetResult<Prisma.$CallBreakRoundPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CallBreakRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundCountArgs} args - Arguments to filter CallBreakRounds to count.
     * @example
     * // Count the number of CallBreakRounds
     * const count = await prisma.callBreakRound.count({
     *   where: {
     *     // ... the filter for the CallBreakRounds we want to count
     *   }
     * })
    **/
    count<T extends CallBreakRoundCountArgs>(
      args?: Subset<T, CallBreakRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallBreakRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallBreakRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallBreakRoundAggregateArgs>(args: Subset<T, CallBreakRoundAggregateArgs>): Prisma.PrismaPromise<GetCallBreakRoundAggregateType<T>>

    /**
     * Group by CallBreakRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallBreakRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallBreakRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallBreakRoundGroupByArgs['orderBy'] }
        : { orderBy?: CallBreakRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallBreakRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallBreakRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallBreakRound model
   */
  readonly fields: CallBreakRoundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallBreakRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallBreakRoundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deal<T extends CallBreakDealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakDealDefaultArgs<ExtArgs>>): Prisma__CallBreakDealClient<$Result.GetResult<Prisma.$CallBreakDealPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    game<T extends CallBreakGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallBreakGameDefaultArgs<ExtArgs>>): Prisma__CallBreakGameClient<$Result.GetResult<Prisma.$CallBreakGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallBreakRound model
   */ 
  interface CallBreakRoundFieldRefs {
    readonly id: FieldRef<"CallBreakRound", 'String'>
    readonly gameId: FieldRef<"CallBreakRound", 'String'>
    readonly dealId: FieldRef<"CallBreakRound", 'String'>
    readonly winner: FieldRef<"CallBreakRound", 'String'>
    readonly playerOrder: FieldRef<"CallBreakRound", 'String[]'>
    readonly cards: FieldRef<"CallBreakRound", 'Json'>
    readonly turnIdx: FieldRef<"CallBreakRound", 'Int'>
    readonly suit: FieldRef<"CallBreakRound", 'String'>
    readonly completed: FieldRef<"CallBreakRound", 'Boolean'>
    readonly createdAt: FieldRef<"CallBreakRound", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallBreakRound findUnique
   */
  export type CallBreakRoundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakRound to fetch.
     */
    where: CallBreakRoundWhereUniqueInput
  }

  /**
   * CallBreakRound findUniqueOrThrow
   */
  export type CallBreakRoundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakRound to fetch.
     */
    where: CallBreakRoundWhereUniqueInput
  }

  /**
   * CallBreakRound findFirst
   */
  export type CallBreakRoundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakRound to fetch.
     */
    where?: CallBreakRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakRounds to fetch.
     */
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakRounds.
     */
    cursor?: CallBreakRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakRounds.
     */
    distinct?: CallBreakRoundScalarFieldEnum | CallBreakRoundScalarFieldEnum[]
  }

  /**
   * CallBreakRound findFirstOrThrow
   */
  export type CallBreakRoundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakRound to fetch.
     */
    where?: CallBreakRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakRounds to fetch.
     */
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallBreakRounds.
     */
    cursor?: CallBreakRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallBreakRounds.
     */
    distinct?: CallBreakRoundScalarFieldEnum | CallBreakRoundScalarFieldEnum[]
  }

  /**
   * CallBreakRound findMany
   */
  export type CallBreakRoundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter, which CallBreakRounds to fetch.
     */
    where?: CallBreakRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallBreakRounds to fetch.
     */
    orderBy?: CallBreakRoundOrderByWithRelationInput | CallBreakRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallBreakRounds.
     */
    cursor?: CallBreakRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallBreakRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallBreakRounds.
     */
    skip?: number
    distinct?: CallBreakRoundScalarFieldEnum | CallBreakRoundScalarFieldEnum[]
  }

  /**
   * CallBreakRound create
   */
  export type CallBreakRoundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * The data needed to create a CallBreakRound.
     */
    data: XOR<CallBreakRoundCreateInput, CallBreakRoundUncheckedCreateInput>
  }

  /**
   * CallBreakRound createMany
   */
  export type CallBreakRoundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallBreakRounds.
     */
    data: CallBreakRoundCreateManyInput | CallBreakRoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallBreakRound createManyAndReturn
   */
  export type CallBreakRoundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * The data used to create many CallBreakRounds.
     */
    data: CallBreakRoundCreateManyInput | CallBreakRoundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakRound update
   */
  export type CallBreakRoundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * The data needed to update a CallBreakRound.
     */
    data: XOR<CallBreakRoundUpdateInput, CallBreakRoundUncheckedUpdateInput>
    /**
     * Choose, which CallBreakRound to update.
     */
    where: CallBreakRoundWhereUniqueInput
  }

  /**
   * CallBreakRound updateMany
   */
  export type CallBreakRoundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallBreakRounds.
     */
    data: XOR<CallBreakRoundUpdateManyMutationInput, CallBreakRoundUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakRounds to update
     */
    where?: CallBreakRoundWhereInput
    /**
     * Limit how many CallBreakRounds to update.
     */
    limit?: number
  }

  /**
   * CallBreakRound updateManyAndReturn
   */
  export type CallBreakRoundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * The data used to update CallBreakRounds.
     */
    data: XOR<CallBreakRoundUpdateManyMutationInput, CallBreakRoundUncheckedUpdateManyInput>
    /**
     * Filter which CallBreakRounds to update
     */
    where?: CallBreakRoundWhereInput
    /**
     * Limit how many CallBreakRounds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallBreakRound upsert
   */
  export type CallBreakRoundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * The filter to search for the CallBreakRound to update in case it exists.
     */
    where: CallBreakRoundWhereUniqueInput
    /**
     * In case the CallBreakRound found by the `where` argument doesn't exist, create a new CallBreakRound with this data.
     */
    create: XOR<CallBreakRoundCreateInput, CallBreakRoundUncheckedCreateInput>
    /**
     * In case the CallBreakRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallBreakRoundUpdateInput, CallBreakRoundUncheckedUpdateInput>
  }

  /**
   * CallBreakRound delete
   */
  export type CallBreakRoundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
    /**
     * Filter which CallBreakRound to delete.
     */
    where: CallBreakRoundWhereUniqueInput
  }

  /**
   * CallBreakRound deleteMany
   */
  export type CallBreakRoundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallBreakRounds to delete
     */
    where?: CallBreakRoundWhereInput
    /**
     * Limit how many CallBreakRounds to delete.
     */
    limit?: number
  }

  /**
   * CallBreakRound without action
   */
  export type CallBreakRoundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallBreakRound
     */
    select?: CallBreakRoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallBreakRound
     */
    omit?: CallBreakRoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallBreakRoundInclude<ExtArgs> | null
  }


  /**
   * Model LiteraturePlayer
   */

  export type AggregateLiteraturePlayer = {
    _count: LiteraturePlayerCountAggregateOutputType | null
    _min: LiteraturePlayerMinAggregateOutputType | null
    _max: LiteraturePlayerMaxAggregateOutputType | null
  }

  export type LiteraturePlayerMinAggregateOutputType = {
    id: string | null
    name: string | null
    avatar: string | null
    gameId: string | null
    teamId: string | null
    isBot: boolean | null
  }

  export type LiteraturePlayerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    avatar: string | null
    gameId: string | null
    teamId: string | null
    isBot: boolean | null
  }

  export type LiteraturePlayerCountAggregateOutputType = {
    id: number
    name: number
    avatar: number
    gameId: number
    teamId: number
    isBot: number
    _all: number
  }


  export type LiteraturePlayerMinAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    teamId?: true
    isBot?: true
  }

  export type LiteraturePlayerMaxAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    teamId?: true
    isBot?: true
  }

  export type LiteraturePlayerCountAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    gameId?: true
    teamId?: true
    isBot?: true
    _all?: true
  }

  export type LiteraturePlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteraturePlayer to aggregate.
     */
    where?: LiteraturePlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteraturePlayers to fetch.
     */
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteraturePlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteraturePlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteraturePlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteraturePlayers
    **/
    _count?: true | LiteraturePlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteraturePlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteraturePlayerMaxAggregateInputType
  }

  export type GetLiteraturePlayerAggregateType<T extends LiteraturePlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteraturePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteraturePlayer[P]>
      : GetScalarType<T[P], AggregateLiteraturePlayer[P]>
  }




  export type LiteraturePlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteraturePlayerWhereInput
    orderBy?: LiteraturePlayerOrderByWithAggregationInput | LiteraturePlayerOrderByWithAggregationInput[]
    by: LiteraturePlayerScalarFieldEnum[] | LiteraturePlayerScalarFieldEnum
    having?: LiteraturePlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteraturePlayerCountAggregateInputType | true
    _min?: LiteraturePlayerMinAggregateInputType
    _max?: LiteraturePlayerMaxAggregateInputType
  }

  export type LiteraturePlayerGroupByOutputType = {
    id: string
    name: string
    avatar: string
    gameId: string
    teamId: string | null
    isBot: boolean
    _count: LiteraturePlayerCountAggregateOutputType | null
    _min: LiteraturePlayerMinAggregateOutputType | null
    _max: LiteraturePlayerMaxAggregateOutputType | null
  }

  type GetLiteraturePlayerGroupByPayload<T extends LiteraturePlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteraturePlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteraturePlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteraturePlayerGroupByOutputType[P]>
            : GetScalarType<T[P], LiteraturePlayerGroupByOutputType[P]>
        }
      >
    >


  export type LiteraturePlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    teamId?: boolean
    isBot?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
    cardMappings?: boolean | LiteraturePlayer$cardMappingsArgs<ExtArgs>
    cardLocations?: boolean | LiteraturePlayer$cardLocationsArgs<ExtArgs>
    asks?: boolean | LiteraturePlayer$asksArgs<ExtArgs>
    calls?: boolean | LiteraturePlayer$callsArgs<ExtArgs>
    transfers?: boolean | LiteraturePlayer$transfersArgs<ExtArgs>
    _count?: boolean | LiteraturePlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literaturePlayer"]>

  export type LiteraturePlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    teamId?: boolean
    isBot?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
  }, ExtArgs["result"]["literaturePlayer"]>

  export type LiteraturePlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    teamId?: boolean
    isBot?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
  }, ExtArgs["result"]["literaturePlayer"]>

  export type LiteraturePlayerSelectScalar = {
    id?: boolean
    name?: boolean
    avatar?: boolean
    gameId?: boolean
    teamId?: boolean
    isBot?: boolean
  }

  export type LiteraturePlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "avatar" | "gameId" | "teamId" | "isBot", ExtArgs["result"]["literaturePlayer"]>
  export type LiteraturePlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
    cardMappings?: boolean | LiteraturePlayer$cardMappingsArgs<ExtArgs>
    cardLocations?: boolean | LiteraturePlayer$cardLocationsArgs<ExtArgs>
    asks?: boolean | LiteraturePlayer$asksArgs<ExtArgs>
    calls?: boolean | LiteraturePlayer$callsArgs<ExtArgs>
    transfers?: boolean | LiteraturePlayer$transfersArgs<ExtArgs>
    _count?: boolean | LiteraturePlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiteraturePlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
  }
  export type LiteraturePlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    team?: boolean | LiteraturePlayer$teamArgs<ExtArgs>
  }

  export type $LiteraturePlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteraturePlayer"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      team: Prisma.$LiteratureTeamPayload<ExtArgs> | null
      cardMappings: Prisma.$LiteratureCardMappingPayload<ExtArgs>[]
      cardLocations: Prisma.$LiteratureCardLocationPayload<ExtArgs>[]
      asks: Prisma.$LiteratureAskPayload<ExtArgs>[]
      calls: Prisma.$LiteratureCallPayload<ExtArgs>[]
      transfers: Prisma.$LiteratureTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      avatar: string
      gameId: string
      teamId: string | null
      isBot: boolean
    }, ExtArgs["result"]["literaturePlayer"]>
    composites: {}
  }

  type LiteraturePlayerGetPayload<S extends boolean | null | undefined | LiteraturePlayerDefaultArgs> = $Result.GetResult<Prisma.$LiteraturePlayerPayload, S>

  type LiteraturePlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteraturePlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteraturePlayerCountAggregateInputType | true
    }

  export interface LiteraturePlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteraturePlayer'], meta: { name: 'LiteraturePlayer' } }
    /**
     * Find zero or one LiteraturePlayer that matches the filter.
     * @param {LiteraturePlayerFindUniqueArgs} args - Arguments to find a LiteraturePlayer
     * @example
     * // Get one LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteraturePlayerFindUniqueArgs>(args: SelectSubset<T, LiteraturePlayerFindUniqueArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteraturePlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteraturePlayerFindUniqueOrThrowArgs} args - Arguments to find a LiteraturePlayer
     * @example
     * // Get one LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteraturePlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteraturePlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteraturePlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerFindFirstArgs} args - Arguments to find a LiteraturePlayer
     * @example
     * // Get one LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteraturePlayerFindFirstArgs>(args?: SelectSubset<T, LiteraturePlayerFindFirstArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteraturePlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerFindFirstOrThrowArgs} args - Arguments to find a LiteraturePlayer
     * @example
     * // Get one LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteraturePlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteraturePlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteraturePlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteraturePlayers
     * const literaturePlayers = await prisma.literaturePlayer.findMany()
     * 
     * // Get first 10 LiteraturePlayers
     * const literaturePlayers = await prisma.literaturePlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literaturePlayerWithIdOnly = await prisma.literaturePlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteraturePlayerFindManyArgs>(args?: SelectSubset<T, LiteraturePlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteraturePlayer.
     * @param {LiteraturePlayerCreateArgs} args - Arguments to create a LiteraturePlayer.
     * @example
     * // Create one LiteraturePlayer
     * const LiteraturePlayer = await prisma.literaturePlayer.create({
     *   data: {
     *     // ... data to create a LiteraturePlayer
     *   }
     * })
     * 
     */
    create<T extends LiteraturePlayerCreateArgs>(args: SelectSubset<T, LiteraturePlayerCreateArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteraturePlayers.
     * @param {LiteraturePlayerCreateManyArgs} args - Arguments to create many LiteraturePlayers.
     * @example
     * // Create many LiteraturePlayers
     * const literaturePlayer = await prisma.literaturePlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteraturePlayerCreateManyArgs>(args?: SelectSubset<T, LiteraturePlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteraturePlayers and returns the data saved in the database.
     * @param {LiteraturePlayerCreateManyAndReturnArgs} args - Arguments to create many LiteraturePlayers.
     * @example
     * // Create many LiteraturePlayers
     * const literaturePlayer = await prisma.literaturePlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteraturePlayers and only return the `id`
     * const literaturePlayerWithIdOnly = await prisma.literaturePlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteraturePlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteraturePlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteraturePlayer.
     * @param {LiteraturePlayerDeleteArgs} args - Arguments to delete one LiteraturePlayer.
     * @example
     * // Delete one LiteraturePlayer
     * const LiteraturePlayer = await prisma.literaturePlayer.delete({
     *   where: {
     *     // ... filter to delete one LiteraturePlayer
     *   }
     * })
     * 
     */
    delete<T extends LiteraturePlayerDeleteArgs>(args: SelectSubset<T, LiteraturePlayerDeleteArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteraturePlayer.
     * @param {LiteraturePlayerUpdateArgs} args - Arguments to update one LiteraturePlayer.
     * @example
     * // Update one LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteraturePlayerUpdateArgs>(args: SelectSubset<T, LiteraturePlayerUpdateArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteraturePlayers.
     * @param {LiteraturePlayerDeleteManyArgs} args - Arguments to filter LiteraturePlayers to delete.
     * @example
     * // Delete a few LiteraturePlayers
     * const { count } = await prisma.literaturePlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteraturePlayerDeleteManyArgs>(args?: SelectSubset<T, LiteraturePlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteraturePlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteraturePlayers
     * const literaturePlayer = await prisma.literaturePlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteraturePlayerUpdateManyArgs>(args: SelectSubset<T, LiteraturePlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteraturePlayers and returns the data updated in the database.
     * @param {LiteraturePlayerUpdateManyAndReturnArgs} args - Arguments to update many LiteraturePlayers.
     * @example
     * // Update many LiteraturePlayers
     * const literaturePlayer = await prisma.literaturePlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteraturePlayers and only return the `id`
     * const literaturePlayerWithIdOnly = await prisma.literaturePlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteraturePlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteraturePlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteraturePlayer.
     * @param {LiteraturePlayerUpsertArgs} args - Arguments to update or create a LiteraturePlayer.
     * @example
     * // Update or create a LiteraturePlayer
     * const literaturePlayer = await prisma.literaturePlayer.upsert({
     *   create: {
     *     // ... data to create a LiteraturePlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteraturePlayer we want to update
     *   }
     * })
     */
    upsert<T extends LiteraturePlayerUpsertArgs>(args: SelectSubset<T, LiteraturePlayerUpsertArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteraturePlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerCountArgs} args - Arguments to filter LiteraturePlayers to count.
     * @example
     * // Count the number of LiteraturePlayers
     * const count = await prisma.literaturePlayer.count({
     *   where: {
     *     // ... the filter for the LiteraturePlayers we want to count
     *   }
     * })
    **/
    count<T extends LiteraturePlayerCountArgs>(
      args?: Subset<T, LiteraturePlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteraturePlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteraturePlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteraturePlayerAggregateArgs>(args: Subset<T, LiteraturePlayerAggregateArgs>): Prisma.PrismaPromise<GetLiteraturePlayerAggregateType<T>>

    /**
     * Group by LiteraturePlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteraturePlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteraturePlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteraturePlayerGroupByArgs['orderBy'] }
        : { orderBy?: LiteraturePlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteraturePlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteraturePlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteraturePlayer model
   */
  readonly fields: LiteraturePlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteraturePlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteraturePlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    team<T extends LiteraturePlayer$teamArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$teamArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    cardMappings<T extends LiteraturePlayer$cardMappingsArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$cardMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cardLocations<T extends LiteraturePlayer$cardLocationsArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$cardLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    asks<T extends LiteraturePlayer$asksArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$asksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    calls<T extends LiteraturePlayer$callsArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    transfers<T extends LiteraturePlayer$transfersArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayer$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteraturePlayer model
   */ 
  interface LiteraturePlayerFieldRefs {
    readonly id: FieldRef<"LiteraturePlayer", 'String'>
    readonly name: FieldRef<"LiteraturePlayer", 'String'>
    readonly avatar: FieldRef<"LiteraturePlayer", 'String'>
    readonly gameId: FieldRef<"LiteraturePlayer", 'String'>
    readonly teamId: FieldRef<"LiteraturePlayer", 'String'>
    readonly isBot: FieldRef<"LiteraturePlayer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LiteraturePlayer findUnique
   */
  export type LiteraturePlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter, which LiteraturePlayer to fetch.
     */
    where: LiteraturePlayerWhereUniqueInput
  }

  /**
   * LiteraturePlayer findUniqueOrThrow
   */
  export type LiteraturePlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter, which LiteraturePlayer to fetch.
     */
    where: LiteraturePlayerWhereUniqueInput
  }

  /**
   * LiteraturePlayer findFirst
   */
  export type LiteraturePlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter, which LiteraturePlayer to fetch.
     */
    where?: LiteraturePlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteraturePlayers to fetch.
     */
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteraturePlayers.
     */
    cursor?: LiteraturePlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteraturePlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteraturePlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteraturePlayers.
     */
    distinct?: LiteraturePlayerScalarFieldEnum | LiteraturePlayerScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer findFirstOrThrow
   */
  export type LiteraturePlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter, which LiteraturePlayer to fetch.
     */
    where?: LiteraturePlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteraturePlayers to fetch.
     */
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteraturePlayers.
     */
    cursor?: LiteraturePlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteraturePlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteraturePlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteraturePlayers.
     */
    distinct?: LiteraturePlayerScalarFieldEnum | LiteraturePlayerScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer findMany
   */
  export type LiteraturePlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter, which LiteraturePlayers to fetch.
     */
    where?: LiteraturePlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteraturePlayers to fetch.
     */
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteraturePlayers.
     */
    cursor?: LiteraturePlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteraturePlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteraturePlayers.
     */
    skip?: number
    distinct?: LiteraturePlayerScalarFieldEnum | LiteraturePlayerScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer create
   */
  export type LiteraturePlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteraturePlayer.
     */
    data: XOR<LiteraturePlayerCreateInput, LiteraturePlayerUncheckedCreateInput>
  }

  /**
   * LiteraturePlayer createMany
   */
  export type LiteraturePlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteraturePlayers.
     */
    data: LiteraturePlayerCreateManyInput | LiteraturePlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteraturePlayer createManyAndReturn
   */
  export type LiteraturePlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * The data used to create many LiteraturePlayers.
     */
    data: LiteraturePlayerCreateManyInput | LiteraturePlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteraturePlayer update
   */
  export type LiteraturePlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteraturePlayer.
     */
    data: XOR<LiteraturePlayerUpdateInput, LiteraturePlayerUncheckedUpdateInput>
    /**
     * Choose, which LiteraturePlayer to update.
     */
    where: LiteraturePlayerWhereUniqueInput
  }

  /**
   * LiteraturePlayer updateMany
   */
  export type LiteraturePlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteraturePlayers.
     */
    data: XOR<LiteraturePlayerUpdateManyMutationInput, LiteraturePlayerUncheckedUpdateManyInput>
    /**
     * Filter which LiteraturePlayers to update
     */
    where?: LiteraturePlayerWhereInput
    /**
     * Limit how many LiteraturePlayers to update.
     */
    limit?: number
  }

  /**
   * LiteraturePlayer updateManyAndReturn
   */
  export type LiteraturePlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * The data used to update LiteraturePlayers.
     */
    data: XOR<LiteraturePlayerUpdateManyMutationInput, LiteraturePlayerUncheckedUpdateManyInput>
    /**
     * Filter which LiteraturePlayers to update
     */
    where?: LiteraturePlayerWhereInput
    /**
     * Limit how many LiteraturePlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteraturePlayer upsert
   */
  export type LiteraturePlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteraturePlayer to update in case it exists.
     */
    where: LiteraturePlayerWhereUniqueInput
    /**
     * In case the LiteraturePlayer found by the `where` argument doesn't exist, create a new LiteraturePlayer with this data.
     */
    create: XOR<LiteraturePlayerCreateInput, LiteraturePlayerUncheckedCreateInput>
    /**
     * In case the LiteraturePlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteraturePlayerUpdateInput, LiteraturePlayerUncheckedUpdateInput>
  }

  /**
   * LiteraturePlayer delete
   */
  export type LiteraturePlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    /**
     * Filter which LiteraturePlayer to delete.
     */
    where: LiteraturePlayerWhereUniqueInput
  }

  /**
   * LiteraturePlayer deleteMany
   */
  export type LiteraturePlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteraturePlayers to delete
     */
    where?: LiteraturePlayerWhereInput
    /**
     * Limit how many LiteraturePlayers to delete.
     */
    limit?: number
  }

  /**
   * LiteraturePlayer.team
   */
  export type LiteraturePlayer$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    where?: LiteratureTeamWhereInput
  }

  /**
   * LiteraturePlayer.cardMappings
   */
  export type LiteraturePlayer$cardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    where?: LiteratureCardMappingWhereInput
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    cursor?: LiteratureCardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCardMappingScalarFieldEnum | LiteratureCardMappingScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer.cardLocations
   */
  export type LiteraturePlayer$cardLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    where?: LiteratureCardLocationWhereInput
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    cursor?: LiteratureCardLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCardLocationScalarFieldEnum | LiteratureCardLocationScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer.asks
   */
  export type LiteraturePlayer$asksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    where?: LiteratureAskWhereInput
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    cursor?: LiteratureAskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureAskScalarFieldEnum | LiteratureAskScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer.calls
   */
  export type LiteraturePlayer$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    where?: LiteratureCallWhereInput
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    cursor?: LiteratureCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCallScalarFieldEnum | LiteratureCallScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer.transfers
   */
  export type LiteraturePlayer$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    where?: LiteratureTransferWhereInput
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    cursor?: LiteratureTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureTransferScalarFieldEnum | LiteratureTransferScalarFieldEnum[]
  }

  /**
   * LiteraturePlayer without action
   */
  export type LiteraturePlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureTeam
   */

  export type AggregateLiteratureTeam = {
    _count: LiteratureTeamCountAggregateOutputType | null
    _avg: LiteratureTeamAvgAggregateOutputType | null
    _sum: LiteratureTeamSumAggregateOutputType | null
    _min: LiteratureTeamMinAggregateOutputType | null
    _max: LiteratureTeamMaxAggregateOutputType | null
  }

  export type LiteratureTeamAvgAggregateOutputType = {
    score: number | null
  }

  export type LiteratureTeamSumAggregateOutputType = {
    score: number | null
  }

  export type LiteratureTeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    score: number | null
    gameId: string | null
  }

  export type LiteratureTeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    score: number | null
    gameId: string | null
  }

  export type LiteratureTeamCountAggregateOutputType = {
    id: number
    name: number
    score: number
    setsWon: number
    memberIds: number
    gameId: number
    _all: number
  }


  export type LiteratureTeamAvgAggregateInputType = {
    score?: true
  }

  export type LiteratureTeamSumAggregateInputType = {
    score?: true
  }

  export type LiteratureTeamMinAggregateInputType = {
    id?: true
    name?: true
    score?: true
    gameId?: true
  }

  export type LiteratureTeamMaxAggregateInputType = {
    id?: true
    name?: true
    score?: true
    gameId?: true
  }

  export type LiteratureTeamCountAggregateInputType = {
    id?: true
    name?: true
    score?: true
    setsWon?: true
    memberIds?: true
    gameId?: true
    _all?: true
  }

  export type LiteratureTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureTeam to aggregate.
     */
    where?: LiteratureTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTeams to fetch.
     */
    orderBy?: LiteratureTeamOrderByWithRelationInput | LiteratureTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureTeams
    **/
    _count?: true | LiteratureTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiteratureTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiteratureTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureTeamMaxAggregateInputType
  }

  export type GetLiteratureTeamAggregateType<T extends LiteratureTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureTeam[P]>
      : GetScalarType<T[P], AggregateLiteratureTeam[P]>
  }




  export type LiteratureTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureTeamWhereInput
    orderBy?: LiteratureTeamOrderByWithAggregationInput | LiteratureTeamOrderByWithAggregationInput[]
    by: LiteratureTeamScalarFieldEnum[] | LiteratureTeamScalarFieldEnum
    having?: LiteratureTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureTeamCountAggregateInputType | true
    _avg?: LiteratureTeamAvgAggregateInputType
    _sum?: LiteratureTeamSumAggregateInputType
    _min?: LiteratureTeamMinAggregateInputType
    _max?: LiteratureTeamMaxAggregateInputType
  }

  export type LiteratureTeamGroupByOutputType = {
    id: string
    name: string
    score: number
    setsWon: string[]
    memberIds: string[]
    gameId: string
    _count: LiteratureTeamCountAggregateOutputType | null
    _avg: LiteratureTeamAvgAggregateOutputType | null
    _sum: LiteratureTeamSumAggregateOutputType | null
    _min: LiteratureTeamMinAggregateOutputType | null
    _max: LiteratureTeamMaxAggregateOutputType | null
  }

  type GetLiteratureTeamGroupByPayload<T extends LiteratureTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureTeamGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureTeamGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    score?: boolean
    setsWon?: boolean
    memberIds?: boolean
    gameId?: boolean
    members?: boolean | LiteratureTeam$membersArgs<ExtArgs>
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    _count?: boolean | LiteratureTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTeam"]>

  export type LiteratureTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    score?: boolean
    setsWon?: boolean
    memberIds?: boolean
    gameId?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTeam"]>

  export type LiteratureTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    score?: boolean
    setsWon?: boolean
    memberIds?: boolean
    gameId?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTeam"]>

  export type LiteratureTeamSelectScalar = {
    id?: boolean
    name?: boolean
    score?: boolean
    setsWon?: boolean
    memberIds?: boolean
    gameId?: boolean
  }

  export type LiteratureTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "score" | "setsWon" | "memberIds" | "gameId", ExtArgs["result"]["literatureTeam"]>
  export type LiteratureTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | LiteratureTeam$membersArgs<ExtArgs>
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    _count?: boolean | LiteratureTeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiteratureTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
  }
  export type LiteratureTeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
  }

  export type $LiteratureTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureTeam"
    objects: {
      members: Prisma.$LiteraturePlayerPayload<ExtArgs>[]
      game: Prisma.$LiteratureGamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      score: number
      setsWon: string[]
      memberIds: string[]
      gameId: string
    }, ExtArgs["result"]["literatureTeam"]>
    composites: {}
  }

  type LiteratureTeamGetPayload<S extends boolean | null | undefined | LiteratureTeamDefaultArgs> = $Result.GetResult<Prisma.$LiteratureTeamPayload, S>

  type LiteratureTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureTeamCountAggregateInputType | true
    }

  export interface LiteratureTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureTeam'], meta: { name: 'LiteratureTeam' } }
    /**
     * Find zero or one LiteratureTeam that matches the filter.
     * @param {LiteratureTeamFindUniqueArgs} args - Arguments to find a LiteratureTeam
     * @example
     * // Get one LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureTeamFindUniqueArgs>(args: SelectSubset<T, LiteratureTeamFindUniqueArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureTeamFindUniqueOrThrowArgs} args - Arguments to find a LiteratureTeam
     * @example
     * // Get one LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamFindFirstArgs} args - Arguments to find a LiteratureTeam
     * @example
     * // Get one LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureTeamFindFirstArgs>(args?: SelectSubset<T, LiteratureTeamFindFirstArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamFindFirstOrThrowArgs} args - Arguments to find a LiteratureTeam
     * @example
     * // Get one LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureTeams
     * const literatureTeams = await prisma.literatureTeam.findMany()
     * 
     * // Get first 10 LiteratureTeams
     * const literatureTeams = await prisma.literatureTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literatureTeamWithIdOnly = await prisma.literatureTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteratureTeamFindManyArgs>(args?: SelectSubset<T, LiteratureTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureTeam.
     * @param {LiteratureTeamCreateArgs} args - Arguments to create a LiteratureTeam.
     * @example
     * // Create one LiteratureTeam
     * const LiteratureTeam = await prisma.literatureTeam.create({
     *   data: {
     *     // ... data to create a LiteratureTeam
     *   }
     * })
     * 
     */
    create<T extends LiteratureTeamCreateArgs>(args: SelectSubset<T, LiteratureTeamCreateArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureTeams.
     * @param {LiteratureTeamCreateManyArgs} args - Arguments to create many LiteratureTeams.
     * @example
     * // Create many LiteratureTeams
     * const literatureTeam = await prisma.literatureTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureTeamCreateManyArgs>(args?: SelectSubset<T, LiteratureTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureTeams and returns the data saved in the database.
     * @param {LiteratureTeamCreateManyAndReturnArgs} args - Arguments to create many LiteratureTeams.
     * @example
     * // Create many LiteratureTeams
     * const literatureTeam = await prisma.literatureTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureTeams and only return the `id`
     * const literatureTeamWithIdOnly = await prisma.literatureTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureTeam.
     * @param {LiteratureTeamDeleteArgs} args - Arguments to delete one LiteratureTeam.
     * @example
     * // Delete one LiteratureTeam
     * const LiteratureTeam = await prisma.literatureTeam.delete({
     *   where: {
     *     // ... filter to delete one LiteratureTeam
     *   }
     * })
     * 
     */
    delete<T extends LiteratureTeamDeleteArgs>(args: SelectSubset<T, LiteratureTeamDeleteArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureTeam.
     * @param {LiteratureTeamUpdateArgs} args - Arguments to update one LiteratureTeam.
     * @example
     * // Update one LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureTeamUpdateArgs>(args: SelectSubset<T, LiteratureTeamUpdateArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureTeams.
     * @param {LiteratureTeamDeleteManyArgs} args - Arguments to filter LiteratureTeams to delete.
     * @example
     * // Delete a few LiteratureTeams
     * const { count } = await prisma.literatureTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureTeamDeleteManyArgs>(args?: SelectSubset<T, LiteratureTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureTeams
     * const literatureTeam = await prisma.literatureTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureTeamUpdateManyArgs>(args: SelectSubset<T, LiteratureTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureTeams and returns the data updated in the database.
     * @param {LiteratureTeamUpdateManyAndReturnArgs} args - Arguments to update many LiteratureTeams.
     * @example
     * // Update many LiteratureTeams
     * const literatureTeam = await prisma.literatureTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureTeams and only return the `id`
     * const literatureTeamWithIdOnly = await prisma.literatureTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureTeam.
     * @param {LiteratureTeamUpsertArgs} args - Arguments to update or create a LiteratureTeam.
     * @example
     * // Update or create a LiteratureTeam
     * const literatureTeam = await prisma.literatureTeam.upsert({
     *   create: {
     *     // ... data to create a LiteratureTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureTeam we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureTeamUpsertArgs>(args: SelectSubset<T, LiteratureTeamUpsertArgs<ExtArgs>>): Prisma__LiteratureTeamClient<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamCountArgs} args - Arguments to filter LiteratureTeams to count.
     * @example
     * // Count the number of LiteratureTeams
     * const count = await prisma.literatureTeam.count({
     *   where: {
     *     // ... the filter for the LiteratureTeams we want to count
     *   }
     * })
    **/
    count<T extends LiteratureTeamCountArgs>(
      args?: Subset<T, LiteratureTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureTeamAggregateArgs>(args: Subset<T, LiteratureTeamAggregateArgs>): Prisma.PrismaPromise<GetLiteratureTeamAggregateType<T>>

    /**
     * Group by LiteratureTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureTeamGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureTeam model
   */
  readonly fields: LiteratureTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends LiteratureTeam$membersArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureTeam$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureTeam model
   */ 
  interface LiteratureTeamFieldRefs {
    readonly id: FieldRef<"LiteratureTeam", 'String'>
    readonly name: FieldRef<"LiteratureTeam", 'String'>
    readonly score: FieldRef<"LiteratureTeam", 'Int'>
    readonly setsWon: FieldRef<"LiteratureTeam", 'String[]'>
    readonly memberIds: FieldRef<"LiteratureTeam", 'String[]'>
    readonly gameId: FieldRef<"LiteratureTeam", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureTeam findUnique
   */
  export type LiteratureTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTeam to fetch.
     */
    where: LiteratureTeamWhereUniqueInput
  }

  /**
   * LiteratureTeam findUniqueOrThrow
   */
  export type LiteratureTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTeam to fetch.
     */
    where: LiteratureTeamWhereUniqueInput
  }

  /**
   * LiteratureTeam findFirst
   */
  export type LiteratureTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTeam to fetch.
     */
    where?: LiteratureTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTeams to fetch.
     */
    orderBy?: LiteratureTeamOrderByWithRelationInput | LiteratureTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureTeams.
     */
    cursor?: LiteratureTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureTeams.
     */
    distinct?: LiteratureTeamScalarFieldEnum | LiteratureTeamScalarFieldEnum[]
  }

  /**
   * LiteratureTeam findFirstOrThrow
   */
  export type LiteratureTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTeam to fetch.
     */
    where?: LiteratureTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTeams to fetch.
     */
    orderBy?: LiteratureTeamOrderByWithRelationInput | LiteratureTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureTeams.
     */
    cursor?: LiteratureTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureTeams.
     */
    distinct?: LiteratureTeamScalarFieldEnum | LiteratureTeamScalarFieldEnum[]
  }

  /**
   * LiteratureTeam findMany
   */
  export type LiteratureTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTeams to fetch.
     */
    where?: LiteratureTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTeams to fetch.
     */
    orderBy?: LiteratureTeamOrderByWithRelationInput | LiteratureTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureTeams.
     */
    cursor?: LiteratureTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTeams.
     */
    skip?: number
    distinct?: LiteratureTeamScalarFieldEnum | LiteratureTeamScalarFieldEnum[]
  }

  /**
   * LiteratureTeam create
   */
  export type LiteratureTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureTeam.
     */
    data: XOR<LiteratureTeamCreateInput, LiteratureTeamUncheckedCreateInput>
  }

  /**
   * LiteratureTeam createMany
   */
  export type LiteratureTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureTeams.
     */
    data: LiteratureTeamCreateManyInput | LiteratureTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureTeam createManyAndReturn
   */
  export type LiteratureTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureTeams.
     */
    data: LiteratureTeamCreateManyInput | LiteratureTeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureTeam update
   */
  export type LiteratureTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureTeam.
     */
    data: XOR<LiteratureTeamUpdateInput, LiteratureTeamUncheckedUpdateInput>
    /**
     * Choose, which LiteratureTeam to update.
     */
    where: LiteratureTeamWhereUniqueInput
  }

  /**
   * LiteratureTeam updateMany
   */
  export type LiteratureTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureTeams.
     */
    data: XOR<LiteratureTeamUpdateManyMutationInput, LiteratureTeamUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureTeams to update
     */
    where?: LiteratureTeamWhereInput
    /**
     * Limit how many LiteratureTeams to update.
     */
    limit?: number
  }

  /**
   * LiteratureTeam updateManyAndReturn
   */
  export type LiteratureTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureTeams.
     */
    data: XOR<LiteratureTeamUpdateManyMutationInput, LiteratureTeamUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureTeams to update
     */
    where?: LiteratureTeamWhereInput
    /**
     * Limit how many LiteratureTeams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureTeam upsert
   */
  export type LiteratureTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureTeam to update in case it exists.
     */
    where: LiteratureTeamWhereUniqueInput
    /**
     * In case the LiteratureTeam found by the `where` argument doesn't exist, create a new LiteratureTeam with this data.
     */
    create: XOR<LiteratureTeamCreateInput, LiteratureTeamUncheckedCreateInput>
    /**
     * In case the LiteratureTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureTeamUpdateInput, LiteratureTeamUncheckedUpdateInput>
  }

  /**
   * LiteratureTeam delete
   */
  export type LiteratureTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    /**
     * Filter which LiteratureTeam to delete.
     */
    where: LiteratureTeamWhereUniqueInput
  }

  /**
   * LiteratureTeam deleteMany
   */
  export type LiteratureTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureTeams to delete
     */
    where?: LiteratureTeamWhereInput
    /**
     * Limit how many LiteratureTeams to delete.
     */
    limit?: number
  }

  /**
   * LiteratureTeam.members
   */
  export type LiteratureTeam$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    where?: LiteraturePlayerWhereInput
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    cursor?: LiteraturePlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteraturePlayerScalarFieldEnum | LiteraturePlayerScalarFieldEnum[]
  }

  /**
   * LiteratureTeam without action
   */
  export type LiteratureTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureCardMapping
   */

  export type AggregateLiteratureCardMapping = {
    _count: LiteratureCardMappingCountAggregateOutputType | null
    _min: LiteratureCardMappingMinAggregateOutputType | null
    _max: LiteratureCardMappingMaxAggregateOutputType | null
  }

  export type LiteratureCardMappingMinAggregateOutputType = {
    cardId: string | null
    gameId: string | null
    playerId: string | null
  }

  export type LiteratureCardMappingMaxAggregateOutputType = {
    cardId: string | null
    gameId: string | null
    playerId: string | null
  }

  export type LiteratureCardMappingCountAggregateOutputType = {
    cardId: number
    gameId: number
    playerId: number
    _all: number
  }


  export type LiteratureCardMappingMinAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
  }

  export type LiteratureCardMappingMaxAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
  }

  export type LiteratureCardMappingCountAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
    _all?: true
  }

  export type LiteratureCardMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCardMapping to aggregate.
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardMappings to fetch.
     */
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureCardMappings
    **/
    _count?: true | LiteratureCardMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureCardMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureCardMappingMaxAggregateInputType
  }

  export type GetLiteratureCardMappingAggregateType<T extends LiteratureCardMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureCardMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureCardMapping[P]>
      : GetScalarType<T[P], AggregateLiteratureCardMapping[P]>
  }




  export type LiteratureCardMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardMappingWhereInput
    orderBy?: LiteratureCardMappingOrderByWithAggregationInput | LiteratureCardMappingOrderByWithAggregationInput[]
    by: LiteratureCardMappingScalarFieldEnum[] | LiteratureCardMappingScalarFieldEnum
    having?: LiteratureCardMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureCardMappingCountAggregateInputType | true
    _min?: LiteratureCardMappingMinAggregateInputType
    _max?: LiteratureCardMappingMaxAggregateInputType
  }

  export type LiteratureCardMappingGroupByOutputType = {
    cardId: string
    gameId: string
    playerId: string
    _count: LiteratureCardMappingCountAggregateOutputType | null
    _min: LiteratureCardMappingMinAggregateOutputType | null
    _max: LiteratureCardMappingMaxAggregateOutputType | null
  }

  type GetLiteratureCardMappingGroupByPayload<T extends LiteratureCardMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureCardMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureCardMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureCardMappingGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureCardMappingGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureCardMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardMapping"]>

  export type LiteratureCardMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardMapping"]>

  export type LiteratureCardMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardMapping"]>

  export type LiteratureCardMappingSelectScalar = {
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
  }

  export type LiteratureCardMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cardId" | "gameId" | "playerId", ExtArgs["result"]["literatureCardMapping"]>
  export type LiteratureCardMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCardMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCardMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }

  export type $LiteratureCardMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureCardMapping"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      player: Prisma.$LiteraturePlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cardId: string
      gameId: string
      playerId: string
    }, ExtArgs["result"]["literatureCardMapping"]>
    composites: {}
  }

  type LiteratureCardMappingGetPayload<S extends boolean | null | undefined | LiteratureCardMappingDefaultArgs> = $Result.GetResult<Prisma.$LiteratureCardMappingPayload, S>

  type LiteratureCardMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureCardMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureCardMappingCountAggregateInputType | true
    }

  export interface LiteratureCardMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureCardMapping'], meta: { name: 'LiteratureCardMapping' } }
    /**
     * Find zero or one LiteratureCardMapping that matches the filter.
     * @param {LiteratureCardMappingFindUniqueArgs} args - Arguments to find a LiteratureCardMapping
     * @example
     * // Get one LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureCardMappingFindUniqueArgs>(args: SelectSubset<T, LiteratureCardMappingFindUniqueArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureCardMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureCardMappingFindUniqueOrThrowArgs} args - Arguments to find a LiteratureCardMapping
     * @example
     * // Get one LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureCardMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureCardMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCardMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingFindFirstArgs} args - Arguments to find a LiteratureCardMapping
     * @example
     * // Get one LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureCardMappingFindFirstArgs>(args?: SelectSubset<T, LiteratureCardMappingFindFirstArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCardMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingFindFirstOrThrowArgs} args - Arguments to find a LiteratureCardMapping
     * @example
     * // Get one LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureCardMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureCardMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureCardMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureCardMappings
     * const literatureCardMappings = await prisma.literatureCardMapping.findMany()
     * 
     * // Get first 10 LiteratureCardMappings
     * const literatureCardMappings = await prisma.literatureCardMapping.findMany({ take: 10 })
     * 
     * // Only select the `cardId`
     * const literatureCardMappingWithCardIdOnly = await prisma.literatureCardMapping.findMany({ select: { cardId: true } })
     * 
     */
    findMany<T extends LiteratureCardMappingFindManyArgs>(args?: SelectSubset<T, LiteratureCardMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureCardMapping.
     * @param {LiteratureCardMappingCreateArgs} args - Arguments to create a LiteratureCardMapping.
     * @example
     * // Create one LiteratureCardMapping
     * const LiteratureCardMapping = await prisma.literatureCardMapping.create({
     *   data: {
     *     // ... data to create a LiteratureCardMapping
     *   }
     * })
     * 
     */
    create<T extends LiteratureCardMappingCreateArgs>(args: SelectSubset<T, LiteratureCardMappingCreateArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureCardMappings.
     * @param {LiteratureCardMappingCreateManyArgs} args - Arguments to create many LiteratureCardMappings.
     * @example
     * // Create many LiteratureCardMappings
     * const literatureCardMapping = await prisma.literatureCardMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureCardMappingCreateManyArgs>(args?: SelectSubset<T, LiteratureCardMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureCardMappings and returns the data saved in the database.
     * @param {LiteratureCardMappingCreateManyAndReturnArgs} args - Arguments to create many LiteratureCardMappings.
     * @example
     * // Create many LiteratureCardMappings
     * const literatureCardMapping = await prisma.literatureCardMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureCardMappings and only return the `cardId`
     * const literatureCardMappingWithCardIdOnly = await prisma.literatureCardMapping.createManyAndReturn({
     *   select: { cardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureCardMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureCardMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureCardMapping.
     * @param {LiteratureCardMappingDeleteArgs} args - Arguments to delete one LiteratureCardMapping.
     * @example
     * // Delete one LiteratureCardMapping
     * const LiteratureCardMapping = await prisma.literatureCardMapping.delete({
     *   where: {
     *     // ... filter to delete one LiteratureCardMapping
     *   }
     * })
     * 
     */
    delete<T extends LiteratureCardMappingDeleteArgs>(args: SelectSubset<T, LiteratureCardMappingDeleteArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureCardMapping.
     * @param {LiteratureCardMappingUpdateArgs} args - Arguments to update one LiteratureCardMapping.
     * @example
     * // Update one LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureCardMappingUpdateArgs>(args: SelectSubset<T, LiteratureCardMappingUpdateArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureCardMappings.
     * @param {LiteratureCardMappingDeleteManyArgs} args - Arguments to filter LiteratureCardMappings to delete.
     * @example
     * // Delete a few LiteratureCardMappings
     * const { count } = await prisma.literatureCardMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureCardMappingDeleteManyArgs>(args?: SelectSubset<T, LiteratureCardMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureCardMappings
     * const literatureCardMapping = await prisma.literatureCardMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureCardMappingUpdateManyArgs>(args: SelectSubset<T, LiteratureCardMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCardMappings and returns the data updated in the database.
     * @param {LiteratureCardMappingUpdateManyAndReturnArgs} args - Arguments to update many LiteratureCardMappings.
     * @example
     * // Update many LiteratureCardMappings
     * const literatureCardMapping = await prisma.literatureCardMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureCardMappings and only return the `cardId`
     * const literatureCardMappingWithCardIdOnly = await prisma.literatureCardMapping.updateManyAndReturn({
     *   select: { cardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureCardMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureCardMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureCardMapping.
     * @param {LiteratureCardMappingUpsertArgs} args - Arguments to update or create a LiteratureCardMapping.
     * @example
     * // Update or create a LiteratureCardMapping
     * const literatureCardMapping = await prisma.literatureCardMapping.upsert({
     *   create: {
     *     // ... data to create a LiteratureCardMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureCardMapping we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureCardMappingUpsertArgs>(args: SelectSubset<T, LiteratureCardMappingUpsertArgs<ExtArgs>>): Prisma__LiteratureCardMappingClient<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureCardMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingCountArgs} args - Arguments to filter LiteratureCardMappings to count.
     * @example
     * // Count the number of LiteratureCardMappings
     * const count = await prisma.literatureCardMapping.count({
     *   where: {
     *     // ... the filter for the LiteratureCardMappings we want to count
     *   }
     * })
    **/
    count<T extends LiteratureCardMappingCountArgs>(
      args?: Subset<T, LiteratureCardMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureCardMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureCardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureCardMappingAggregateArgs>(args: Subset<T, LiteratureCardMappingAggregateArgs>): Prisma.PrismaPromise<GetLiteratureCardMappingAggregateType<T>>

    /**
     * Group by LiteratureCardMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureCardMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureCardMappingGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureCardMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureCardMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureCardMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureCardMapping model
   */
  readonly fields: LiteratureCardMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureCardMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureCardMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends LiteraturePlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayerDefaultArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureCardMapping model
   */ 
  interface LiteratureCardMappingFieldRefs {
    readonly cardId: FieldRef<"LiteratureCardMapping", 'String'>
    readonly gameId: FieldRef<"LiteratureCardMapping", 'String'>
    readonly playerId: FieldRef<"LiteratureCardMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureCardMapping findUnique
   */
  export type LiteratureCardMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardMapping to fetch.
     */
    where: LiteratureCardMappingWhereUniqueInput
  }

  /**
   * LiteratureCardMapping findUniqueOrThrow
   */
  export type LiteratureCardMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardMapping to fetch.
     */
    where: LiteratureCardMappingWhereUniqueInput
  }

  /**
   * LiteratureCardMapping findFirst
   */
  export type LiteratureCardMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardMapping to fetch.
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardMappings to fetch.
     */
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCardMappings.
     */
    cursor?: LiteratureCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCardMappings.
     */
    distinct?: LiteratureCardMappingScalarFieldEnum | LiteratureCardMappingScalarFieldEnum[]
  }

  /**
   * LiteratureCardMapping findFirstOrThrow
   */
  export type LiteratureCardMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardMapping to fetch.
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardMappings to fetch.
     */
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCardMappings.
     */
    cursor?: LiteratureCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCardMappings.
     */
    distinct?: LiteratureCardMappingScalarFieldEnum | LiteratureCardMappingScalarFieldEnum[]
  }

  /**
   * LiteratureCardMapping findMany
   */
  export type LiteratureCardMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardMappings to fetch.
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardMappings to fetch.
     */
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureCardMappings.
     */
    cursor?: LiteratureCardMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardMappings.
     */
    skip?: number
    distinct?: LiteratureCardMappingScalarFieldEnum | LiteratureCardMappingScalarFieldEnum[]
  }

  /**
   * LiteratureCardMapping create
   */
  export type LiteratureCardMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureCardMapping.
     */
    data: XOR<LiteratureCardMappingCreateInput, LiteratureCardMappingUncheckedCreateInput>
  }

  /**
   * LiteratureCardMapping createMany
   */
  export type LiteratureCardMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureCardMappings.
     */
    data: LiteratureCardMappingCreateManyInput | LiteratureCardMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureCardMapping createManyAndReturn
   */
  export type LiteratureCardMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureCardMappings.
     */
    data: LiteratureCardMappingCreateManyInput | LiteratureCardMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCardMapping update
   */
  export type LiteratureCardMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureCardMapping.
     */
    data: XOR<LiteratureCardMappingUpdateInput, LiteratureCardMappingUncheckedUpdateInput>
    /**
     * Choose, which LiteratureCardMapping to update.
     */
    where: LiteratureCardMappingWhereUniqueInput
  }

  /**
   * LiteratureCardMapping updateMany
   */
  export type LiteratureCardMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureCardMappings.
     */
    data: XOR<LiteratureCardMappingUpdateManyMutationInput, LiteratureCardMappingUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCardMappings to update
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * Limit how many LiteratureCardMappings to update.
     */
    limit?: number
  }

  /**
   * LiteratureCardMapping updateManyAndReturn
   */
  export type LiteratureCardMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureCardMappings.
     */
    data: XOR<LiteratureCardMappingUpdateManyMutationInput, LiteratureCardMappingUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCardMappings to update
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * Limit how many LiteratureCardMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCardMapping upsert
   */
  export type LiteratureCardMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureCardMapping to update in case it exists.
     */
    where: LiteratureCardMappingWhereUniqueInput
    /**
     * In case the LiteratureCardMapping found by the `where` argument doesn't exist, create a new LiteratureCardMapping with this data.
     */
    create: XOR<LiteratureCardMappingCreateInput, LiteratureCardMappingUncheckedCreateInput>
    /**
     * In case the LiteratureCardMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureCardMappingUpdateInput, LiteratureCardMappingUncheckedUpdateInput>
  }

  /**
   * LiteratureCardMapping delete
   */
  export type LiteratureCardMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    /**
     * Filter which LiteratureCardMapping to delete.
     */
    where: LiteratureCardMappingWhereUniqueInput
  }

  /**
   * LiteratureCardMapping deleteMany
   */
  export type LiteratureCardMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCardMappings to delete
     */
    where?: LiteratureCardMappingWhereInput
    /**
     * Limit how many LiteratureCardMappings to delete.
     */
    limit?: number
  }

  /**
   * LiteratureCardMapping without action
   */
  export type LiteratureCardMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureCardLocation
   */

  export type AggregateLiteratureCardLocation = {
    _count: LiteratureCardLocationCountAggregateOutputType | null
    _avg: LiteratureCardLocationAvgAggregateOutputType | null
    _sum: LiteratureCardLocationSumAggregateOutputType | null
    _min: LiteratureCardLocationMinAggregateOutputType | null
    _max: LiteratureCardLocationMaxAggregateOutputType | null
  }

  export type LiteratureCardLocationAvgAggregateOutputType = {
    weight: number | null
  }

  export type LiteratureCardLocationSumAggregateOutputType = {
    weight: number | null
  }

  export type LiteratureCardLocationMinAggregateOutputType = {
    cardId: string | null
    gameId: string | null
    playerId: string | null
    weight: number | null
  }

  export type LiteratureCardLocationMaxAggregateOutputType = {
    cardId: string | null
    gameId: string | null
    playerId: string | null
    weight: number | null
  }

  export type LiteratureCardLocationCountAggregateOutputType = {
    cardId: number
    gameId: number
    playerId: number
    playerIds: number
    weight: number
    _all: number
  }


  export type LiteratureCardLocationAvgAggregateInputType = {
    weight?: true
  }

  export type LiteratureCardLocationSumAggregateInputType = {
    weight?: true
  }

  export type LiteratureCardLocationMinAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
    weight?: true
  }

  export type LiteratureCardLocationMaxAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
    weight?: true
  }

  export type LiteratureCardLocationCountAggregateInputType = {
    cardId?: true
    gameId?: true
    playerId?: true
    playerIds?: true
    weight?: true
    _all?: true
  }

  export type LiteratureCardLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCardLocation to aggregate.
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardLocations to fetch.
     */
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureCardLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureCardLocations
    **/
    _count?: true | LiteratureCardLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiteratureCardLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiteratureCardLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureCardLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureCardLocationMaxAggregateInputType
  }

  export type GetLiteratureCardLocationAggregateType<T extends LiteratureCardLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureCardLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureCardLocation[P]>
      : GetScalarType<T[P], AggregateLiteratureCardLocation[P]>
  }




  export type LiteratureCardLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCardLocationWhereInput
    orderBy?: LiteratureCardLocationOrderByWithAggregationInput | LiteratureCardLocationOrderByWithAggregationInput[]
    by: LiteratureCardLocationScalarFieldEnum[] | LiteratureCardLocationScalarFieldEnum
    having?: LiteratureCardLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureCardLocationCountAggregateInputType | true
    _avg?: LiteratureCardLocationAvgAggregateInputType
    _sum?: LiteratureCardLocationSumAggregateInputType
    _min?: LiteratureCardLocationMinAggregateInputType
    _max?: LiteratureCardLocationMaxAggregateInputType
  }

  export type LiteratureCardLocationGroupByOutputType = {
    cardId: string
    gameId: string
    playerId: string
    playerIds: string[]
    weight: number
    _count: LiteratureCardLocationCountAggregateOutputType | null
    _avg: LiteratureCardLocationAvgAggregateOutputType | null
    _sum: LiteratureCardLocationSumAggregateOutputType | null
    _min: LiteratureCardLocationMinAggregateOutputType | null
    _max: LiteratureCardLocationMaxAggregateOutputType | null
  }

  type GetLiteratureCardLocationGroupByPayload<T extends LiteratureCardLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureCardLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureCardLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureCardLocationGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureCardLocationGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureCardLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    playerIds?: boolean
    weight?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardLocation"]>

  export type LiteratureCardLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    playerIds?: boolean
    weight?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardLocation"]>

  export type LiteratureCardLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    playerIds?: boolean
    weight?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCardLocation"]>

  export type LiteratureCardLocationSelectScalar = {
    cardId?: boolean
    gameId?: boolean
    playerId?: boolean
    playerIds?: boolean
    weight?: boolean
  }

  export type LiteratureCardLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cardId" | "gameId" | "playerId" | "playerIds" | "weight", ExtArgs["result"]["literatureCardLocation"]>
  export type LiteratureCardLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCardLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCardLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }

  export type $LiteratureCardLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureCardLocation"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      player: Prisma.$LiteraturePlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cardId: string
      gameId: string
      playerId: string
      playerIds: string[]
      weight: number
    }, ExtArgs["result"]["literatureCardLocation"]>
    composites: {}
  }

  type LiteratureCardLocationGetPayload<S extends boolean | null | undefined | LiteratureCardLocationDefaultArgs> = $Result.GetResult<Prisma.$LiteratureCardLocationPayload, S>

  type LiteratureCardLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureCardLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureCardLocationCountAggregateInputType | true
    }

  export interface LiteratureCardLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureCardLocation'], meta: { name: 'LiteratureCardLocation' } }
    /**
     * Find zero or one LiteratureCardLocation that matches the filter.
     * @param {LiteratureCardLocationFindUniqueArgs} args - Arguments to find a LiteratureCardLocation
     * @example
     * // Get one LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureCardLocationFindUniqueArgs>(args: SelectSubset<T, LiteratureCardLocationFindUniqueArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureCardLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureCardLocationFindUniqueOrThrowArgs} args - Arguments to find a LiteratureCardLocation
     * @example
     * // Get one LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureCardLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureCardLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCardLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationFindFirstArgs} args - Arguments to find a LiteratureCardLocation
     * @example
     * // Get one LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureCardLocationFindFirstArgs>(args?: SelectSubset<T, LiteratureCardLocationFindFirstArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCardLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationFindFirstOrThrowArgs} args - Arguments to find a LiteratureCardLocation
     * @example
     * // Get one LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureCardLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureCardLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureCardLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureCardLocations
     * const literatureCardLocations = await prisma.literatureCardLocation.findMany()
     * 
     * // Get first 10 LiteratureCardLocations
     * const literatureCardLocations = await prisma.literatureCardLocation.findMany({ take: 10 })
     * 
     * // Only select the `cardId`
     * const literatureCardLocationWithCardIdOnly = await prisma.literatureCardLocation.findMany({ select: { cardId: true } })
     * 
     */
    findMany<T extends LiteratureCardLocationFindManyArgs>(args?: SelectSubset<T, LiteratureCardLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureCardLocation.
     * @param {LiteratureCardLocationCreateArgs} args - Arguments to create a LiteratureCardLocation.
     * @example
     * // Create one LiteratureCardLocation
     * const LiteratureCardLocation = await prisma.literatureCardLocation.create({
     *   data: {
     *     // ... data to create a LiteratureCardLocation
     *   }
     * })
     * 
     */
    create<T extends LiteratureCardLocationCreateArgs>(args: SelectSubset<T, LiteratureCardLocationCreateArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureCardLocations.
     * @param {LiteratureCardLocationCreateManyArgs} args - Arguments to create many LiteratureCardLocations.
     * @example
     * // Create many LiteratureCardLocations
     * const literatureCardLocation = await prisma.literatureCardLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureCardLocationCreateManyArgs>(args?: SelectSubset<T, LiteratureCardLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureCardLocations and returns the data saved in the database.
     * @param {LiteratureCardLocationCreateManyAndReturnArgs} args - Arguments to create many LiteratureCardLocations.
     * @example
     * // Create many LiteratureCardLocations
     * const literatureCardLocation = await prisma.literatureCardLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureCardLocations and only return the `cardId`
     * const literatureCardLocationWithCardIdOnly = await prisma.literatureCardLocation.createManyAndReturn({
     *   select: { cardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureCardLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureCardLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureCardLocation.
     * @param {LiteratureCardLocationDeleteArgs} args - Arguments to delete one LiteratureCardLocation.
     * @example
     * // Delete one LiteratureCardLocation
     * const LiteratureCardLocation = await prisma.literatureCardLocation.delete({
     *   where: {
     *     // ... filter to delete one LiteratureCardLocation
     *   }
     * })
     * 
     */
    delete<T extends LiteratureCardLocationDeleteArgs>(args: SelectSubset<T, LiteratureCardLocationDeleteArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureCardLocation.
     * @param {LiteratureCardLocationUpdateArgs} args - Arguments to update one LiteratureCardLocation.
     * @example
     * // Update one LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureCardLocationUpdateArgs>(args: SelectSubset<T, LiteratureCardLocationUpdateArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureCardLocations.
     * @param {LiteratureCardLocationDeleteManyArgs} args - Arguments to filter LiteratureCardLocations to delete.
     * @example
     * // Delete a few LiteratureCardLocations
     * const { count } = await prisma.literatureCardLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureCardLocationDeleteManyArgs>(args?: SelectSubset<T, LiteratureCardLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCardLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureCardLocations
     * const literatureCardLocation = await prisma.literatureCardLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureCardLocationUpdateManyArgs>(args: SelectSubset<T, LiteratureCardLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCardLocations and returns the data updated in the database.
     * @param {LiteratureCardLocationUpdateManyAndReturnArgs} args - Arguments to update many LiteratureCardLocations.
     * @example
     * // Update many LiteratureCardLocations
     * const literatureCardLocation = await prisma.literatureCardLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureCardLocations and only return the `cardId`
     * const literatureCardLocationWithCardIdOnly = await prisma.literatureCardLocation.updateManyAndReturn({
     *   select: { cardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureCardLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureCardLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureCardLocation.
     * @param {LiteratureCardLocationUpsertArgs} args - Arguments to update or create a LiteratureCardLocation.
     * @example
     * // Update or create a LiteratureCardLocation
     * const literatureCardLocation = await prisma.literatureCardLocation.upsert({
     *   create: {
     *     // ... data to create a LiteratureCardLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureCardLocation we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureCardLocationUpsertArgs>(args: SelectSubset<T, LiteratureCardLocationUpsertArgs<ExtArgs>>): Prisma__LiteratureCardLocationClient<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureCardLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationCountArgs} args - Arguments to filter LiteratureCardLocations to count.
     * @example
     * // Count the number of LiteratureCardLocations
     * const count = await prisma.literatureCardLocation.count({
     *   where: {
     *     // ... the filter for the LiteratureCardLocations we want to count
     *   }
     * })
    **/
    count<T extends LiteratureCardLocationCountArgs>(
      args?: Subset<T, LiteratureCardLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureCardLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureCardLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureCardLocationAggregateArgs>(args: Subset<T, LiteratureCardLocationAggregateArgs>): Prisma.PrismaPromise<GetLiteratureCardLocationAggregateType<T>>

    /**
     * Group by LiteratureCardLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCardLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureCardLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureCardLocationGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureCardLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureCardLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureCardLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureCardLocation model
   */
  readonly fields: LiteratureCardLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureCardLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureCardLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends LiteraturePlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayerDefaultArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureCardLocation model
   */ 
  interface LiteratureCardLocationFieldRefs {
    readonly cardId: FieldRef<"LiteratureCardLocation", 'String'>
    readonly gameId: FieldRef<"LiteratureCardLocation", 'String'>
    readonly playerId: FieldRef<"LiteratureCardLocation", 'String'>
    readonly playerIds: FieldRef<"LiteratureCardLocation", 'String[]'>
    readonly weight: FieldRef<"LiteratureCardLocation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureCardLocation findUnique
   */
  export type LiteratureCardLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardLocation to fetch.
     */
    where: LiteratureCardLocationWhereUniqueInput
  }

  /**
   * LiteratureCardLocation findUniqueOrThrow
   */
  export type LiteratureCardLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardLocation to fetch.
     */
    where: LiteratureCardLocationWhereUniqueInput
  }

  /**
   * LiteratureCardLocation findFirst
   */
  export type LiteratureCardLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardLocation to fetch.
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardLocations to fetch.
     */
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCardLocations.
     */
    cursor?: LiteratureCardLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCardLocations.
     */
    distinct?: LiteratureCardLocationScalarFieldEnum | LiteratureCardLocationScalarFieldEnum[]
  }

  /**
   * LiteratureCardLocation findFirstOrThrow
   */
  export type LiteratureCardLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardLocation to fetch.
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardLocations to fetch.
     */
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCardLocations.
     */
    cursor?: LiteratureCardLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCardLocations.
     */
    distinct?: LiteratureCardLocationScalarFieldEnum | LiteratureCardLocationScalarFieldEnum[]
  }

  /**
   * LiteratureCardLocation findMany
   */
  export type LiteratureCardLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCardLocations to fetch.
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCardLocations to fetch.
     */
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureCardLocations.
     */
    cursor?: LiteratureCardLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCardLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCardLocations.
     */
    skip?: number
    distinct?: LiteratureCardLocationScalarFieldEnum | LiteratureCardLocationScalarFieldEnum[]
  }

  /**
   * LiteratureCardLocation create
   */
  export type LiteratureCardLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureCardLocation.
     */
    data: XOR<LiteratureCardLocationCreateInput, LiteratureCardLocationUncheckedCreateInput>
  }

  /**
   * LiteratureCardLocation createMany
   */
  export type LiteratureCardLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureCardLocations.
     */
    data: LiteratureCardLocationCreateManyInput | LiteratureCardLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureCardLocation createManyAndReturn
   */
  export type LiteratureCardLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureCardLocations.
     */
    data: LiteratureCardLocationCreateManyInput | LiteratureCardLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCardLocation update
   */
  export type LiteratureCardLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureCardLocation.
     */
    data: XOR<LiteratureCardLocationUpdateInput, LiteratureCardLocationUncheckedUpdateInput>
    /**
     * Choose, which LiteratureCardLocation to update.
     */
    where: LiteratureCardLocationWhereUniqueInput
  }

  /**
   * LiteratureCardLocation updateMany
   */
  export type LiteratureCardLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureCardLocations.
     */
    data: XOR<LiteratureCardLocationUpdateManyMutationInput, LiteratureCardLocationUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCardLocations to update
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * Limit how many LiteratureCardLocations to update.
     */
    limit?: number
  }

  /**
   * LiteratureCardLocation updateManyAndReturn
   */
  export type LiteratureCardLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureCardLocations.
     */
    data: XOR<LiteratureCardLocationUpdateManyMutationInput, LiteratureCardLocationUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCardLocations to update
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * Limit how many LiteratureCardLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCardLocation upsert
   */
  export type LiteratureCardLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureCardLocation to update in case it exists.
     */
    where: LiteratureCardLocationWhereUniqueInput
    /**
     * In case the LiteratureCardLocation found by the `where` argument doesn't exist, create a new LiteratureCardLocation with this data.
     */
    create: XOR<LiteratureCardLocationCreateInput, LiteratureCardLocationUncheckedCreateInput>
    /**
     * In case the LiteratureCardLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureCardLocationUpdateInput, LiteratureCardLocationUncheckedUpdateInput>
  }

  /**
   * LiteratureCardLocation delete
   */
  export type LiteratureCardLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    /**
     * Filter which LiteratureCardLocation to delete.
     */
    where: LiteratureCardLocationWhereUniqueInput
  }

  /**
   * LiteratureCardLocation deleteMany
   */
  export type LiteratureCardLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCardLocations to delete
     */
    where?: LiteratureCardLocationWhereInput
    /**
     * Limit how many LiteratureCardLocations to delete.
     */
    limit?: number
  }

  /**
   * LiteratureCardLocation without action
   */
  export type LiteratureCardLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureAsk
   */

  export type AggregateLiteratureAsk = {
    _count: LiteratureAskCountAggregateOutputType | null
    _min: LiteratureAskMinAggregateOutputType | null
    _max: LiteratureAskMaxAggregateOutputType | null
  }

  export type LiteratureAskMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    cardId: string | null
    askedFrom: string | null
  }

  export type LiteratureAskMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    cardId: string | null
    askedFrom: string | null
  }

  export type LiteratureAskCountAggregateOutputType = {
    id: number
    gameId: number
    playerId: number
    timestamp: number
    description: number
    success: number
    cardId: number
    askedFrom: number
    _all: number
  }


  export type LiteratureAskMinAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardId?: true
    askedFrom?: true
  }

  export type LiteratureAskMaxAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardId?: true
    askedFrom?: true
  }

  export type LiteratureAskCountAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardId?: true
    askedFrom?: true
    _all?: true
  }

  export type LiteratureAskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureAsk to aggregate.
     */
    where?: LiteratureAskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureAsks to fetch.
     */
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureAskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureAsks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureAsks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureAsks
    **/
    _count?: true | LiteratureAskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureAskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureAskMaxAggregateInputType
  }

  export type GetLiteratureAskAggregateType<T extends LiteratureAskAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureAsk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureAsk[P]>
      : GetScalarType<T[P], AggregateLiteratureAsk[P]>
  }




  export type LiteratureAskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureAskWhereInput
    orderBy?: LiteratureAskOrderByWithAggregationInput | LiteratureAskOrderByWithAggregationInput[]
    by: LiteratureAskScalarFieldEnum[] | LiteratureAskScalarFieldEnum
    having?: LiteratureAskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureAskCountAggregateInputType | true
    _min?: LiteratureAskMinAggregateInputType
    _max?: LiteratureAskMaxAggregateInputType
  }

  export type LiteratureAskGroupByOutputType = {
    id: string
    gameId: string
    playerId: string
    timestamp: Date
    description: string
    success: boolean
    cardId: string
    askedFrom: string
    _count: LiteratureAskCountAggregateOutputType | null
    _min: LiteratureAskMinAggregateOutputType | null
    _max: LiteratureAskMaxAggregateOutputType | null
  }

  type GetLiteratureAskGroupByPayload<T extends LiteratureAskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureAskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureAskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureAskGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureAskGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureAskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardId?: boolean
    askedFrom?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureAsk"]>

  export type LiteratureAskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardId?: boolean
    askedFrom?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureAsk"]>

  export type LiteratureAskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardId?: boolean
    askedFrom?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureAsk"]>

  export type LiteratureAskSelectScalar = {
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardId?: boolean
    askedFrom?: boolean
  }

  export type LiteratureAskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "playerId" | "timestamp" | "description" | "success" | "cardId" | "askedFrom", ExtArgs["result"]["literatureAsk"]>
  export type LiteratureAskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureAskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureAskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }

  export type $LiteratureAskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureAsk"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      player: Prisma.$LiteraturePlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      playerId: string
      timestamp: Date
      description: string
      success: boolean
      cardId: string
      askedFrom: string
    }, ExtArgs["result"]["literatureAsk"]>
    composites: {}
  }

  type LiteratureAskGetPayload<S extends boolean | null | undefined | LiteratureAskDefaultArgs> = $Result.GetResult<Prisma.$LiteratureAskPayload, S>

  type LiteratureAskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureAskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureAskCountAggregateInputType | true
    }

  export interface LiteratureAskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureAsk'], meta: { name: 'LiteratureAsk' } }
    /**
     * Find zero or one LiteratureAsk that matches the filter.
     * @param {LiteratureAskFindUniqueArgs} args - Arguments to find a LiteratureAsk
     * @example
     * // Get one LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureAskFindUniqueArgs>(args: SelectSubset<T, LiteratureAskFindUniqueArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureAsk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureAskFindUniqueOrThrowArgs} args - Arguments to find a LiteratureAsk
     * @example
     * // Get one LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureAskFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureAskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureAsk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskFindFirstArgs} args - Arguments to find a LiteratureAsk
     * @example
     * // Get one LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureAskFindFirstArgs>(args?: SelectSubset<T, LiteratureAskFindFirstArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureAsk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskFindFirstOrThrowArgs} args - Arguments to find a LiteratureAsk
     * @example
     * // Get one LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureAskFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureAskFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureAsks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureAsks
     * const literatureAsks = await prisma.literatureAsk.findMany()
     * 
     * // Get first 10 LiteratureAsks
     * const literatureAsks = await prisma.literatureAsk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literatureAskWithIdOnly = await prisma.literatureAsk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteratureAskFindManyArgs>(args?: SelectSubset<T, LiteratureAskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureAsk.
     * @param {LiteratureAskCreateArgs} args - Arguments to create a LiteratureAsk.
     * @example
     * // Create one LiteratureAsk
     * const LiteratureAsk = await prisma.literatureAsk.create({
     *   data: {
     *     // ... data to create a LiteratureAsk
     *   }
     * })
     * 
     */
    create<T extends LiteratureAskCreateArgs>(args: SelectSubset<T, LiteratureAskCreateArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureAsks.
     * @param {LiteratureAskCreateManyArgs} args - Arguments to create many LiteratureAsks.
     * @example
     * // Create many LiteratureAsks
     * const literatureAsk = await prisma.literatureAsk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureAskCreateManyArgs>(args?: SelectSubset<T, LiteratureAskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureAsks and returns the data saved in the database.
     * @param {LiteratureAskCreateManyAndReturnArgs} args - Arguments to create many LiteratureAsks.
     * @example
     * // Create many LiteratureAsks
     * const literatureAsk = await prisma.literatureAsk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureAsks and only return the `id`
     * const literatureAskWithIdOnly = await prisma.literatureAsk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureAskCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureAskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureAsk.
     * @param {LiteratureAskDeleteArgs} args - Arguments to delete one LiteratureAsk.
     * @example
     * // Delete one LiteratureAsk
     * const LiteratureAsk = await prisma.literatureAsk.delete({
     *   where: {
     *     // ... filter to delete one LiteratureAsk
     *   }
     * })
     * 
     */
    delete<T extends LiteratureAskDeleteArgs>(args: SelectSubset<T, LiteratureAskDeleteArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureAsk.
     * @param {LiteratureAskUpdateArgs} args - Arguments to update one LiteratureAsk.
     * @example
     * // Update one LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureAskUpdateArgs>(args: SelectSubset<T, LiteratureAskUpdateArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureAsks.
     * @param {LiteratureAskDeleteManyArgs} args - Arguments to filter LiteratureAsks to delete.
     * @example
     * // Delete a few LiteratureAsks
     * const { count } = await prisma.literatureAsk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureAskDeleteManyArgs>(args?: SelectSubset<T, LiteratureAskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureAsks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureAsks
     * const literatureAsk = await prisma.literatureAsk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureAskUpdateManyArgs>(args: SelectSubset<T, LiteratureAskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureAsks and returns the data updated in the database.
     * @param {LiteratureAskUpdateManyAndReturnArgs} args - Arguments to update many LiteratureAsks.
     * @example
     * // Update many LiteratureAsks
     * const literatureAsk = await prisma.literatureAsk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureAsks and only return the `id`
     * const literatureAskWithIdOnly = await prisma.literatureAsk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureAskUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureAskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureAsk.
     * @param {LiteratureAskUpsertArgs} args - Arguments to update or create a LiteratureAsk.
     * @example
     * // Update or create a LiteratureAsk
     * const literatureAsk = await prisma.literatureAsk.upsert({
     *   create: {
     *     // ... data to create a LiteratureAsk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureAsk we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureAskUpsertArgs>(args: SelectSubset<T, LiteratureAskUpsertArgs<ExtArgs>>): Prisma__LiteratureAskClient<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureAsks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskCountArgs} args - Arguments to filter LiteratureAsks to count.
     * @example
     * // Count the number of LiteratureAsks
     * const count = await prisma.literatureAsk.count({
     *   where: {
     *     // ... the filter for the LiteratureAsks we want to count
     *   }
     * })
    **/
    count<T extends LiteratureAskCountArgs>(
      args?: Subset<T, LiteratureAskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureAskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureAsk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureAskAggregateArgs>(args: Subset<T, LiteratureAskAggregateArgs>): Prisma.PrismaPromise<GetLiteratureAskAggregateType<T>>

    /**
     * Group by LiteratureAsk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureAskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureAskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureAskGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureAskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureAskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureAskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureAsk model
   */
  readonly fields: LiteratureAskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureAsk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureAskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends LiteraturePlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayerDefaultArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureAsk model
   */ 
  interface LiteratureAskFieldRefs {
    readonly id: FieldRef<"LiteratureAsk", 'String'>
    readonly gameId: FieldRef<"LiteratureAsk", 'String'>
    readonly playerId: FieldRef<"LiteratureAsk", 'String'>
    readonly timestamp: FieldRef<"LiteratureAsk", 'DateTime'>
    readonly description: FieldRef<"LiteratureAsk", 'String'>
    readonly success: FieldRef<"LiteratureAsk", 'Boolean'>
    readonly cardId: FieldRef<"LiteratureAsk", 'String'>
    readonly askedFrom: FieldRef<"LiteratureAsk", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureAsk findUnique
   */
  export type LiteratureAskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureAsk to fetch.
     */
    where: LiteratureAskWhereUniqueInput
  }

  /**
   * LiteratureAsk findUniqueOrThrow
   */
  export type LiteratureAskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureAsk to fetch.
     */
    where: LiteratureAskWhereUniqueInput
  }

  /**
   * LiteratureAsk findFirst
   */
  export type LiteratureAskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureAsk to fetch.
     */
    where?: LiteratureAskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureAsks to fetch.
     */
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureAsks.
     */
    cursor?: LiteratureAskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureAsks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureAsks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureAsks.
     */
    distinct?: LiteratureAskScalarFieldEnum | LiteratureAskScalarFieldEnum[]
  }

  /**
   * LiteratureAsk findFirstOrThrow
   */
  export type LiteratureAskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureAsk to fetch.
     */
    where?: LiteratureAskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureAsks to fetch.
     */
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureAsks.
     */
    cursor?: LiteratureAskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureAsks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureAsks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureAsks.
     */
    distinct?: LiteratureAskScalarFieldEnum | LiteratureAskScalarFieldEnum[]
  }

  /**
   * LiteratureAsk findMany
   */
  export type LiteratureAskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureAsks to fetch.
     */
    where?: LiteratureAskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureAsks to fetch.
     */
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureAsks.
     */
    cursor?: LiteratureAskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureAsks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureAsks.
     */
    skip?: number
    distinct?: LiteratureAskScalarFieldEnum | LiteratureAskScalarFieldEnum[]
  }

  /**
   * LiteratureAsk create
   */
  export type LiteratureAskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureAsk.
     */
    data: XOR<LiteratureAskCreateInput, LiteratureAskUncheckedCreateInput>
  }

  /**
   * LiteratureAsk createMany
   */
  export type LiteratureAskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureAsks.
     */
    data: LiteratureAskCreateManyInput | LiteratureAskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureAsk createManyAndReturn
   */
  export type LiteratureAskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureAsks.
     */
    data: LiteratureAskCreateManyInput | LiteratureAskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureAsk update
   */
  export type LiteratureAskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureAsk.
     */
    data: XOR<LiteratureAskUpdateInput, LiteratureAskUncheckedUpdateInput>
    /**
     * Choose, which LiteratureAsk to update.
     */
    where: LiteratureAskWhereUniqueInput
  }

  /**
   * LiteratureAsk updateMany
   */
  export type LiteratureAskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureAsks.
     */
    data: XOR<LiteratureAskUpdateManyMutationInput, LiteratureAskUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureAsks to update
     */
    where?: LiteratureAskWhereInput
    /**
     * Limit how many LiteratureAsks to update.
     */
    limit?: number
  }

  /**
   * LiteratureAsk updateManyAndReturn
   */
  export type LiteratureAskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureAsks.
     */
    data: XOR<LiteratureAskUpdateManyMutationInput, LiteratureAskUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureAsks to update
     */
    where?: LiteratureAskWhereInput
    /**
     * Limit how many LiteratureAsks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureAsk upsert
   */
  export type LiteratureAskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureAsk to update in case it exists.
     */
    where: LiteratureAskWhereUniqueInput
    /**
     * In case the LiteratureAsk found by the `where` argument doesn't exist, create a new LiteratureAsk with this data.
     */
    create: XOR<LiteratureAskCreateInput, LiteratureAskUncheckedCreateInput>
    /**
     * In case the LiteratureAsk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureAskUpdateInput, LiteratureAskUncheckedUpdateInput>
  }

  /**
   * LiteratureAsk delete
   */
  export type LiteratureAskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    /**
     * Filter which LiteratureAsk to delete.
     */
    where: LiteratureAskWhereUniqueInput
  }

  /**
   * LiteratureAsk deleteMany
   */
  export type LiteratureAskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureAsks to delete
     */
    where?: LiteratureAskWhereInput
    /**
     * Limit how many LiteratureAsks to delete.
     */
    limit?: number
  }

  /**
   * LiteratureAsk without action
   */
  export type LiteratureAskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureCall
   */

  export type AggregateLiteratureCall = {
    _count: LiteratureCallCountAggregateOutputType | null
    _min: LiteratureCallMinAggregateOutputType | null
    _max: LiteratureCallMaxAggregateOutputType | null
  }

  export type LiteratureCallMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    cardSet: string | null
  }

  export type LiteratureCallMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    cardSet: string | null
  }

  export type LiteratureCallCountAggregateOutputType = {
    id: number
    gameId: number
    playerId: number
    timestamp: number
    description: number
    success: number
    cardSet: number
    actualCall: number
    correctCall: number
    _all: number
  }


  export type LiteratureCallMinAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardSet?: true
  }

  export type LiteratureCallMaxAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardSet?: true
  }

  export type LiteratureCallCountAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    cardSet?: true
    actualCall?: true
    correctCall?: true
    _all?: true
  }

  export type LiteratureCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCall to aggregate.
     */
    where?: LiteratureCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCalls to fetch.
     */
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureCalls
    **/
    _count?: true | LiteratureCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureCallMaxAggregateInputType
  }

  export type GetLiteratureCallAggregateType<T extends LiteratureCallAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureCall[P]>
      : GetScalarType<T[P], AggregateLiteratureCall[P]>
  }




  export type LiteratureCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureCallWhereInput
    orderBy?: LiteratureCallOrderByWithAggregationInput | LiteratureCallOrderByWithAggregationInput[]
    by: LiteratureCallScalarFieldEnum[] | LiteratureCallScalarFieldEnum
    having?: LiteratureCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureCallCountAggregateInputType | true
    _min?: LiteratureCallMinAggregateInputType
    _max?: LiteratureCallMaxAggregateInputType
  }

  export type LiteratureCallGroupByOutputType = {
    id: string
    gameId: string
    playerId: string
    timestamp: Date
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
    _count: LiteratureCallCountAggregateOutputType | null
    _min: LiteratureCallMinAggregateOutputType | null
    _max: LiteratureCallMaxAggregateOutputType | null
  }

  type GetLiteratureCallGroupByPayload<T extends LiteratureCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureCallGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureCallGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardSet?: boolean
    actualCall?: boolean
    correctCall?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCall"]>

  export type LiteratureCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardSet?: boolean
    actualCall?: boolean
    correctCall?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCall"]>

  export type LiteratureCallSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardSet?: boolean
    actualCall?: boolean
    correctCall?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureCall"]>

  export type LiteratureCallSelectScalar = {
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    cardSet?: boolean
    actualCall?: boolean
    correctCall?: boolean
  }

  export type LiteratureCallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "playerId" | "timestamp" | "description" | "success" | "cardSet" | "actualCall" | "correctCall", ExtArgs["result"]["literatureCall"]>
  export type LiteratureCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureCallIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }

  export type $LiteratureCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureCall"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      player: Prisma.$LiteraturePlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      playerId: string
      timestamp: Date
      description: string
      success: boolean
      cardSet: string
      /**
       * ![Record<string, string>]
       */
      actualCall: (Record<string, string>)
      /**
       * ![Record<string, string>]
       */
      correctCall: (Record<string, string>)
    }, ExtArgs["result"]["literatureCall"]>
    composites: {}
  }

  type LiteratureCallGetPayload<S extends boolean | null | undefined | LiteratureCallDefaultArgs> = $Result.GetResult<Prisma.$LiteratureCallPayload, S>

  type LiteratureCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureCallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureCallCountAggregateInputType | true
    }

  export interface LiteratureCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureCall'], meta: { name: 'LiteratureCall' } }
    /**
     * Find zero or one LiteratureCall that matches the filter.
     * @param {LiteratureCallFindUniqueArgs} args - Arguments to find a LiteratureCall
     * @example
     * // Get one LiteratureCall
     * const literatureCall = await prisma.literatureCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureCallFindUniqueArgs>(args: SelectSubset<T, LiteratureCallFindUniqueArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureCall that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureCallFindUniqueOrThrowArgs} args - Arguments to find a LiteratureCall
     * @example
     * // Get one LiteratureCall
     * const literatureCall = await prisma.literatureCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureCallFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallFindFirstArgs} args - Arguments to find a LiteratureCall
     * @example
     * // Get one LiteratureCall
     * const literatureCall = await prisma.literatureCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureCallFindFirstArgs>(args?: SelectSubset<T, LiteratureCallFindFirstArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallFindFirstOrThrowArgs} args - Arguments to find a LiteratureCall
     * @example
     * // Get one LiteratureCall
     * const literatureCall = await prisma.literatureCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureCallFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureCalls
     * const literatureCalls = await prisma.literatureCall.findMany()
     * 
     * // Get first 10 LiteratureCalls
     * const literatureCalls = await prisma.literatureCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literatureCallWithIdOnly = await prisma.literatureCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteratureCallFindManyArgs>(args?: SelectSubset<T, LiteratureCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureCall.
     * @param {LiteratureCallCreateArgs} args - Arguments to create a LiteratureCall.
     * @example
     * // Create one LiteratureCall
     * const LiteratureCall = await prisma.literatureCall.create({
     *   data: {
     *     // ... data to create a LiteratureCall
     *   }
     * })
     * 
     */
    create<T extends LiteratureCallCreateArgs>(args: SelectSubset<T, LiteratureCallCreateArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureCalls.
     * @param {LiteratureCallCreateManyArgs} args - Arguments to create many LiteratureCalls.
     * @example
     * // Create many LiteratureCalls
     * const literatureCall = await prisma.literatureCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureCallCreateManyArgs>(args?: SelectSubset<T, LiteratureCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureCalls and returns the data saved in the database.
     * @param {LiteratureCallCreateManyAndReturnArgs} args - Arguments to create many LiteratureCalls.
     * @example
     * // Create many LiteratureCalls
     * const literatureCall = await prisma.literatureCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureCalls and only return the `id`
     * const literatureCallWithIdOnly = await prisma.literatureCall.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureCallCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureCall.
     * @param {LiteratureCallDeleteArgs} args - Arguments to delete one LiteratureCall.
     * @example
     * // Delete one LiteratureCall
     * const LiteratureCall = await prisma.literatureCall.delete({
     *   where: {
     *     // ... filter to delete one LiteratureCall
     *   }
     * })
     * 
     */
    delete<T extends LiteratureCallDeleteArgs>(args: SelectSubset<T, LiteratureCallDeleteArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureCall.
     * @param {LiteratureCallUpdateArgs} args - Arguments to update one LiteratureCall.
     * @example
     * // Update one LiteratureCall
     * const literatureCall = await prisma.literatureCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureCallUpdateArgs>(args: SelectSubset<T, LiteratureCallUpdateArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureCalls.
     * @param {LiteratureCallDeleteManyArgs} args - Arguments to filter LiteratureCalls to delete.
     * @example
     * // Delete a few LiteratureCalls
     * const { count } = await prisma.literatureCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureCallDeleteManyArgs>(args?: SelectSubset<T, LiteratureCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureCalls
     * const literatureCall = await prisma.literatureCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureCallUpdateManyArgs>(args: SelectSubset<T, LiteratureCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureCalls and returns the data updated in the database.
     * @param {LiteratureCallUpdateManyAndReturnArgs} args - Arguments to update many LiteratureCalls.
     * @example
     * // Update many LiteratureCalls
     * const literatureCall = await prisma.literatureCall.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureCalls and only return the `id`
     * const literatureCallWithIdOnly = await prisma.literatureCall.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureCallUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureCallUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureCall.
     * @param {LiteratureCallUpsertArgs} args - Arguments to update or create a LiteratureCall.
     * @example
     * // Update or create a LiteratureCall
     * const literatureCall = await prisma.literatureCall.upsert({
     *   create: {
     *     // ... data to create a LiteratureCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureCall we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureCallUpsertArgs>(args: SelectSubset<T, LiteratureCallUpsertArgs<ExtArgs>>): Prisma__LiteratureCallClient<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallCountArgs} args - Arguments to filter LiteratureCalls to count.
     * @example
     * // Count the number of LiteratureCalls
     * const count = await prisma.literatureCall.count({
     *   where: {
     *     // ... the filter for the LiteratureCalls we want to count
     *   }
     * })
    **/
    count<T extends LiteratureCallCountArgs>(
      args?: Subset<T, LiteratureCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureCallAggregateArgs>(args: Subset<T, LiteratureCallAggregateArgs>): Prisma.PrismaPromise<GetLiteratureCallAggregateType<T>>

    /**
     * Group by LiteratureCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureCallGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureCall model
   */
  readonly fields: LiteratureCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends LiteraturePlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayerDefaultArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureCall model
   */ 
  interface LiteratureCallFieldRefs {
    readonly id: FieldRef<"LiteratureCall", 'String'>
    readonly gameId: FieldRef<"LiteratureCall", 'String'>
    readonly playerId: FieldRef<"LiteratureCall", 'String'>
    readonly timestamp: FieldRef<"LiteratureCall", 'DateTime'>
    readonly description: FieldRef<"LiteratureCall", 'String'>
    readonly success: FieldRef<"LiteratureCall", 'Boolean'>
    readonly cardSet: FieldRef<"LiteratureCall", 'String'>
    readonly actualCall: FieldRef<"LiteratureCall", 'Json'>
    readonly correctCall: FieldRef<"LiteratureCall", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureCall findUnique
   */
  export type LiteratureCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCall to fetch.
     */
    where: LiteratureCallWhereUniqueInput
  }

  /**
   * LiteratureCall findUniqueOrThrow
   */
  export type LiteratureCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCall to fetch.
     */
    where: LiteratureCallWhereUniqueInput
  }

  /**
   * LiteratureCall findFirst
   */
  export type LiteratureCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCall to fetch.
     */
    where?: LiteratureCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCalls to fetch.
     */
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCalls.
     */
    cursor?: LiteratureCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCalls.
     */
    distinct?: LiteratureCallScalarFieldEnum | LiteratureCallScalarFieldEnum[]
  }

  /**
   * LiteratureCall findFirstOrThrow
   */
  export type LiteratureCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCall to fetch.
     */
    where?: LiteratureCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCalls to fetch.
     */
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureCalls.
     */
    cursor?: LiteratureCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureCalls.
     */
    distinct?: LiteratureCallScalarFieldEnum | LiteratureCallScalarFieldEnum[]
  }

  /**
   * LiteratureCall findMany
   */
  export type LiteratureCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureCalls to fetch.
     */
    where?: LiteratureCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureCalls to fetch.
     */
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureCalls.
     */
    cursor?: LiteratureCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureCalls.
     */
    skip?: number
    distinct?: LiteratureCallScalarFieldEnum | LiteratureCallScalarFieldEnum[]
  }

  /**
   * LiteratureCall create
   */
  export type LiteratureCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureCall.
     */
    data: XOR<LiteratureCallCreateInput, LiteratureCallUncheckedCreateInput>
  }

  /**
   * LiteratureCall createMany
   */
  export type LiteratureCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureCalls.
     */
    data: LiteratureCallCreateManyInput | LiteratureCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureCall createManyAndReturn
   */
  export type LiteratureCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureCalls.
     */
    data: LiteratureCallCreateManyInput | LiteratureCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCall update
   */
  export type LiteratureCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureCall.
     */
    data: XOR<LiteratureCallUpdateInput, LiteratureCallUncheckedUpdateInput>
    /**
     * Choose, which LiteratureCall to update.
     */
    where: LiteratureCallWhereUniqueInput
  }

  /**
   * LiteratureCall updateMany
   */
  export type LiteratureCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureCalls.
     */
    data: XOR<LiteratureCallUpdateManyMutationInput, LiteratureCallUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCalls to update
     */
    where?: LiteratureCallWhereInput
    /**
     * Limit how many LiteratureCalls to update.
     */
    limit?: number
  }

  /**
   * LiteratureCall updateManyAndReturn
   */
  export type LiteratureCallUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureCalls.
     */
    data: XOR<LiteratureCallUpdateManyMutationInput, LiteratureCallUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureCalls to update
     */
    where?: LiteratureCallWhereInput
    /**
     * Limit how many LiteratureCalls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureCall upsert
   */
  export type LiteratureCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureCall to update in case it exists.
     */
    where: LiteratureCallWhereUniqueInput
    /**
     * In case the LiteratureCall found by the `where` argument doesn't exist, create a new LiteratureCall with this data.
     */
    create: XOR<LiteratureCallCreateInput, LiteratureCallUncheckedCreateInput>
    /**
     * In case the LiteratureCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureCallUpdateInput, LiteratureCallUncheckedUpdateInput>
  }

  /**
   * LiteratureCall delete
   */
  export type LiteratureCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    /**
     * Filter which LiteratureCall to delete.
     */
    where: LiteratureCallWhereUniqueInput
  }

  /**
   * LiteratureCall deleteMany
   */
  export type LiteratureCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureCalls to delete
     */
    where?: LiteratureCallWhereInput
    /**
     * Limit how many LiteratureCalls to delete.
     */
    limit?: number
  }

  /**
   * LiteratureCall without action
   */
  export type LiteratureCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureTransfer
   */

  export type AggregateLiteratureTransfer = {
    _count: LiteratureTransferCountAggregateOutputType | null
    _min: LiteratureTransferMinAggregateOutputType | null
    _max: LiteratureTransferMaxAggregateOutputType | null
  }

  export type LiteratureTransferMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    transferTo: string | null
  }

  export type LiteratureTransferMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    playerId: string | null
    timestamp: Date | null
    description: string | null
    success: boolean | null
    transferTo: string | null
  }

  export type LiteratureTransferCountAggregateOutputType = {
    id: number
    gameId: number
    playerId: number
    timestamp: number
    description: number
    success: number
    transferTo: number
    _all: number
  }


  export type LiteratureTransferMinAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    transferTo?: true
  }

  export type LiteratureTransferMaxAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    transferTo?: true
  }

  export type LiteratureTransferCountAggregateInputType = {
    id?: true
    gameId?: true
    playerId?: true
    timestamp?: true
    description?: true
    success?: true
    transferTo?: true
    _all?: true
  }

  export type LiteratureTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureTransfer to aggregate.
     */
    where?: LiteratureTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTransfers to fetch.
     */
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureTransfers
    **/
    _count?: true | LiteratureTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureTransferMaxAggregateInputType
  }

  export type GetLiteratureTransferAggregateType<T extends LiteratureTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureTransfer[P]>
      : GetScalarType<T[P], AggregateLiteratureTransfer[P]>
  }




  export type LiteratureTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureTransferWhereInput
    orderBy?: LiteratureTransferOrderByWithAggregationInput | LiteratureTransferOrderByWithAggregationInput[]
    by: LiteratureTransferScalarFieldEnum[] | LiteratureTransferScalarFieldEnum
    having?: LiteratureTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureTransferCountAggregateInputType | true
    _min?: LiteratureTransferMinAggregateInputType
    _max?: LiteratureTransferMaxAggregateInputType
  }

  export type LiteratureTransferGroupByOutputType = {
    id: string
    gameId: string
    playerId: string
    timestamp: Date
    description: string
    success: boolean
    transferTo: string
    _count: LiteratureTransferCountAggregateOutputType | null
    _min: LiteratureTransferMinAggregateOutputType | null
    _max: LiteratureTransferMaxAggregateOutputType | null
  }

  type GetLiteratureTransferGroupByPayload<T extends LiteratureTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureTransferGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureTransferGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    transferTo?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTransfer"]>

  export type LiteratureTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    transferTo?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTransfer"]>

  export type LiteratureTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    transferTo?: boolean
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureTransfer"]>

  export type LiteratureTransferSelectScalar = {
    id?: boolean
    gameId?: boolean
    playerId?: boolean
    timestamp?: boolean
    description?: boolean
    success?: boolean
    transferTo?: boolean
  }

  export type LiteratureTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "playerId" | "timestamp" | "description" | "success" | "transferTo", ExtArgs["result"]["literatureTransfer"]>
  export type LiteratureTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }
  export type LiteratureTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | LiteratureGameDefaultArgs<ExtArgs>
    player?: boolean | LiteraturePlayerDefaultArgs<ExtArgs>
  }

  export type $LiteratureTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureTransfer"
    objects: {
      game: Prisma.$LiteratureGamePayload<ExtArgs>
      player: Prisma.$LiteraturePlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      playerId: string
      timestamp: Date
      description: string
      success: boolean
      transferTo: string
    }, ExtArgs["result"]["literatureTransfer"]>
    composites: {}
  }

  type LiteratureTransferGetPayload<S extends boolean | null | undefined | LiteratureTransferDefaultArgs> = $Result.GetResult<Prisma.$LiteratureTransferPayload, S>

  type LiteratureTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureTransferCountAggregateInputType | true
    }

  export interface LiteratureTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureTransfer'], meta: { name: 'LiteratureTransfer' } }
    /**
     * Find zero or one LiteratureTransfer that matches the filter.
     * @param {LiteratureTransferFindUniqueArgs} args - Arguments to find a LiteratureTransfer
     * @example
     * // Get one LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureTransferFindUniqueArgs>(args: SelectSubset<T, LiteratureTransferFindUniqueArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureTransferFindUniqueOrThrowArgs} args - Arguments to find a LiteratureTransfer
     * @example
     * // Get one LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferFindFirstArgs} args - Arguments to find a LiteratureTransfer
     * @example
     * // Get one LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureTransferFindFirstArgs>(args?: SelectSubset<T, LiteratureTransferFindFirstArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferFindFirstOrThrowArgs} args - Arguments to find a LiteratureTransfer
     * @example
     * // Get one LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureTransfers
     * const literatureTransfers = await prisma.literatureTransfer.findMany()
     * 
     * // Get first 10 LiteratureTransfers
     * const literatureTransfers = await prisma.literatureTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literatureTransferWithIdOnly = await prisma.literatureTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteratureTransferFindManyArgs>(args?: SelectSubset<T, LiteratureTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureTransfer.
     * @param {LiteratureTransferCreateArgs} args - Arguments to create a LiteratureTransfer.
     * @example
     * // Create one LiteratureTransfer
     * const LiteratureTransfer = await prisma.literatureTransfer.create({
     *   data: {
     *     // ... data to create a LiteratureTransfer
     *   }
     * })
     * 
     */
    create<T extends LiteratureTransferCreateArgs>(args: SelectSubset<T, LiteratureTransferCreateArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureTransfers.
     * @param {LiteratureTransferCreateManyArgs} args - Arguments to create many LiteratureTransfers.
     * @example
     * // Create many LiteratureTransfers
     * const literatureTransfer = await prisma.literatureTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureTransferCreateManyArgs>(args?: SelectSubset<T, LiteratureTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureTransfers and returns the data saved in the database.
     * @param {LiteratureTransferCreateManyAndReturnArgs} args - Arguments to create many LiteratureTransfers.
     * @example
     * // Create many LiteratureTransfers
     * const literatureTransfer = await prisma.literatureTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureTransfers and only return the `id`
     * const literatureTransferWithIdOnly = await prisma.literatureTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureTransfer.
     * @param {LiteratureTransferDeleteArgs} args - Arguments to delete one LiteratureTransfer.
     * @example
     * // Delete one LiteratureTransfer
     * const LiteratureTransfer = await prisma.literatureTransfer.delete({
     *   where: {
     *     // ... filter to delete one LiteratureTransfer
     *   }
     * })
     * 
     */
    delete<T extends LiteratureTransferDeleteArgs>(args: SelectSubset<T, LiteratureTransferDeleteArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureTransfer.
     * @param {LiteratureTransferUpdateArgs} args - Arguments to update one LiteratureTransfer.
     * @example
     * // Update one LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureTransferUpdateArgs>(args: SelectSubset<T, LiteratureTransferUpdateArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureTransfers.
     * @param {LiteratureTransferDeleteManyArgs} args - Arguments to filter LiteratureTransfers to delete.
     * @example
     * // Delete a few LiteratureTransfers
     * const { count } = await prisma.literatureTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureTransferDeleteManyArgs>(args?: SelectSubset<T, LiteratureTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureTransfers
     * const literatureTransfer = await prisma.literatureTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureTransferUpdateManyArgs>(args: SelectSubset<T, LiteratureTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureTransfers and returns the data updated in the database.
     * @param {LiteratureTransferUpdateManyAndReturnArgs} args - Arguments to update many LiteratureTransfers.
     * @example
     * // Update many LiteratureTransfers
     * const literatureTransfer = await prisma.literatureTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureTransfers and only return the `id`
     * const literatureTransferWithIdOnly = await prisma.literatureTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureTransfer.
     * @param {LiteratureTransferUpsertArgs} args - Arguments to update or create a LiteratureTransfer.
     * @example
     * // Update or create a LiteratureTransfer
     * const literatureTransfer = await prisma.literatureTransfer.upsert({
     *   create: {
     *     // ... data to create a LiteratureTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureTransfer we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureTransferUpsertArgs>(args: SelectSubset<T, LiteratureTransferUpsertArgs<ExtArgs>>): Prisma__LiteratureTransferClient<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferCountArgs} args - Arguments to filter LiteratureTransfers to count.
     * @example
     * // Count the number of LiteratureTransfers
     * const count = await prisma.literatureTransfer.count({
     *   where: {
     *     // ... the filter for the LiteratureTransfers we want to count
     *   }
     * })
    **/
    count<T extends LiteratureTransferCountArgs>(
      args?: Subset<T, LiteratureTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureTransferAggregateArgs>(args: Subset<T, LiteratureTransferAggregateArgs>): Prisma.PrismaPromise<GetLiteratureTransferAggregateType<T>>

    /**
     * Group by LiteratureTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureTransferGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureTransfer model
   */
  readonly fields: LiteratureTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends LiteratureGameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGameDefaultArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    player<T extends LiteraturePlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiteraturePlayerDefaultArgs<ExtArgs>>): Prisma__LiteraturePlayerClient<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureTransfer model
   */ 
  interface LiteratureTransferFieldRefs {
    readonly id: FieldRef<"LiteratureTransfer", 'String'>
    readonly gameId: FieldRef<"LiteratureTransfer", 'String'>
    readonly playerId: FieldRef<"LiteratureTransfer", 'String'>
    readonly timestamp: FieldRef<"LiteratureTransfer", 'DateTime'>
    readonly description: FieldRef<"LiteratureTransfer", 'String'>
    readonly success: FieldRef<"LiteratureTransfer", 'Boolean'>
    readonly transferTo: FieldRef<"LiteratureTransfer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureTransfer findUnique
   */
  export type LiteratureTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTransfer to fetch.
     */
    where: LiteratureTransferWhereUniqueInput
  }

  /**
   * LiteratureTransfer findUniqueOrThrow
   */
  export type LiteratureTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTransfer to fetch.
     */
    where: LiteratureTransferWhereUniqueInput
  }

  /**
   * LiteratureTransfer findFirst
   */
  export type LiteratureTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTransfer to fetch.
     */
    where?: LiteratureTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTransfers to fetch.
     */
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureTransfers.
     */
    cursor?: LiteratureTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureTransfers.
     */
    distinct?: LiteratureTransferScalarFieldEnum | LiteratureTransferScalarFieldEnum[]
  }

  /**
   * LiteratureTransfer findFirstOrThrow
   */
  export type LiteratureTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTransfer to fetch.
     */
    where?: LiteratureTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTransfers to fetch.
     */
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureTransfers.
     */
    cursor?: LiteratureTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureTransfers.
     */
    distinct?: LiteratureTransferScalarFieldEnum | LiteratureTransferScalarFieldEnum[]
  }

  /**
   * LiteratureTransfer findMany
   */
  export type LiteratureTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureTransfers to fetch.
     */
    where?: LiteratureTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureTransfers to fetch.
     */
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureTransfers.
     */
    cursor?: LiteratureTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureTransfers.
     */
    skip?: number
    distinct?: LiteratureTransferScalarFieldEnum | LiteratureTransferScalarFieldEnum[]
  }

  /**
   * LiteratureTransfer create
   */
  export type LiteratureTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureTransfer.
     */
    data: XOR<LiteratureTransferCreateInput, LiteratureTransferUncheckedCreateInput>
  }

  /**
   * LiteratureTransfer createMany
   */
  export type LiteratureTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureTransfers.
     */
    data: LiteratureTransferCreateManyInput | LiteratureTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureTransfer createManyAndReturn
   */
  export type LiteratureTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureTransfers.
     */
    data: LiteratureTransferCreateManyInput | LiteratureTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureTransfer update
   */
  export type LiteratureTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureTransfer.
     */
    data: XOR<LiteratureTransferUpdateInput, LiteratureTransferUncheckedUpdateInput>
    /**
     * Choose, which LiteratureTransfer to update.
     */
    where: LiteratureTransferWhereUniqueInput
  }

  /**
   * LiteratureTransfer updateMany
   */
  export type LiteratureTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureTransfers.
     */
    data: XOR<LiteratureTransferUpdateManyMutationInput, LiteratureTransferUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureTransfers to update
     */
    where?: LiteratureTransferWhereInput
    /**
     * Limit how many LiteratureTransfers to update.
     */
    limit?: number
  }

  /**
   * LiteratureTransfer updateManyAndReturn
   */
  export type LiteratureTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureTransfers.
     */
    data: XOR<LiteratureTransferUpdateManyMutationInput, LiteratureTransferUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureTransfers to update
     */
    where?: LiteratureTransferWhereInput
    /**
     * Limit how many LiteratureTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiteratureTransfer upsert
   */
  export type LiteratureTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureTransfer to update in case it exists.
     */
    where: LiteratureTransferWhereUniqueInput
    /**
     * In case the LiteratureTransfer found by the `where` argument doesn't exist, create a new LiteratureTransfer with this data.
     */
    create: XOR<LiteratureTransferCreateInput, LiteratureTransferUncheckedCreateInput>
    /**
     * In case the LiteratureTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureTransferUpdateInput, LiteratureTransferUncheckedUpdateInput>
  }

  /**
   * LiteratureTransfer delete
   */
  export type LiteratureTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    /**
     * Filter which LiteratureTransfer to delete.
     */
    where: LiteratureTransferWhereUniqueInput
  }

  /**
   * LiteratureTransfer deleteMany
   */
  export type LiteratureTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureTransfers to delete
     */
    where?: LiteratureTransferWhereInput
    /**
     * Limit how many LiteratureTransfers to delete.
     */
    limit?: number
  }

  /**
   * LiteratureTransfer without action
   */
  export type LiteratureTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
  }


  /**
   * Model LiteratureGame
   */

  export type AggregateLiteratureGame = {
    _count: LiteratureGameCountAggregateOutputType | null
    _avg: LiteratureGameAvgAggregateOutputType | null
    _sum: LiteratureGameSumAggregateOutputType | null
    _min: LiteratureGameMinAggregateOutputType | null
    _max: LiteratureGameMaxAggregateOutputType | null
  }

  export type LiteratureGameAvgAggregateOutputType = {
    playerCount: number | null
  }

  export type LiteratureGameSumAggregateOutputType = {
    playerCount: number | null
  }

  export type LiteratureGameMinAggregateOutputType = {
    id: string | null
    code: string | null
    status: $Enums.LiteratureGameStatus | null
    playerCount: number | null
    currentTurn: string | null
    lastMoveId: string | null
  }

  export type LiteratureGameMaxAggregateOutputType = {
    id: string | null
    code: string | null
    status: $Enums.LiteratureGameStatus | null
    playerCount: number | null
    currentTurn: string | null
    lastMoveId: string | null
  }

  export type LiteratureGameCountAggregateOutputType = {
    id: number
    code: number
    status: number
    playerCount: number
    currentTurn: number
    lastMoveId: number
    _all: number
  }


  export type LiteratureGameAvgAggregateInputType = {
    playerCount?: true
  }

  export type LiteratureGameSumAggregateInputType = {
    playerCount?: true
  }

  export type LiteratureGameMinAggregateInputType = {
    id?: true
    code?: true
    status?: true
    playerCount?: true
    currentTurn?: true
    lastMoveId?: true
  }

  export type LiteratureGameMaxAggregateInputType = {
    id?: true
    code?: true
    status?: true
    playerCount?: true
    currentTurn?: true
    lastMoveId?: true
  }

  export type LiteratureGameCountAggregateInputType = {
    id?: true
    code?: true
    status?: true
    playerCount?: true
    currentTurn?: true
    lastMoveId?: true
    _all?: true
  }

  export type LiteratureGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureGame to aggregate.
     */
    where?: LiteratureGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureGames to fetch.
     */
    orderBy?: LiteratureGameOrderByWithRelationInput | LiteratureGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiteratureGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiteratureGames
    **/
    _count?: true | LiteratureGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiteratureGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiteratureGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiteratureGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiteratureGameMaxAggregateInputType
  }

  export type GetLiteratureGameAggregateType<T extends LiteratureGameAggregateArgs> = {
        [P in keyof T & keyof AggregateLiteratureGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiteratureGame[P]>
      : GetScalarType<T[P], AggregateLiteratureGame[P]>
  }




  export type LiteratureGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiteratureGameWhereInput
    orderBy?: LiteratureGameOrderByWithAggregationInput | LiteratureGameOrderByWithAggregationInput[]
    by: LiteratureGameScalarFieldEnum[] | LiteratureGameScalarFieldEnum
    having?: LiteratureGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiteratureGameCountAggregateInputType | true
    _avg?: LiteratureGameAvgAggregateInputType
    _sum?: LiteratureGameSumAggregateInputType
    _min?: LiteratureGameMinAggregateInputType
    _max?: LiteratureGameMaxAggregateInputType
  }

  export type LiteratureGameGroupByOutputType = {
    id: string
    code: string
    status: $Enums.LiteratureGameStatus
    playerCount: number
    currentTurn: string
    lastMoveId: string
    _count: LiteratureGameCountAggregateOutputType | null
    _avg: LiteratureGameAvgAggregateOutputType | null
    _sum: LiteratureGameSumAggregateOutputType | null
    _min: LiteratureGameMinAggregateOutputType | null
    _max: LiteratureGameMaxAggregateOutputType | null
  }

  type GetLiteratureGameGroupByPayload<T extends LiteratureGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiteratureGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiteratureGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiteratureGameGroupByOutputType[P]>
            : GetScalarType<T[P], LiteratureGameGroupByOutputType[P]>
        }
      >
    >


  export type LiteratureGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    playerCount?: boolean
    currentTurn?: boolean
    lastMoveId?: boolean
    players?: boolean | LiteratureGame$playersArgs<ExtArgs>
    teams?: boolean | LiteratureGame$teamsArgs<ExtArgs>
    cardMappings?: boolean | LiteratureGame$cardMappingsArgs<ExtArgs>
    cardLocations?: boolean | LiteratureGame$cardLocationsArgs<ExtArgs>
    asks?: boolean | LiteratureGame$asksArgs<ExtArgs>
    calls?: boolean | LiteratureGame$callsArgs<ExtArgs>
    transfers?: boolean | LiteratureGame$transfersArgs<ExtArgs>
    _count?: boolean | LiteratureGameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["literatureGame"]>

  export type LiteratureGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    playerCount?: boolean
    currentTurn?: boolean
    lastMoveId?: boolean
  }, ExtArgs["result"]["literatureGame"]>

  export type LiteratureGameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    status?: boolean
    playerCount?: boolean
    currentTurn?: boolean
    lastMoveId?: boolean
  }, ExtArgs["result"]["literatureGame"]>

  export type LiteratureGameSelectScalar = {
    id?: boolean
    code?: boolean
    status?: boolean
    playerCount?: boolean
    currentTurn?: boolean
    lastMoveId?: boolean
  }

  export type LiteratureGameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "status" | "playerCount" | "currentTurn" | "lastMoveId", ExtArgs["result"]["literatureGame"]>
  export type LiteratureGameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | LiteratureGame$playersArgs<ExtArgs>
    teams?: boolean | LiteratureGame$teamsArgs<ExtArgs>
    cardMappings?: boolean | LiteratureGame$cardMappingsArgs<ExtArgs>
    cardLocations?: boolean | LiteratureGame$cardLocationsArgs<ExtArgs>
    asks?: boolean | LiteratureGame$asksArgs<ExtArgs>
    calls?: boolean | LiteratureGame$callsArgs<ExtArgs>
    transfers?: boolean | LiteratureGame$transfersArgs<ExtArgs>
    _count?: boolean | LiteratureGameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiteratureGameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LiteratureGameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LiteratureGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiteratureGame"
    objects: {
      players: Prisma.$LiteraturePlayerPayload<ExtArgs>[]
      teams: Prisma.$LiteratureTeamPayload<ExtArgs>[]
      cardMappings: Prisma.$LiteratureCardMappingPayload<ExtArgs>[]
      cardLocations: Prisma.$LiteratureCardLocationPayload<ExtArgs>[]
      asks: Prisma.$LiteratureAskPayload<ExtArgs>[]
      calls: Prisma.$LiteratureCallPayload<ExtArgs>[]
      transfers: Prisma.$LiteratureTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      status: $Enums.LiteratureGameStatus
      playerCount: number
      currentTurn: string
      lastMoveId: string
    }, ExtArgs["result"]["literatureGame"]>
    composites: {}
  }

  type LiteratureGameGetPayload<S extends boolean | null | undefined | LiteratureGameDefaultArgs> = $Result.GetResult<Prisma.$LiteratureGamePayload, S>

  type LiteratureGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiteratureGameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiteratureGameCountAggregateInputType | true
    }

  export interface LiteratureGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiteratureGame'], meta: { name: 'LiteratureGame' } }
    /**
     * Find zero or one LiteratureGame that matches the filter.
     * @param {LiteratureGameFindUniqueArgs} args - Arguments to find a LiteratureGame
     * @example
     * // Get one LiteratureGame
     * const literatureGame = await prisma.literatureGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiteratureGameFindUniqueArgs>(args: SelectSubset<T, LiteratureGameFindUniqueArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LiteratureGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiteratureGameFindUniqueOrThrowArgs} args - Arguments to find a LiteratureGame
     * @example
     * // Get one LiteratureGame
     * const literatureGame = await prisma.literatureGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiteratureGameFindUniqueOrThrowArgs>(args: SelectSubset<T, LiteratureGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameFindFirstArgs} args - Arguments to find a LiteratureGame
     * @example
     * // Get one LiteratureGame
     * const literatureGame = await prisma.literatureGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiteratureGameFindFirstArgs>(args?: SelectSubset<T, LiteratureGameFindFirstArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LiteratureGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameFindFirstOrThrowArgs} args - Arguments to find a LiteratureGame
     * @example
     * // Get one LiteratureGame
     * const literatureGame = await prisma.literatureGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiteratureGameFindFirstOrThrowArgs>(args?: SelectSubset<T, LiteratureGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LiteratureGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiteratureGames
     * const literatureGames = await prisma.literatureGame.findMany()
     * 
     * // Get first 10 LiteratureGames
     * const literatureGames = await prisma.literatureGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const literatureGameWithIdOnly = await prisma.literatureGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiteratureGameFindManyArgs>(args?: SelectSubset<T, LiteratureGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LiteratureGame.
     * @param {LiteratureGameCreateArgs} args - Arguments to create a LiteratureGame.
     * @example
     * // Create one LiteratureGame
     * const LiteratureGame = await prisma.literatureGame.create({
     *   data: {
     *     // ... data to create a LiteratureGame
     *   }
     * })
     * 
     */
    create<T extends LiteratureGameCreateArgs>(args: SelectSubset<T, LiteratureGameCreateArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LiteratureGames.
     * @param {LiteratureGameCreateManyArgs} args - Arguments to create many LiteratureGames.
     * @example
     * // Create many LiteratureGames
     * const literatureGame = await prisma.literatureGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiteratureGameCreateManyArgs>(args?: SelectSubset<T, LiteratureGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiteratureGames and returns the data saved in the database.
     * @param {LiteratureGameCreateManyAndReturnArgs} args - Arguments to create many LiteratureGames.
     * @example
     * // Create many LiteratureGames
     * const literatureGame = await prisma.literatureGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiteratureGames and only return the `id`
     * const literatureGameWithIdOnly = await prisma.literatureGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiteratureGameCreateManyAndReturnArgs>(args?: SelectSubset<T, LiteratureGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LiteratureGame.
     * @param {LiteratureGameDeleteArgs} args - Arguments to delete one LiteratureGame.
     * @example
     * // Delete one LiteratureGame
     * const LiteratureGame = await prisma.literatureGame.delete({
     *   where: {
     *     // ... filter to delete one LiteratureGame
     *   }
     * })
     * 
     */
    delete<T extends LiteratureGameDeleteArgs>(args: SelectSubset<T, LiteratureGameDeleteArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LiteratureGame.
     * @param {LiteratureGameUpdateArgs} args - Arguments to update one LiteratureGame.
     * @example
     * // Update one LiteratureGame
     * const literatureGame = await prisma.literatureGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiteratureGameUpdateArgs>(args: SelectSubset<T, LiteratureGameUpdateArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LiteratureGames.
     * @param {LiteratureGameDeleteManyArgs} args - Arguments to filter LiteratureGames to delete.
     * @example
     * // Delete a few LiteratureGames
     * const { count } = await prisma.literatureGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiteratureGameDeleteManyArgs>(args?: SelectSubset<T, LiteratureGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiteratureGames
     * const literatureGame = await prisma.literatureGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiteratureGameUpdateManyArgs>(args: SelectSubset<T, LiteratureGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiteratureGames and returns the data updated in the database.
     * @param {LiteratureGameUpdateManyAndReturnArgs} args - Arguments to update many LiteratureGames.
     * @example
     * // Update many LiteratureGames
     * const literatureGame = await prisma.literatureGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiteratureGames and only return the `id`
     * const literatureGameWithIdOnly = await prisma.literatureGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiteratureGameUpdateManyAndReturnArgs>(args: SelectSubset<T, LiteratureGameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LiteratureGame.
     * @param {LiteratureGameUpsertArgs} args - Arguments to update or create a LiteratureGame.
     * @example
     * // Update or create a LiteratureGame
     * const literatureGame = await prisma.literatureGame.upsert({
     *   create: {
     *     // ... data to create a LiteratureGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiteratureGame we want to update
     *   }
     * })
     */
    upsert<T extends LiteratureGameUpsertArgs>(args: SelectSubset<T, LiteratureGameUpsertArgs<ExtArgs>>): Prisma__LiteratureGameClient<$Result.GetResult<Prisma.$LiteratureGamePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LiteratureGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameCountArgs} args - Arguments to filter LiteratureGames to count.
     * @example
     * // Count the number of LiteratureGames
     * const count = await prisma.literatureGame.count({
     *   where: {
     *     // ... the filter for the LiteratureGames we want to count
     *   }
     * })
    **/
    count<T extends LiteratureGameCountArgs>(
      args?: Subset<T, LiteratureGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiteratureGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiteratureGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiteratureGameAggregateArgs>(args: Subset<T, LiteratureGameAggregateArgs>): Prisma.PrismaPromise<GetLiteratureGameAggregateType<T>>

    /**
     * Group by LiteratureGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiteratureGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiteratureGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiteratureGameGroupByArgs['orderBy'] }
        : { orderBy?: LiteratureGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiteratureGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiteratureGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiteratureGame model
   */
  readonly fields: LiteratureGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiteratureGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiteratureGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends LiteratureGame$playersArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteraturePlayerPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teams<T extends LiteratureGame$teamsArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTeamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cardMappings<T extends LiteratureGame$cardMappingsArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$cardMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardMappingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cardLocations<T extends LiteratureGame$cardLocationsArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$cardLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCardLocationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    asks<T extends LiteratureGame$asksArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$asksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureAskPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    calls<T extends LiteratureGame$callsArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureCallPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    transfers<T extends LiteratureGame$transfersArgs<ExtArgs> = {}>(args?: Subset<T, LiteratureGame$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiteratureTransferPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiteratureGame model
   */ 
  interface LiteratureGameFieldRefs {
    readonly id: FieldRef<"LiteratureGame", 'String'>
    readonly code: FieldRef<"LiteratureGame", 'String'>
    readonly status: FieldRef<"LiteratureGame", 'LiteratureGameStatus'>
    readonly playerCount: FieldRef<"LiteratureGame", 'Int'>
    readonly currentTurn: FieldRef<"LiteratureGame", 'String'>
    readonly lastMoveId: FieldRef<"LiteratureGame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiteratureGame findUnique
   */
  export type LiteratureGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureGame to fetch.
     */
    where: LiteratureGameWhereUniqueInput
  }

  /**
   * LiteratureGame findUniqueOrThrow
   */
  export type LiteratureGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureGame to fetch.
     */
    where: LiteratureGameWhereUniqueInput
  }

  /**
   * LiteratureGame findFirst
   */
  export type LiteratureGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureGame to fetch.
     */
    where?: LiteratureGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureGames to fetch.
     */
    orderBy?: LiteratureGameOrderByWithRelationInput | LiteratureGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureGames.
     */
    cursor?: LiteratureGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureGames.
     */
    distinct?: LiteratureGameScalarFieldEnum | LiteratureGameScalarFieldEnum[]
  }

  /**
   * LiteratureGame findFirstOrThrow
   */
  export type LiteratureGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureGame to fetch.
     */
    where?: LiteratureGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureGames to fetch.
     */
    orderBy?: LiteratureGameOrderByWithRelationInput | LiteratureGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiteratureGames.
     */
    cursor?: LiteratureGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiteratureGames.
     */
    distinct?: LiteratureGameScalarFieldEnum | LiteratureGameScalarFieldEnum[]
  }

  /**
   * LiteratureGame findMany
   */
  export type LiteratureGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter, which LiteratureGames to fetch.
     */
    where?: LiteratureGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiteratureGames to fetch.
     */
    orderBy?: LiteratureGameOrderByWithRelationInput | LiteratureGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiteratureGames.
     */
    cursor?: LiteratureGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiteratureGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiteratureGames.
     */
    skip?: number
    distinct?: LiteratureGameScalarFieldEnum | LiteratureGameScalarFieldEnum[]
  }

  /**
   * LiteratureGame create
   */
  export type LiteratureGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * The data needed to create a LiteratureGame.
     */
    data: XOR<LiteratureGameCreateInput, LiteratureGameUncheckedCreateInput>
  }

  /**
   * LiteratureGame createMany
   */
  export type LiteratureGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiteratureGames.
     */
    data: LiteratureGameCreateManyInput | LiteratureGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureGame createManyAndReturn
   */
  export type LiteratureGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * The data used to create many LiteratureGames.
     */
    data: LiteratureGameCreateManyInput | LiteratureGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiteratureGame update
   */
  export type LiteratureGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * The data needed to update a LiteratureGame.
     */
    data: XOR<LiteratureGameUpdateInput, LiteratureGameUncheckedUpdateInput>
    /**
     * Choose, which LiteratureGame to update.
     */
    where: LiteratureGameWhereUniqueInput
  }

  /**
   * LiteratureGame updateMany
   */
  export type LiteratureGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiteratureGames.
     */
    data: XOR<LiteratureGameUpdateManyMutationInput, LiteratureGameUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureGames to update
     */
    where?: LiteratureGameWhereInput
    /**
     * Limit how many LiteratureGames to update.
     */
    limit?: number
  }

  /**
   * LiteratureGame updateManyAndReturn
   */
  export type LiteratureGameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * The data used to update LiteratureGames.
     */
    data: XOR<LiteratureGameUpdateManyMutationInput, LiteratureGameUncheckedUpdateManyInput>
    /**
     * Filter which LiteratureGames to update
     */
    where?: LiteratureGameWhereInput
    /**
     * Limit how many LiteratureGames to update.
     */
    limit?: number
  }

  /**
   * LiteratureGame upsert
   */
  export type LiteratureGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * The filter to search for the LiteratureGame to update in case it exists.
     */
    where: LiteratureGameWhereUniqueInput
    /**
     * In case the LiteratureGame found by the `where` argument doesn't exist, create a new LiteratureGame with this data.
     */
    create: XOR<LiteratureGameCreateInput, LiteratureGameUncheckedCreateInput>
    /**
     * In case the LiteratureGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiteratureGameUpdateInput, LiteratureGameUncheckedUpdateInput>
  }

  /**
   * LiteratureGame delete
   */
  export type LiteratureGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
    /**
     * Filter which LiteratureGame to delete.
     */
    where: LiteratureGameWhereUniqueInput
  }

  /**
   * LiteratureGame deleteMany
   */
  export type LiteratureGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiteratureGames to delete
     */
    where?: LiteratureGameWhereInput
    /**
     * Limit how many LiteratureGames to delete.
     */
    limit?: number
  }

  /**
   * LiteratureGame.players
   */
  export type LiteratureGame$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteraturePlayer
     */
    select?: LiteraturePlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteraturePlayer
     */
    omit?: LiteraturePlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteraturePlayerInclude<ExtArgs> | null
    where?: LiteraturePlayerWhereInput
    orderBy?: LiteraturePlayerOrderByWithRelationInput | LiteraturePlayerOrderByWithRelationInput[]
    cursor?: LiteraturePlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteraturePlayerScalarFieldEnum | LiteraturePlayerScalarFieldEnum[]
  }

  /**
   * LiteratureGame.teams
   */
  export type LiteratureGame$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTeam
     */
    select?: LiteratureTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTeam
     */
    omit?: LiteratureTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTeamInclude<ExtArgs> | null
    where?: LiteratureTeamWhereInput
    orderBy?: LiteratureTeamOrderByWithRelationInput | LiteratureTeamOrderByWithRelationInput[]
    cursor?: LiteratureTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureTeamScalarFieldEnum | LiteratureTeamScalarFieldEnum[]
  }

  /**
   * LiteratureGame.cardMappings
   */
  export type LiteratureGame$cardMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardMapping
     */
    select?: LiteratureCardMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardMapping
     */
    omit?: LiteratureCardMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardMappingInclude<ExtArgs> | null
    where?: LiteratureCardMappingWhereInput
    orderBy?: LiteratureCardMappingOrderByWithRelationInput | LiteratureCardMappingOrderByWithRelationInput[]
    cursor?: LiteratureCardMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCardMappingScalarFieldEnum | LiteratureCardMappingScalarFieldEnum[]
  }

  /**
   * LiteratureGame.cardLocations
   */
  export type LiteratureGame$cardLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCardLocation
     */
    select?: LiteratureCardLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCardLocation
     */
    omit?: LiteratureCardLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCardLocationInclude<ExtArgs> | null
    where?: LiteratureCardLocationWhereInput
    orderBy?: LiteratureCardLocationOrderByWithRelationInput | LiteratureCardLocationOrderByWithRelationInput[]
    cursor?: LiteratureCardLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCardLocationScalarFieldEnum | LiteratureCardLocationScalarFieldEnum[]
  }

  /**
   * LiteratureGame.asks
   */
  export type LiteratureGame$asksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureAsk
     */
    select?: LiteratureAskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureAsk
     */
    omit?: LiteratureAskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureAskInclude<ExtArgs> | null
    where?: LiteratureAskWhereInput
    orderBy?: LiteratureAskOrderByWithRelationInput | LiteratureAskOrderByWithRelationInput[]
    cursor?: LiteratureAskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureAskScalarFieldEnum | LiteratureAskScalarFieldEnum[]
  }

  /**
   * LiteratureGame.calls
   */
  export type LiteratureGame$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureCall
     */
    select?: LiteratureCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureCall
     */
    omit?: LiteratureCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureCallInclude<ExtArgs> | null
    where?: LiteratureCallWhereInput
    orderBy?: LiteratureCallOrderByWithRelationInput | LiteratureCallOrderByWithRelationInput[]
    cursor?: LiteratureCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureCallScalarFieldEnum | LiteratureCallScalarFieldEnum[]
  }

  /**
   * LiteratureGame.transfers
   */
  export type LiteratureGame$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureTransfer
     */
    select?: LiteratureTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureTransfer
     */
    omit?: LiteratureTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureTransferInclude<ExtArgs> | null
    where?: LiteratureTransferWhereInput
    orderBy?: LiteratureTransferOrderByWithRelationInput | LiteratureTransferOrderByWithRelationInput[]
    cursor?: LiteratureTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiteratureTransferScalarFieldEnum | LiteratureTransferScalarFieldEnum[]
  }

  /**
   * LiteratureGame without action
   */
  export type LiteratureGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiteratureGame
     */
    select?: LiteratureGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiteratureGame
     */
    omit?: LiteratureGameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiteratureGameInclude<ExtArgs> | null
  }


  /**
   * Model WordleGame
   */

  export type AggregateWordleGame = {
    _count: WordleGameCountAggregateOutputType | null
    _avg: WordleGameAvgAggregateOutputType | null
    _sum: WordleGameSumAggregateOutputType | null
    _min: WordleGameMinAggregateOutputType | null
    _max: WordleGameMaxAggregateOutputType | null
  }

  export type WordleGameAvgAggregateOutputType = {
    wordLength: number | null
    wordCount: number | null
  }

  export type WordleGameSumAggregateOutputType = {
    wordLength: number | null
    wordCount: number | null
  }

  export type WordleGameMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    wordLength: number | null
    wordCount: number | null
  }

  export type WordleGameMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    wordLength: number | null
    wordCount: number | null
  }

  export type WordleGameCountAggregateOutputType = {
    id: number
    playerId: number
    wordLength: number
    wordCount: number
    words: number
    guesses: number
    completedWords: number
    _all: number
  }


  export type WordleGameAvgAggregateInputType = {
    wordLength?: true
    wordCount?: true
  }

  export type WordleGameSumAggregateInputType = {
    wordLength?: true
    wordCount?: true
  }

  export type WordleGameMinAggregateInputType = {
    id?: true
    playerId?: true
    wordLength?: true
    wordCount?: true
  }

  export type WordleGameMaxAggregateInputType = {
    id?: true
    playerId?: true
    wordLength?: true
    wordCount?: true
  }

  export type WordleGameCountAggregateInputType = {
    id?: true
    playerId?: true
    wordLength?: true
    wordCount?: true
    words?: true
    guesses?: true
    completedWords?: true
    _all?: true
  }

  export type WordleGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordleGame to aggregate.
     */
    where?: WordleGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordleGames to fetch.
     */
    orderBy?: WordleGameOrderByWithRelationInput | WordleGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordleGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordleGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordleGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WordleGames
    **/
    _count?: true | WordleGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WordleGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WordleGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordleGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordleGameMaxAggregateInputType
  }

  export type GetWordleGameAggregateType<T extends WordleGameAggregateArgs> = {
        [P in keyof T & keyof AggregateWordleGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWordleGame[P]>
      : GetScalarType<T[P], AggregateWordleGame[P]>
  }




  export type WordleGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordleGameWhereInput
    orderBy?: WordleGameOrderByWithAggregationInput | WordleGameOrderByWithAggregationInput[]
    by: WordleGameScalarFieldEnum[] | WordleGameScalarFieldEnum
    having?: WordleGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordleGameCountAggregateInputType | true
    _avg?: WordleGameAvgAggregateInputType
    _sum?: WordleGameSumAggregateInputType
    _min?: WordleGameMinAggregateInputType
    _max?: WordleGameMaxAggregateInputType
  }

  export type WordleGameGroupByOutputType = {
    id: string
    playerId: string
    wordLength: number
    wordCount: number
    words: string[]
    guesses: string[]
    completedWords: string[]
    _count: WordleGameCountAggregateOutputType | null
    _avg: WordleGameAvgAggregateOutputType | null
    _sum: WordleGameSumAggregateOutputType | null
    _min: WordleGameMinAggregateOutputType | null
    _max: WordleGameMaxAggregateOutputType | null
  }

  type GetWordleGameGroupByPayload<T extends WordleGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WordleGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordleGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordleGameGroupByOutputType[P]>
            : GetScalarType<T[P], WordleGameGroupByOutputType[P]>
        }
      >
    >


  export type WordleGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    wordLength?: boolean
    wordCount?: boolean
    words?: boolean
    guesses?: boolean
    completedWords?: boolean
  }, ExtArgs["result"]["wordleGame"]>

  export type WordleGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    wordLength?: boolean
    wordCount?: boolean
    words?: boolean
    guesses?: boolean
    completedWords?: boolean
  }, ExtArgs["result"]["wordleGame"]>

  export type WordleGameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    wordLength?: boolean
    wordCount?: boolean
    words?: boolean
    guesses?: boolean
    completedWords?: boolean
  }, ExtArgs["result"]["wordleGame"]>

  export type WordleGameSelectScalar = {
    id?: boolean
    playerId?: boolean
    wordLength?: boolean
    wordCount?: boolean
    words?: boolean
    guesses?: boolean
    completedWords?: boolean
  }

  export type WordleGameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "wordLength" | "wordCount" | "words" | "guesses" | "completedWords", ExtArgs["result"]["wordleGame"]>

  export type $WordleGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WordleGame"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      wordLength: number
      wordCount: number
      words: string[]
      guesses: string[]
      completedWords: string[]
    }, ExtArgs["result"]["wordleGame"]>
    composites: {}
  }

  type WordleGameGetPayload<S extends boolean | null | undefined | WordleGameDefaultArgs> = $Result.GetResult<Prisma.$WordleGamePayload, S>

  type WordleGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WordleGameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WordleGameCountAggregateInputType | true
    }

  export interface WordleGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WordleGame'], meta: { name: 'WordleGame' } }
    /**
     * Find zero or one WordleGame that matches the filter.
     * @param {WordleGameFindUniqueArgs} args - Arguments to find a WordleGame
     * @example
     * // Get one WordleGame
     * const wordleGame = await prisma.wordleGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WordleGameFindUniqueArgs>(args: SelectSubset<T, WordleGameFindUniqueArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WordleGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WordleGameFindUniqueOrThrowArgs} args - Arguments to find a WordleGame
     * @example
     * // Get one WordleGame
     * const wordleGame = await prisma.wordleGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WordleGameFindUniqueOrThrowArgs>(args: SelectSubset<T, WordleGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WordleGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameFindFirstArgs} args - Arguments to find a WordleGame
     * @example
     * // Get one WordleGame
     * const wordleGame = await prisma.wordleGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WordleGameFindFirstArgs>(args?: SelectSubset<T, WordleGameFindFirstArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WordleGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameFindFirstOrThrowArgs} args - Arguments to find a WordleGame
     * @example
     * // Get one WordleGame
     * const wordleGame = await prisma.wordleGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WordleGameFindFirstOrThrowArgs>(args?: SelectSubset<T, WordleGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WordleGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WordleGames
     * const wordleGames = await prisma.wordleGame.findMany()
     * 
     * // Get first 10 WordleGames
     * const wordleGames = await prisma.wordleGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wordleGameWithIdOnly = await prisma.wordleGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WordleGameFindManyArgs>(args?: SelectSubset<T, WordleGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WordleGame.
     * @param {WordleGameCreateArgs} args - Arguments to create a WordleGame.
     * @example
     * // Create one WordleGame
     * const WordleGame = await prisma.wordleGame.create({
     *   data: {
     *     // ... data to create a WordleGame
     *   }
     * })
     * 
     */
    create<T extends WordleGameCreateArgs>(args: SelectSubset<T, WordleGameCreateArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WordleGames.
     * @param {WordleGameCreateManyArgs} args - Arguments to create many WordleGames.
     * @example
     * // Create many WordleGames
     * const wordleGame = await prisma.wordleGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WordleGameCreateManyArgs>(args?: SelectSubset<T, WordleGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WordleGames and returns the data saved in the database.
     * @param {WordleGameCreateManyAndReturnArgs} args - Arguments to create many WordleGames.
     * @example
     * // Create many WordleGames
     * const wordleGame = await prisma.wordleGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WordleGames and only return the `id`
     * const wordleGameWithIdOnly = await prisma.wordleGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WordleGameCreateManyAndReturnArgs>(args?: SelectSubset<T, WordleGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WordleGame.
     * @param {WordleGameDeleteArgs} args - Arguments to delete one WordleGame.
     * @example
     * // Delete one WordleGame
     * const WordleGame = await prisma.wordleGame.delete({
     *   where: {
     *     // ... filter to delete one WordleGame
     *   }
     * })
     * 
     */
    delete<T extends WordleGameDeleteArgs>(args: SelectSubset<T, WordleGameDeleteArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WordleGame.
     * @param {WordleGameUpdateArgs} args - Arguments to update one WordleGame.
     * @example
     * // Update one WordleGame
     * const wordleGame = await prisma.wordleGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WordleGameUpdateArgs>(args: SelectSubset<T, WordleGameUpdateArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WordleGames.
     * @param {WordleGameDeleteManyArgs} args - Arguments to filter WordleGames to delete.
     * @example
     * // Delete a few WordleGames
     * const { count } = await prisma.wordleGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WordleGameDeleteManyArgs>(args?: SelectSubset<T, WordleGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordleGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WordleGames
     * const wordleGame = await prisma.wordleGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WordleGameUpdateManyArgs>(args: SelectSubset<T, WordleGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordleGames and returns the data updated in the database.
     * @param {WordleGameUpdateManyAndReturnArgs} args - Arguments to update many WordleGames.
     * @example
     * // Update many WordleGames
     * const wordleGame = await prisma.wordleGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WordleGames and only return the `id`
     * const wordleGameWithIdOnly = await prisma.wordleGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WordleGameUpdateManyAndReturnArgs>(args: SelectSubset<T, WordleGameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WordleGame.
     * @param {WordleGameUpsertArgs} args - Arguments to update or create a WordleGame.
     * @example
     * // Update or create a WordleGame
     * const wordleGame = await prisma.wordleGame.upsert({
     *   create: {
     *     // ... data to create a WordleGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WordleGame we want to update
     *   }
     * })
     */
    upsert<T extends WordleGameUpsertArgs>(args: SelectSubset<T, WordleGameUpsertArgs<ExtArgs>>): Prisma__WordleGameClient<$Result.GetResult<Prisma.$WordleGamePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WordleGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameCountArgs} args - Arguments to filter WordleGames to count.
     * @example
     * // Count the number of WordleGames
     * const count = await prisma.wordleGame.count({
     *   where: {
     *     // ... the filter for the WordleGames we want to count
     *   }
     * })
    **/
    count<T extends WordleGameCountArgs>(
      args?: Subset<T, WordleGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordleGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WordleGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordleGameAggregateArgs>(args: Subset<T, WordleGameAggregateArgs>): Prisma.PrismaPromise<GetWordleGameAggregateType<T>>

    /**
     * Group by WordleGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordleGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordleGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordleGameGroupByArgs['orderBy'] }
        : { orderBy?: WordleGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordleGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordleGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WordleGame model
   */
  readonly fields: WordleGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WordleGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WordleGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WordleGame model
   */ 
  interface WordleGameFieldRefs {
    readonly id: FieldRef<"WordleGame", 'String'>
    readonly playerId: FieldRef<"WordleGame", 'String'>
    readonly wordLength: FieldRef<"WordleGame", 'Int'>
    readonly wordCount: FieldRef<"WordleGame", 'Int'>
    readonly words: FieldRef<"WordleGame", 'String[]'>
    readonly guesses: FieldRef<"WordleGame", 'String[]'>
    readonly completedWords: FieldRef<"WordleGame", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * WordleGame findUnique
   */
  export type WordleGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter, which WordleGame to fetch.
     */
    where: WordleGameWhereUniqueInput
  }

  /**
   * WordleGame findUniqueOrThrow
   */
  export type WordleGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter, which WordleGame to fetch.
     */
    where: WordleGameWhereUniqueInput
  }

  /**
   * WordleGame findFirst
   */
  export type WordleGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter, which WordleGame to fetch.
     */
    where?: WordleGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordleGames to fetch.
     */
    orderBy?: WordleGameOrderByWithRelationInput | WordleGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordleGames.
     */
    cursor?: WordleGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordleGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordleGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordleGames.
     */
    distinct?: WordleGameScalarFieldEnum | WordleGameScalarFieldEnum[]
  }

  /**
   * WordleGame findFirstOrThrow
   */
  export type WordleGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter, which WordleGame to fetch.
     */
    where?: WordleGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordleGames to fetch.
     */
    orderBy?: WordleGameOrderByWithRelationInput | WordleGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordleGames.
     */
    cursor?: WordleGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordleGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordleGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordleGames.
     */
    distinct?: WordleGameScalarFieldEnum | WordleGameScalarFieldEnum[]
  }

  /**
   * WordleGame findMany
   */
  export type WordleGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter, which WordleGames to fetch.
     */
    where?: WordleGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordleGames to fetch.
     */
    orderBy?: WordleGameOrderByWithRelationInput | WordleGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WordleGames.
     */
    cursor?: WordleGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordleGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordleGames.
     */
    skip?: number
    distinct?: WordleGameScalarFieldEnum | WordleGameScalarFieldEnum[]
  }

  /**
   * WordleGame create
   */
  export type WordleGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * The data needed to create a WordleGame.
     */
    data: XOR<WordleGameCreateInput, WordleGameUncheckedCreateInput>
  }

  /**
   * WordleGame createMany
   */
  export type WordleGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WordleGames.
     */
    data: WordleGameCreateManyInput | WordleGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WordleGame createManyAndReturn
   */
  export type WordleGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * The data used to create many WordleGames.
     */
    data: WordleGameCreateManyInput | WordleGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WordleGame update
   */
  export type WordleGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * The data needed to update a WordleGame.
     */
    data: XOR<WordleGameUpdateInput, WordleGameUncheckedUpdateInput>
    /**
     * Choose, which WordleGame to update.
     */
    where: WordleGameWhereUniqueInput
  }

  /**
   * WordleGame updateMany
   */
  export type WordleGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WordleGames.
     */
    data: XOR<WordleGameUpdateManyMutationInput, WordleGameUncheckedUpdateManyInput>
    /**
     * Filter which WordleGames to update
     */
    where?: WordleGameWhereInput
    /**
     * Limit how many WordleGames to update.
     */
    limit?: number
  }

  /**
   * WordleGame updateManyAndReturn
   */
  export type WordleGameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * The data used to update WordleGames.
     */
    data: XOR<WordleGameUpdateManyMutationInput, WordleGameUncheckedUpdateManyInput>
    /**
     * Filter which WordleGames to update
     */
    where?: WordleGameWhereInput
    /**
     * Limit how many WordleGames to update.
     */
    limit?: number
  }

  /**
   * WordleGame upsert
   */
  export type WordleGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * The filter to search for the WordleGame to update in case it exists.
     */
    where: WordleGameWhereUniqueInput
    /**
     * In case the WordleGame found by the `where` argument doesn't exist, create a new WordleGame with this data.
     */
    create: XOR<WordleGameCreateInput, WordleGameUncheckedCreateInput>
    /**
     * In case the WordleGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordleGameUpdateInput, WordleGameUncheckedUpdateInput>
  }

  /**
   * WordleGame delete
   */
  export type WordleGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
    /**
     * Filter which WordleGame to delete.
     */
    where: WordleGameWhereUniqueInput
  }

  /**
   * WordleGame deleteMany
   */
  export type WordleGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordleGames to delete
     */
    where?: WordleGameWhereInput
    /**
     * Limit how many WordleGames to delete.
     */
    limit?: number
  }

  /**
   * WordleGame without action
   */
  export type WordleGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordleGame
     */
    select?: WordleGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WordleGame
     */
    omit?: WordleGameOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerId: 'providerId',
    accountId: 'accountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    idToken: 'idToken',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const CallBreakGameScalarFieldEnum: {
    id: 'id',
    code: 'code',
    dealCount: 'dealCount',
    trumpSuit: 'trumpSuit',
    status: 'status',
    createdBy: 'createdBy',
    scores: 'scores'
  };

  export type CallBreakGameScalarFieldEnum = (typeof CallBreakGameScalarFieldEnum)[keyof typeof CallBreakGameScalarFieldEnum]


  export const CallBreakPlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    avatar: 'avatar',
    gameId: 'gameId',
    isBot: 'isBot'
  };

  export type CallBreakPlayerScalarFieldEnum = (typeof CallBreakPlayerScalarFieldEnum)[keyof typeof CallBreakPlayerScalarFieldEnum]


  export const CallBreakDealScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    playerOrder: 'playerOrder',
    declarations: 'declarations',
    wins: 'wins',
    turnIdx: 'turnIdx',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type CallBreakDealScalarFieldEnum = (typeof CallBreakDealScalarFieldEnum)[keyof typeof CallBreakDealScalarFieldEnum]


  export const CallBreakCardMappingScalarFieldEnum: {
    cardId: 'cardId',
    dealId: 'dealId',
    gameId: 'gameId',
    playerId: 'playerId'
  };

  export type CallBreakCardMappingScalarFieldEnum = (typeof CallBreakCardMappingScalarFieldEnum)[keyof typeof CallBreakCardMappingScalarFieldEnum]


  export const CallBreakRoundScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    dealId: 'dealId',
    winner: 'winner',
    playerOrder: 'playerOrder',
    cards: 'cards',
    turnIdx: 'turnIdx',
    suit: 'suit',
    completed: 'completed',
    createdAt: 'createdAt'
  };

  export type CallBreakRoundScalarFieldEnum = (typeof CallBreakRoundScalarFieldEnum)[keyof typeof CallBreakRoundScalarFieldEnum]


  export const LiteraturePlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    avatar: 'avatar',
    gameId: 'gameId',
    teamId: 'teamId',
    isBot: 'isBot'
  };

  export type LiteraturePlayerScalarFieldEnum = (typeof LiteraturePlayerScalarFieldEnum)[keyof typeof LiteraturePlayerScalarFieldEnum]


  export const LiteratureTeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    score: 'score',
    setsWon: 'setsWon',
    memberIds: 'memberIds',
    gameId: 'gameId'
  };

  export type LiteratureTeamScalarFieldEnum = (typeof LiteratureTeamScalarFieldEnum)[keyof typeof LiteratureTeamScalarFieldEnum]


  export const LiteratureCardMappingScalarFieldEnum: {
    cardId: 'cardId',
    gameId: 'gameId',
    playerId: 'playerId'
  };

  export type LiteratureCardMappingScalarFieldEnum = (typeof LiteratureCardMappingScalarFieldEnum)[keyof typeof LiteratureCardMappingScalarFieldEnum]


  export const LiteratureCardLocationScalarFieldEnum: {
    cardId: 'cardId',
    gameId: 'gameId',
    playerId: 'playerId',
    playerIds: 'playerIds',
    weight: 'weight'
  };

  export type LiteratureCardLocationScalarFieldEnum = (typeof LiteratureCardLocationScalarFieldEnum)[keyof typeof LiteratureCardLocationScalarFieldEnum]


  export const LiteratureAskScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    playerId: 'playerId',
    timestamp: 'timestamp',
    description: 'description',
    success: 'success',
    cardId: 'cardId',
    askedFrom: 'askedFrom'
  };

  export type LiteratureAskScalarFieldEnum = (typeof LiteratureAskScalarFieldEnum)[keyof typeof LiteratureAskScalarFieldEnum]


  export const LiteratureCallScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    playerId: 'playerId',
    timestamp: 'timestamp',
    description: 'description',
    success: 'success',
    cardSet: 'cardSet',
    actualCall: 'actualCall',
    correctCall: 'correctCall'
  };

  export type LiteratureCallScalarFieldEnum = (typeof LiteratureCallScalarFieldEnum)[keyof typeof LiteratureCallScalarFieldEnum]


  export const LiteratureTransferScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    playerId: 'playerId',
    timestamp: 'timestamp',
    description: 'description',
    success: 'success',
    transferTo: 'transferTo'
  };

  export type LiteratureTransferScalarFieldEnum = (typeof LiteratureTransferScalarFieldEnum)[keyof typeof LiteratureTransferScalarFieldEnum]


  export const LiteratureGameScalarFieldEnum: {
    id: 'id',
    code: 'code',
    status: 'status',
    playerCount: 'playerCount',
    currentTurn: 'currentTurn',
    lastMoveId: 'lastMoveId'
  };

  export type LiteratureGameScalarFieldEnum = (typeof LiteratureGameScalarFieldEnum)[keyof typeof LiteratureGameScalarFieldEnum]


  export const WordleGameScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    wordLength: 'wordLength',
    wordCount: 'wordCount',
    words: 'words',
    guesses: 'guesses',
    completedWords: 'completedWords'
  };

  export type WordleGameScalarFieldEnum = (typeof WordleGameScalarFieldEnum)[keyof typeof WordleGameScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CallBreakStatus'
   */
  export type EnumCallBreakStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallBreakStatus'>
    


  /**
   * Reference to a field of type 'CallBreakStatus[]'
   */
  export type ListEnumCallBreakStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallBreakStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'LiteratureGameStatus'
   */
  export type EnumLiteratureGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiteratureGameStatus'>
    


  /**
   * Reference to a field of type 'LiteratureGameStatus[]'
   */
  export type ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiteratureGameStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    accountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    accountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type CallBreakGameWhereInput = {
    AND?: CallBreakGameWhereInput | CallBreakGameWhereInput[]
    OR?: CallBreakGameWhereInput[]
    NOT?: CallBreakGameWhereInput | CallBreakGameWhereInput[]
    id?: StringFilter<"CallBreakGame"> | string
    code?: StringFilter<"CallBreakGame"> | string
    dealCount?: IntFilter<"CallBreakGame"> | number
    trumpSuit?: StringFilter<"CallBreakGame"> | string
    status?: EnumCallBreakStatusFilter<"CallBreakGame"> | $Enums.CallBreakStatus
    createdBy?: StringFilter<"CallBreakGame"> | string
    scores?: JsonFilter<"CallBreakGame">
    players?: CallBreakPlayerListRelationFilter
    deals?: CallBreakDealListRelationFilter
    cardMappings?: CallBreakCardMappingListRelationFilter
    rounds?: CallBreakRoundListRelationFilter
  }

  export type CallBreakGameOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    dealCount?: SortOrder
    trumpSuit?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    scores?: SortOrder
    players?: CallBreakPlayerOrderByRelationAggregateInput
    deals?: CallBreakDealOrderByRelationAggregateInput
    cardMappings?: CallBreakCardMappingOrderByRelationAggregateInput
    rounds?: CallBreakRoundOrderByRelationAggregateInput
  }

  export type CallBreakGameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CallBreakGameWhereInput | CallBreakGameWhereInput[]
    OR?: CallBreakGameWhereInput[]
    NOT?: CallBreakGameWhereInput | CallBreakGameWhereInput[]
    dealCount?: IntFilter<"CallBreakGame"> | number
    trumpSuit?: StringFilter<"CallBreakGame"> | string
    status?: EnumCallBreakStatusFilter<"CallBreakGame"> | $Enums.CallBreakStatus
    createdBy?: StringFilter<"CallBreakGame"> | string
    scores?: JsonFilter<"CallBreakGame">
    players?: CallBreakPlayerListRelationFilter
    deals?: CallBreakDealListRelationFilter
    cardMappings?: CallBreakCardMappingListRelationFilter
    rounds?: CallBreakRoundListRelationFilter
  }, "id" | "code">

  export type CallBreakGameOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    dealCount?: SortOrder
    trumpSuit?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    scores?: SortOrder
    _count?: CallBreakGameCountOrderByAggregateInput
    _avg?: CallBreakGameAvgOrderByAggregateInput
    _max?: CallBreakGameMaxOrderByAggregateInput
    _min?: CallBreakGameMinOrderByAggregateInput
    _sum?: CallBreakGameSumOrderByAggregateInput
  }

  export type CallBreakGameScalarWhereWithAggregatesInput = {
    AND?: CallBreakGameScalarWhereWithAggregatesInput | CallBreakGameScalarWhereWithAggregatesInput[]
    OR?: CallBreakGameScalarWhereWithAggregatesInput[]
    NOT?: CallBreakGameScalarWhereWithAggregatesInput | CallBreakGameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallBreakGame"> | string
    code?: StringWithAggregatesFilter<"CallBreakGame"> | string
    dealCount?: IntWithAggregatesFilter<"CallBreakGame"> | number
    trumpSuit?: StringWithAggregatesFilter<"CallBreakGame"> | string
    status?: EnumCallBreakStatusWithAggregatesFilter<"CallBreakGame"> | $Enums.CallBreakStatus
    createdBy?: StringWithAggregatesFilter<"CallBreakGame"> | string
    scores?: JsonWithAggregatesFilter<"CallBreakGame">
  }

  export type CallBreakPlayerWhereInput = {
    AND?: CallBreakPlayerWhereInput | CallBreakPlayerWhereInput[]
    OR?: CallBreakPlayerWhereInput[]
    NOT?: CallBreakPlayerWhereInput | CallBreakPlayerWhereInput[]
    id?: StringFilter<"CallBreakPlayer"> | string
    name?: StringFilter<"CallBreakPlayer"> | string
    avatar?: StringFilter<"CallBreakPlayer"> | string
    gameId?: StringFilter<"CallBreakPlayer"> | string
    isBot?: BoolFilter<"CallBreakPlayer"> | boolean
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    cardMappings?: CallBreakCardMappingListRelationFilter
  }

  export type CallBreakPlayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    isBot?: SortOrder
    game?: CallBreakGameOrderByWithRelationInput
    cardMappings?: CallBreakCardMappingOrderByRelationAggregateInput
  }

  export type CallBreakPlayerWhereUniqueInput = Prisma.AtLeast<{
    id_gameId?: CallBreakPlayerIdGameIdCompoundUniqueInput
    AND?: CallBreakPlayerWhereInput | CallBreakPlayerWhereInput[]
    OR?: CallBreakPlayerWhereInput[]
    NOT?: CallBreakPlayerWhereInput | CallBreakPlayerWhereInput[]
    id?: StringFilter<"CallBreakPlayer"> | string
    name?: StringFilter<"CallBreakPlayer"> | string
    avatar?: StringFilter<"CallBreakPlayer"> | string
    gameId?: StringFilter<"CallBreakPlayer"> | string
    isBot?: BoolFilter<"CallBreakPlayer"> | boolean
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    cardMappings?: CallBreakCardMappingListRelationFilter
  }, "id_gameId">

  export type CallBreakPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    isBot?: SortOrder
    _count?: CallBreakPlayerCountOrderByAggregateInput
    _max?: CallBreakPlayerMaxOrderByAggregateInput
    _min?: CallBreakPlayerMinOrderByAggregateInput
  }

  export type CallBreakPlayerScalarWhereWithAggregatesInput = {
    AND?: CallBreakPlayerScalarWhereWithAggregatesInput | CallBreakPlayerScalarWhereWithAggregatesInput[]
    OR?: CallBreakPlayerScalarWhereWithAggregatesInput[]
    NOT?: CallBreakPlayerScalarWhereWithAggregatesInput | CallBreakPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallBreakPlayer"> | string
    name?: StringWithAggregatesFilter<"CallBreakPlayer"> | string
    avatar?: StringWithAggregatesFilter<"CallBreakPlayer"> | string
    gameId?: StringWithAggregatesFilter<"CallBreakPlayer"> | string
    isBot?: BoolWithAggregatesFilter<"CallBreakPlayer"> | boolean
  }

  export type CallBreakDealWhereInput = {
    AND?: CallBreakDealWhereInput | CallBreakDealWhereInput[]
    OR?: CallBreakDealWhereInput[]
    NOT?: CallBreakDealWhereInput | CallBreakDealWhereInput[]
    id?: StringFilter<"CallBreakDeal"> | string
    gameId?: StringFilter<"CallBreakDeal"> | string
    playerOrder?: StringNullableListFilter<"CallBreakDeal">
    declarations?: JsonFilter<"CallBreakDeal">
    wins?: JsonFilter<"CallBreakDeal">
    turnIdx?: IntFilter<"CallBreakDeal"> | number
    status?: EnumCallBreakStatusFilter<"CallBreakDeal"> | $Enums.CallBreakStatus
    createdAt?: DateTimeFilter<"CallBreakDeal"> | Date | string
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    cardMappings?: CallBreakCardMappingListRelationFilter
    rounds?: CallBreakRoundListRelationFilter
  }

  export type CallBreakDealOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerOrder?: SortOrder
    declarations?: SortOrder
    wins?: SortOrder
    turnIdx?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    game?: CallBreakGameOrderByWithRelationInput
    cardMappings?: CallBreakCardMappingOrderByRelationAggregateInput
    rounds?: CallBreakRoundOrderByRelationAggregateInput
  }

  export type CallBreakDealWhereUniqueInput = Prisma.AtLeast<{
    id_gameId?: CallBreakDealIdGameIdCompoundUniqueInput
    AND?: CallBreakDealWhereInput | CallBreakDealWhereInput[]
    OR?: CallBreakDealWhereInput[]
    NOT?: CallBreakDealWhereInput | CallBreakDealWhereInput[]
    id?: StringFilter<"CallBreakDeal"> | string
    gameId?: StringFilter<"CallBreakDeal"> | string
    playerOrder?: StringNullableListFilter<"CallBreakDeal">
    declarations?: JsonFilter<"CallBreakDeal">
    wins?: JsonFilter<"CallBreakDeal">
    turnIdx?: IntFilter<"CallBreakDeal"> | number
    status?: EnumCallBreakStatusFilter<"CallBreakDeal"> | $Enums.CallBreakStatus
    createdAt?: DateTimeFilter<"CallBreakDeal"> | Date | string
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    cardMappings?: CallBreakCardMappingListRelationFilter
    rounds?: CallBreakRoundListRelationFilter
  }, "id_gameId">

  export type CallBreakDealOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerOrder?: SortOrder
    declarations?: SortOrder
    wins?: SortOrder
    turnIdx?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: CallBreakDealCountOrderByAggregateInput
    _avg?: CallBreakDealAvgOrderByAggregateInput
    _max?: CallBreakDealMaxOrderByAggregateInput
    _min?: CallBreakDealMinOrderByAggregateInput
    _sum?: CallBreakDealSumOrderByAggregateInput
  }

  export type CallBreakDealScalarWhereWithAggregatesInput = {
    AND?: CallBreakDealScalarWhereWithAggregatesInput | CallBreakDealScalarWhereWithAggregatesInput[]
    OR?: CallBreakDealScalarWhereWithAggregatesInput[]
    NOT?: CallBreakDealScalarWhereWithAggregatesInput | CallBreakDealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallBreakDeal"> | string
    gameId?: StringWithAggregatesFilter<"CallBreakDeal"> | string
    playerOrder?: StringNullableListFilter<"CallBreakDeal">
    declarations?: JsonWithAggregatesFilter<"CallBreakDeal">
    wins?: JsonWithAggregatesFilter<"CallBreakDeal">
    turnIdx?: IntWithAggregatesFilter<"CallBreakDeal"> | number
    status?: EnumCallBreakStatusWithAggregatesFilter<"CallBreakDeal"> | $Enums.CallBreakStatus
    createdAt?: DateTimeWithAggregatesFilter<"CallBreakDeal"> | Date | string
  }

  export type CallBreakCardMappingWhereInput = {
    AND?: CallBreakCardMappingWhereInput | CallBreakCardMappingWhereInput[]
    OR?: CallBreakCardMappingWhereInput[]
    NOT?: CallBreakCardMappingWhereInput | CallBreakCardMappingWhereInput[]
    cardId?: StringFilter<"CallBreakCardMapping"> | string
    dealId?: StringFilter<"CallBreakCardMapping"> | string
    gameId?: StringFilter<"CallBreakCardMapping"> | string
    playerId?: StringFilter<"CallBreakCardMapping"> | string
    deal?: XOR<CallBreakDealScalarRelationFilter, CallBreakDealWhereInput>
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    player?: XOR<CallBreakPlayerScalarRelationFilter, CallBreakPlayerWhereInput>
  }

  export type CallBreakCardMappingOrderByWithRelationInput = {
    cardId?: SortOrder
    dealId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    deal?: CallBreakDealOrderByWithRelationInput
    game?: CallBreakGameOrderByWithRelationInput
    player?: CallBreakPlayerOrderByWithRelationInput
  }

  export type CallBreakCardMappingWhereUniqueInput = Prisma.AtLeast<{
    cardId_dealId_gameId?: CallBreakCardMappingCardIdDealIdGameIdCompoundUniqueInput
    AND?: CallBreakCardMappingWhereInput | CallBreakCardMappingWhereInput[]
    OR?: CallBreakCardMappingWhereInput[]
    NOT?: CallBreakCardMappingWhereInput | CallBreakCardMappingWhereInput[]
    cardId?: StringFilter<"CallBreakCardMapping"> | string
    dealId?: StringFilter<"CallBreakCardMapping"> | string
    gameId?: StringFilter<"CallBreakCardMapping"> | string
    playerId?: StringFilter<"CallBreakCardMapping"> | string
    deal?: XOR<CallBreakDealScalarRelationFilter, CallBreakDealWhereInput>
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
    player?: XOR<CallBreakPlayerScalarRelationFilter, CallBreakPlayerWhereInput>
  }, "cardId_dealId_gameId">

  export type CallBreakCardMappingOrderByWithAggregationInput = {
    cardId?: SortOrder
    dealId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    _count?: CallBreakCardMappingCountOrderByAggregateInput
    _max?: CallBreakCardMappingMaxOrderByAggregateInput
    _min?: CallBreakCardMappingMinOrderByAggregateInput
  }

  export type CallBreakCardMappingScalarWhereWithAggregatesInput = {
    AND?: CallBreakCardMappingScalarWhereWithAggregatesInput | CallBreakCardMappingScalarWhereWithAggregatesInput[]
    OR?: CallBreakCardMappingScalarWhereWithAggregatesInput[]
    NOT?: CallBreakCardMappingScalarWhereWithAggregatesInput | CallBreakCardMappingScalarWhereWithAggregatesInput[]
    cardId?: StringWithAggregatesFilter<"CallBreakCardMapping"> | string
    dealId?: StringWithAggregatesFilter<"CallBreakCardMapping"> | string
    gameId?: StringWithAggregatesFilter<"CallBreakCardMapping"> | string
    playerId?: StringWithAggregatesFilter<"CallBreakCardMapping"> | string
  }

  export type CallBreakRoundWhereInput = {
    AND?: CallBreakRoundWhereInput | CallBreakRoundWhereInput[]
    OR?: CallBreakRoundWhereInput[]
    NOT?: CallBreakRoundWhereInput | CallBreakRoundWhereInput[]
    id?: StringFilter<"CallBreakRound"> | string
    gameId?: StringFilter<"CallBreakRound"> | string
    dealId?: StringFilter<"CallBreakRound"> | string
    winner?: StringNullableFilter<"CallBreakRound"> | string | null
    playerOrder?: StringNullableListFilter<"CallBreakRound">
    cards?: JsonFilter<"CallBreakRound">
    turnIdx?: IntFilter<"CallBreakRound"> | number
    suit?: StringNullableFilter<"CallBreakRound"> | string | null
    completed?: BoolFilter<"CallBreakRound"> | boolean
    createdAt?: DateTimeFilter<"CallBreakRound"> | Date | string
    deal?: XOR<CallBreakDealScalarRelationFilter, CallBreakDealWhereInput>
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
  }

  export type CallBreakRoundOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    dealId?: SortOrder
    winner?: SortOrderInput | SortOrder
    playerOrder?: SortOrder
    cards?: SortOrder
    turnIdx?: SortOrder
    suit?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    deal?: CallBreakDealOrderByWithRelationInput
    game?: CallBreakGameOrderByWithRelationInput
  }

  export type CallBreakRoundWhereUniqueInput = Prisma.AtLeast<{
    id_dealId_gameId?: CallBreakRoundIdDealIdGameIdCompoundUniqueInput
    AND?: CallBreakRoundWhereInput | CallBreakRoundWhereInput[]
    OR?: CallBreakRoundWhereInput[]
    NOT?: CallBreakRoundWhereInput | CallBreakRoundWhereInput[]
    id?: StringFilter<"CallBreakRound"> | string
    gameId?: StringFilter<"CallBreakRound"> | string
    dealId?: StringFilter<"CallBreakRound"> | string
    winner?: StringNullableFilter<"CallBreakRound"> | string | null
    playerOrder?: StringNullableListFilter<"CallBreakRound">
    cards?: JsonFilter<"CallBreakRound">
    turnIdx?: IntFilter<"CallBreakRound"> | number
    suit?: StringNullableFilter<"CallBreakRound"> | string | null
    completed?: BoolFilter<"CallBreakRound"> | boolean
    createdAt?: DateTimeFilter<"CallBreakRound"> | Date | string
    deal?: XOR<CallBreakDealScalarRelationFilter, CallBreakDealWhereInput>
    game?: XOR<CallBreakGameScalarRelationFilter, CallBreakGameWhereInput>
  }, "id_dealId_gameId">

  export type CallBreakRoundOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    dealId?: SortOrder
    winner?: SortOrderInput | SortOrder
    playerOrder?: SortOrder
    cards?: SortOrder
    turnIdx?: SortOrder
    suit?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    _count?: CallBreakRoundCountOrderByAggregateInput
    _avg?: CallBreakRoundAvgOrderByAggregateInput
    _max?: CallBreakRoundMaxOrderByAggregateInput
    _min?: CallBreakRoundMinOrderByAggregateInput
    _sum?: CallBreakRoundSumOrderByAggregateInput
  }

  export type CallBreakRoundScalarWhereWithAggregatesInput = {
    AND?: CallBreakRoundScalarWhereWithAggregatesInput | CallBreakRoundScalarWhereWithAggregatesInput[]
    OR?: CallBreakRoundScalarWhereWithAggregatesInput[]
    NOT?: CallBreakRoundScalarWhereWithAggregatesInput | CallBreakRoundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallBreakRound"> | string
    gameId?: StringWithAggregatesFilter<"CallBreakRound"> | string
    dealId?: StringWithAggregatesFilter<"CallBreakRound"> | string
    winner?: StringNullableWithAggregatesFilter<"CallBreakRound"> | string | null
    playerOrder?: StringNullableListFilter<"CallBreakRound">
    cards?: JsonWithAggregatesFilter<"CallBreakRound">
    turnIdx?: IntWithAggregatesFilter<"CallBreakRound"> | number
    suit?: StringNullableWithAggregatesFilter<"CallBreakRound"> | string | null
    completed?: BoolWithAggregatesFilter<"CallBreakRound"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CallBreakRound"> | Date | string
  }

  export type LiteraturePlayerWhereInput = {
    AND?: LiteraturePlayerWhereInput | LiteraturePlayerWhereInput[]
    OR?: LiteraturePlayerWhereInput[]
    NOT?: LiteraturePlayerWhereInput | LiteraturePlayerWhereInput[]
    id?: StringFilter<"LiteraturePlayer"> | string
    name?: StringFilter<"LiteraturePlayer"> | string
    avatar?: StringFilter<"LiteraturePlayer"> | string
    gameId?: StringFilter<"LiteraturePlayer"> | string
    teamId?: StringNullableFilter<"LiteraturePlayer"> | string | null
    isBot?: BoolFilter<"LiteraturePlayer"> | boolean
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    team?: XOR<LiteratureTeamNullableScalarRelationFilter, LiteratureTeamWhereInput> | null
    cardMappings?: LiteratureCardMappingListRelationFilter
    cardLocations?: LiteratureCardLocationListRelationFilter
    asks?: LiteratureAskListRelationFilter
    calls?: LiteratureCallListRelationFilter
    transfers?: LiteratureTransferListRelationFilter
  }

  export type LiteraturePlayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isBot?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    team?: LiteratureTeamOrderByWithRelationInput
    cardMappings?: LiteratureCardMappingOrderByRelationAggregateInput
    cardLocations?: LiteratureCardLocationOrderByRelationAggregateInput
    asks?: LiteratureAskOrderByRelationAggregateInput
    calls?: LiteratureCallOrderByRelationAggregateInput
    transfers?: LiteratureTransferOrderByRelationAggregateInput
  }

  export type LiteraturePlayerWhereUniqueInput = Prisma.AtLeast<{
    id_gameId?: LiteraturePlayerIdGameIdCompoundUniqueInput
    AND?: LiteraturePlayerWhereInput | LiteraturePlayerWhereInput[]
    OR?: LiteraturePlayerWhereInput[]
    NOT?: LiteraturePlayerWhereInput | LiteraturePlayerWhereInput[]
    id?: StringFilter<"LiteraturePlayer"> | string
    name?: StringFilter<"LiteraturePlayer"> | string
    avatar?: StringFilter<"LiteraturePlayer"> | string
    gameId?: StringFilter<"LiteraturePlayer"> | string
    teamId?: StringNullableFilter<"LiteraturePlayer"> | string | null
    isBot?: BoolFilter<"LiteraturePlayer"> | boolean
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    team?: XOR<LiteratureTeamNullableScalarRelationFilter, LiteratureTeamWhereInput> | null
    cardMappings?: LiteratureCardMappingListRelationFilter
    cardLocations?: LiteratureCardLocationListRelationFilter
    asks?: LiteratureAskListRelationFilter
    calls?: LiteratureCallListRelationFilter
    transfers?: LiteratureTransferListRelationFilter
  }, "id_gameId">

  export type LiteraturePlayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isBot?: SortOrder
    _count?: LiteraturePlayerCountOrderByAggregateInput
    _max?: LiteraturePlayerMaxOrderByAggregateInput
    _min?: LiteraturePlayerMinOrderByAggregateInput
  }

  export type LiteraturePlayerScalarWhereWithAggregatesInput = {
    AND?: LiteraturePlayerScalarWhereWithAggregatesInput | LiteraturePlayerScalarWhereWithAggregatesInput[]
    OR?: LiteraturePlayerScalarWhereWithAggregatesInput[]
    NOT?: LiteraturePlayerScalarWhereWithAggregatesInput | LiteraturePlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteraturePlayer"> | string
    name?: StringWithAggregatesFilter<"LiteraturePlayer"> | string
    avatar?: StringWithAggregatesFilter<"LiteraturePlayer"> | string
    gameId?: StringWithAggregatesFilter<"LiteraturePlayer"> | string
    teamId?: StringNullableWithAggregatesFilter<"LiteraturePlayer"> | string | null
    isBot?: BoolWithAggregatesFilter<"LiteraturePlayer"> | boolean
  }

  export type LiteratureTeamWhereInput = {
    AND?: LiteratureTeamWhereInput | LiteratureTeamWhereInput[]
    OR?: LiteratureTeamWhereInput[]
    NOT?: LiteratureTeamWhereInput | LiteratureTeamWhereInput[]
    id?: StringFilter<"LiteratureTeam"> | string
    name?: StringFilter<"LiteratureTeam"> | string
    score?: IntFilter<"LiteratureTeam"> | number
    setsWon?: StringNullableListFilter<"LiteratureTeam">
    memberIds?: StringNullableListFilter<"LiteratureTeam">
    gameId?: StringFilter<"LiteratureTeam"> | string
    members?: LiteraturePlayerListRelationFilter
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
  }

  export type LiteratureTeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    score?: SortOrder
    setsWon?: SortOrder
    memberIds?: SortOrder
    gameId?: SortOrder
    members?: LiteraturePlayerOrderByRelationAggregateInput
    game?: LiteratureGameOrderByWithRelationInput
  }

  export type LiteratureTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiteratureTeamWhereInput | LiteratureTeamWhereInput[]
    OR?: LiteratureTeamWhereInput[]
    NOT?: LiteratureTeamWhereInput | LiteratureTeamWhereInput[]
    name?: StringFilter<"LiteratureTeam"> | string
    score?: IntFilter<"LiteratureTeam"> | number
    setsWon?: StringNullableListFilter<"LiteratureTeam">
    memberIds?: StringNullableListFilter<"LiteratureTeam">
    gameId?: StringFilter<"LiteratureTeam"> | string
    members?: LiteraturePlayerListRelationFilter
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
  }, "id">

  export type LiteratureTeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    score?: SortOrder
    setsWon?: SortOrder
    memberIds?: SortOrder
    gameId?: SortOrder
    _count?: LiteratureTeamCountOrderByAggregateInput
    _avg?: LiteratureTeamAvgOrderByAggregateInput
    _max?: LiteratureTeamMaxOrderByAggregateInput
    _min?: LiteratureTeamMinOrderByAggregateInput
    _sum?: LiteratureTeamSumOrderByAggregateInput
  }

  export type LiteratureTeamScalarWhereWithAggregatesInput = {
    AND?: LiteratureTeamScalarWhereWithAggregatesInput | LiteratureTeamScalarWhereWithAggregatesInput[]
    OR?: LiteratureTeamScalarWhereWithAggregatesInput[]
    NOT?: LiteratureTeamScalarWhereWithAggregatesInput | LiteratureTeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteratureTeam"> | string
    name?: StringWithAggregatesFilter<"LiteratureTeam"> | string
    score?: IntWithAggregatesFilter<"LiteratureTeam"> | number
    setsWon?: StringNullableListFilter<"LiteratureTeam">
    memberIds?: StringNullableListFilter<"LiteratureTeam">
    gameId?: StringWithAggregatesFilter<"LiteratureTeam"> | string
  }

  export type LiteratureCardMappingWhereInput = {
    AND?: LiteratureCardMappingWhereInput | LiteratureCardMappingWhereInput[]
    OR?: LiteratureCardMappingWhereInput[]
    NOT?: LiteratureCardMappingWhereInput | LiteratureCardMappingWhereInput[]
    cardId?: StringFilter<"LiteratureCardMapping"> | string
    gameId?: StringFilter<"LiteratureCardMapping"> | string
    playerId?: StringFilter<"LiteratureCardMapping"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }

  export type LiteratureCardMappingOrderByWithRelationInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    player?: LiteraturePlayerOrderByWithRelationInput
  }

  export type LiteratureCardMappingWhereUniqueInput = Prisma.AtLeast<{
    gameId_cardId?: LiteratureCardMappingGameIdCardIdCompoundUniqueInput
    AND?: LiteratureCardMappingWhereInput | LiteratureCardMappingWhereInput[]
    OR?: LiteratureCardMappingWhereInput[]
    NOT?: LiteratureCardMappingWhereInput | LiteratureCardMappingWhereInput[]
    cardId?: StringFilter<"LiteratureCardMapping"> | string
    gameId?: StringFilter<"LiteratureCardMapping"> | string
    playerId?: StringFilter<"LiteratureCardMapping"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }, "gameId_cardId">

  export type LiteratureCardMappingOrderByWithAggregationInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    _count?: LiteratureCardMappingCountOrderByAggregateInput
    _max?: LiteratureCardMappingMaxOrderByAggregateInput
    _min?: LiteratureCardMappingMinOrderByAggregateInput
  }

  export type LiteratureCardMappingScalarWhereWithAggregatesInput = {
    AND?: LiteratureCardMappingScalarWhereWithAggregatesInput | LiteratureCardMappingScalarWhereWithAggregatesInput[]
    OR?: LiteratureCardMappingScalarWhereWithAggregatesInput[]
    NOT?: LiteratureCardMappingScalarWhereWithAggregatesInput | LiteratureCardMappingScalarWhereWithAggregatesInput[]
    cardId?: StringWithAggregatesFilter<"LiteratureCardMapping"> | string
    gameId?: StringWithAggregatesFilter<"LiteratureCardMapping"> | string
    playerId?: StringWithAggregatesFilter<"LiteratureCardMapping"> | string
  }

  export type LiteratureCardLocationWhereInput = {
    AND?: LiteratureCardLocationWhereInput | LiteratureCardLocationWhereInput[]
    OR?: LiteratureCardLocationWhereInput[]
    NOT?: LiteratureCardLocationWhereInput | LiteratureCardLocationWhereInput[]
    cardId?: StringFilter<"LiteratureCardLocation"> | string
    gameId?: StringFilter<"LiteratureCardLocation"> | string
    playerId?: StringFilter<"LiteratureCardLocation"> | string
    playerIds?: StringNullableListFilter<"LiteratureCardLocation">
    weight?: IntFilter<"LiteratureCardLocation"> | number
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }

  export type LiteratureCardLocationOrderByWithRelationInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    playerIds?: SortOrder
    weight?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    player?: LiteraturePlayerOrderByWithRelationInput
  }

  export type LiteratureCardLocationWhereUniqueInput = Prisma.AtLeast<{
    gameId_playerId_cardId?: LiteratureCardLocationGameIdPlayerIdCardIdCompoundUniqueInput
    AND?: LiteratureCardLocationWhereInput | LiteratureCardLocationWhereInput[]
    OR?: LiteratureCardLocationWhereInput[]
    NOT?: LiteratureCardLocationWhereInput | LiteratureCardLocationWhereInput[]
    cardId?: StringFilter<"LiteratureCardLocation"> | string
    gameId?: StringFilter<"LiteratureCardLocation"> | string
    playerId?: StringFilter<"LiteratureCardLocation"> | string
    playerIds?: StringNullableListFilter<"LiteratureCardLocation">
    weight?: IntFilter<"LiteratureCardLocation"> | number
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }, "gameId_playerId_cardId">

  export type LiteratureCardLocationOrderByWithAggregationInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    playerIds?: SortOrder
    weight?: SortOrder
    _count?: LiteratureCardLocationCountOrderByAggregateInput
    _avg?: LiteratureCardLocationAvgOrderByAggregateInput
    _max?: LiteratureCardLocationMaxOrderByAggregateInput
    _min?: LiteratureCardLocationMinOrderByAggregateInput
    _sum?: LiteratureCardLocationSumOrderByAggregateInput
  }

  export type LiteratureCardLocationScalarWhereWithAggregatesInput = {
    AND?: LiteratureCardLocationScalarWhereWithAggregatesInput | LiteratureCardLocationScalarWhereWithAggregatesInput[]
    OR?: LiteratureCardLocationScalarWhereWithAggregatesInput[]
    NOT?: LiteratureCardLocationScalarWhereWithAggregatesInput | LiteratureCardLocationScalarWhereWithAggregatesInput[]
    cardId?: StringWithAggregatesFilter<"LiteratureCardLocation"> | string
    gameId?: StringWithAggregatesFilter<"LiteratureCardLocation"> | string
    playerId?: StringWithAggregatesFilter<"LiteratureCardLocation"> | string
    playerIds?: StringNullableListFilter<"LiteratureCardLocation">
    weight?: IntWithAggregatesFilter<"LiteratureCardLocation"> | number
  }

  export type LiteratureAskWhereInput = {
    AND?: LiteratureAskWhereInput | LiteratureAskWhereInput[]
    OR?: LiteratureAskWhereInput[]
    NOT?: LiteratureAskWhereInput | LiteratureAskWhereInput[]
    id?: StringFilter<"LiteratureAsk"> | string
    gameId?: StringFilter<"LiteratureAsk"> | string
    playerId?: StringFilter<"LiteratureAsk"> | string
    timestamp?: DateTimeFilter<"LiteratureAsk"> | Date | string
    description?: StringFilter<"LiteratureAsk"> | string
    success?: BoolFilter<"LiteratureAsk"> | boolean
    cardId?: StringFilter<"LiteratureAsk"> | string
    askedFrom?: StringFilter<"LiteratureAsk"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }

  export type LiteratureAskOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardId?: SortOrder
    askedFrom?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    player?: LiteraturePlayerOrderByWithRelationInput
  }

  export type LiteratureAskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiteratureAskWhereInput | LiteratureAskWhereInput[]
    OR?: LiteratureAskWhereInput[]
    NOT?: LiteratureAskWhereInput | LiteratureAskWhereInput[]
    gameId?: StringFilter<"LiteratureAsk"> | string
    playerId?: StringFilter<"LiteratureAsk"> | string
    timestamp?: DateTimeFilter<"LiteratureAsk"> | Date | string
    description?: StringFilter<"LiteratureAsk"> | string
    success?: BoolFilter<"LiteratureAsk"> | boolean
    cardId?: StringFilter<"LiteratureAsk"> | string
    askedFrom?: StringFilter<"LiteratureAsk"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }, "id">

  export type LiteratureAskOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardId?: SortOrder
    askedFrom?: SortOrder
    _count?: LiteratureAskCountOrderByAggregateInput
    _max?: LiteratureAskMaxOrderByAggregateInput
    _min?: LiteratureAskMinOrderByAggregateInput
  }

  export type LiteratureAskScalarWhereWithAggregatesInput = {
    AND?: LiteratureAskScalarWhereWithAggregatesInput | LiteratureAskScalarWhereWithAggregatesInput[]
    OR?: LiteratureAskScalarWhereWithAggregatesInput[]
    NOT?: LiteratureAskScalarWhereWithAggregatesInput | LiteratureAskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteratureAsk"> | string
    gameId?: StringWithAggregatesFilter<"LiteratureAsk"> | string
    playerId?: StringWithAggregatesFilter<"LiteratureAsk"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LiteratureAsk"> | Date | string
    description?: StringWithAggregatesFilter<"LiteratureAsk"> | string
    success?: BoolWithAggregatesFilter<"LiteratureAsk"> | boolean
    cardId?: StringWithAggregatesFilter<"LiteratureAsk"> | string
    askedFrom?: StringWithAggregatesFilter<"LiteratureAsk"> | string
  }

  export type LiteratureCallWhereInput = {
    AND?: LiteratureCallWhereInput | LiteratureCallWhereInput[]
    OR?: LiteratureCallWhereInput[]
    NOT?: LiteratureCallWhereInput | LiteratureCallWhereInput[]
    id?: StringFilter<"LiteratureCall"> | string
    gameId?: StringFilter<"LiteratureCall"> | string
    playerId?: StringFilter<"LiteratureCall"> | string
    timestamp?: DateTimeFilter<"LiteratureCall"> | Date | string
    description?: StringFilter<"LiteratureCall"> | string
    success?: BoolFilter<"LiteratureCall"> | boolean
    cardSet?: StringFilter<"LiteratureCall"> | string
    actualCall?: JsonFilter<"LiteratureCall">
    correctCall?: JsonFilter<"LiteratureCall">
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }

  export type LiteratureCallOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardSet?: SortOrder
    actualCall?: SortOrder
    correctCall?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    player?: LiteraturePlayerOrderByWithRelationInput
  }

  export type LiteratureCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiteratureCallWhereInput | LiteratureCallWhereInput[]
    OR?: LiteratureCallWhereInput[]
    NOT?: LiteratureCallWhereInput | LiteratureCallWhereInput[]
    gameId?: StringFilter<"LiteratureCall"> | string
    playerId?: StringFilter<"LiteratureCall"> | string
    timestamp?: DateTimeFilter<"LiteratureCall"> | Date | string
    description?: StringFilter<"LiteratureCall"> | string
    success?: BoolFilter<"LiteratureCall"> | boolean
    cardSet?: StringFilter<"LiteratureCall"> | string
    actualCall?: JsonFilter<"LiteratureCall">
    correctCall?: JsonFilter<"LiteratureCall">
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }, "id">

  export type LiteratureCallOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardSet?: SortOrder
    actualCall?: SortOrder
    correctCall?: SortOrder
    _count?: LiteratureCallCountOrderByAggregateInput
    _max?: LiteratureCallMaxOrderByAggregateInput
    _min?: LiteratureCallMinOrderByAggregateInput
  }

  export type LiteratureCallScalarWhereWithAggregatesInput = {
    AND?: LiteratureCallScalarWhereWithAggregatesInput | LiteratureCallScalarWhereWithAggregatesInput[]
    OR?: LiteratureCallScalarWhereWithAggregatesInput[]
    NOT?: LiteratureCallScalarWhereWithAggregatesInput | LiteratureCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteratureCall"> | string
    gameId?: StringWithAggregatesFilter<"LiteratureCall"> | string
    playerId?: StringWithAggregatesFilter<"LiteratureCall"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LiteratureCall"> | Date | string
    description?: StringWithAggregatesFilter<"LiteratureCall"> | string
    success?: BoolWithAggregatesFilter<"LiteratureCall"> | boolean
    cardSet?: StringWithAggregatesFilter<"LiteratureCall"> | string
    actualCall?: JsonWithAggregatesFilter<"LiteratureCall">
    correctCall?: JsonWithAggregatesFilter<"LiteratureCall">
  }

  export type LiteratureTransferWhereInput = {
    AND?: LiteratureTransferWhereInput | LiteratureTransferWhereInput[]
    OR?: LiteratureTransferWhereInput[]
    NOT?: LiteratureTransferWhereInput | LiteratureTransferWhereInput[]
    id?: StringFilter<"LiteratureTransfer"> | string
    gameId?: StringFilter<"LiteratureTransfer"> | string
    playerId?: StringFilter<"LiteratureTransfer"> | string
    timestamp?: DateTimeFilter<"LiteratureTransfer"> | Date | string
    description?: StringFilter<"LiteratureTransfer"> | string
    success?: BoolFilter<"LiteratureTransfer"> | boolean
    transferTo?: StringFilter<"LiteratureTransfer"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }

  export type LiteratureTransferOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    transferTo?: SortOrder
    game?: LiteratureGameOrderByWithRelationInput
    player?: LiteraturePlayerOrderByWithRelationInput
  }

  export type LiteratureTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiteratureTransferWhereInput | LiteratureTransferWhereInput[]
    OR?: LiteratureTransferWhereInput[]
    NOT?: LiteratureTransferWhereInput | LiteratureTransferWhereInput[]
    gameId?: StringFilter<"LiteratureTransfer"> | string
    playerId?: StringFilter<"LiteratureTransfer"> | string
    timestamp?: DateTimeFilter<"LiteratureTransfer"> | Date | string
    description?: StringFilter<"LiteratureTransfer"> | string
    success?: BoolFilter<"LiteratureTransfer"> | boolean
    transferTo?: StringFilter<"LiteratureTransfer"> | string
    game?: XOR<LiteratureGameScalarRelationFilter, LiteratureGameWhereInput>
    player?: XOR<LiteraturePlayerScalarRelationFilter, LiteraturePlayerWhereInput>
  }, "id">

  export type LiteratureTransferOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    transferTo?: SortOrder
    _count?: LiteratureTransferCountOrderByAggregateInput
    _max?: LiteratureTransferMaxOrderByAggregateInput
    _min?: LiteratureTransferMinOrderByAggregateInput
  }

  export type LiteratureTransferScalarWhereWithAggregatesInput = {
    AND?: LiteratureTransferScalarWhereWithAggregatesInput | LiteratureTransferScalarWhereWithAggregatesInput[]
    OR?: LiteratureTransferScalarWhereWithAggregatesInput[]
    NOT?: LiteratureTransferScalarWhereWithAggregatesInput | LiteratureTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteratureTransfer"> | string
    gameId?: StringWithAggregatesFilter<"LiteratureTransfer"> | string
    playerId?: StringWithAggregatesFilter<"LiteratureTransfer"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LiteratureTransfer"> | Date | string
    description?: StringWithAggregatesFilter<"LiteratureTransfer"> | string
    success?: BoolWithAggregatesFilter<"LiteratureTransfer"> | boolean
    transferTo?: StringWithAggregatesFilter<"LiteratureTransfer"> | string
  }

  export type LiteratureGameWhereInput = {
    AND?: LiteratureGameWhereInput | LiteratureGameWhereInput[]
    OR?: LiteratureGameWhereInput[]
    NOT?: LiteratureGameWhereInput | LiteratureGameWhereInput[]
    id?: StringFilter<"LiteratureGame"> | string
    code?: StringFilter<"LiteratureGame"> | string
    status?: EnumLiteratureGameStatusFilter<"LiteratureGame"> | $Enums.LiteratureGameStatus
    playerCount?: IntFilter<"LiteratureGame"> | number
    currentTurn?: StringFilter<"LiteratureGame"> | string
    lastMoveId?: StringFilter<"LiteratureGame"> | string
    players?: LiteraturePlayerListRelationFilter
    teams?: LiteratureTeamListRelationFilter
    cardMappings?: LiteratureCardMappingListRelationFilter
    cardLocations?: LiteratureCardLocationListRelationFilter
    asks?: LiteratureAskListRelationFilter
    calls?: LiteratureCallListRelationFilter
    transfers?: LiteratureTransferListRelationFilter
  }

  export type LiteratureGameOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    playerCount?: SortOrder
    currentTurn?: SortOrder
    lastMoveId?: SortOrder
    players?: LiteraturePlayerOrderByRelationAggregateInput
    teams?: LiteratureTeamOrderByRelationAggregateInput
    cardMappings?: LiteratureCardMappingOrderByRelationAggregateInput
    cardLocations?: LiteratureCardLocationOrderByRelationAggregateInput
    asks?: LiteratureAskOrderByRelationAggregateInput
    calls?: LiteratureCallOrderByRelationAggregateInput
    transfers?: LiteratureTransferOrderByRelationAggregateInput
  }

  export type LiteratureGameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LiteratureGameWhereInput | LiteratureGameWhereInput[]
    OR?: LiteratureGameWhereInput[]
    NOT?: LiteratureGameWhereInput | LiteratureGameWhereInput[]
    status?: EnumLiteratureGameStatusFilter<"LiteratureGame"> | $Enums.LiteratureGameStatus
    playerCount?: IntFilter<"LiteratureGame"> | number
    currentTurn?: StringFilter<"LiteratureGame"> | string
    lastMoveId?: StringFilter<"LiteratureGame"> | string
    players?: LiteraturePlayerListRelationFilter
    teams?: LiteratureTeamListRelationFilter
    cardMappings?: LiteratureCardMappingListRelationFilter
    cardLocations?: LiteratureCardLocationListRelationFilter
    asks?: LiteratureAskListRelationFilter
    calls?: LiteratureCallListRelationFilter
    transfers?: LiteratureTransferListRelationFilter
  }, "id" | "code">

  export type LiteratureGameOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    playerCount?: SortOrder
    currentTurn?: SortOrder
    lastMoveId?: SortOrder
    _count?: LiteratureGameCountOrderByAggregateInput
    _avg?: LiteratureGameAvgOrderByAggregateInput
    _max?: LiteratureGameMaxOrderByAggregateInput
    _min?: LiteratureGameMinOrderByAggregateInput
    _sum?: LiteratureGameSumOrderByAggregateInput
  }

  export type LiteratureGameScalarWhereWithAggregatesInput = {
    AND?: LiteratureGameScalarWhereWithAggregatesInput | LiteratureGameScalarWhereWithAggregatesInput[]
    OR?: LiteratureGameScalarWhereWithAggregatesInput[]
    NOT?: LiteratureGameScalarWhereWithAggregatesInput | LiteratureGameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiteratureGame"> | string
    code?: StringWithAggregatesFilter<"LiteratureGame"> | string
    status?: EnumLiteratureGameStatusWithAggregatesFilter<"LiteratureGame"> | $Enums.LiteratureGameStatus
    playerCount?: IntWithAggregatesFilter<"LiteratureGame"> | number
    currentTurn?: StringWithAggregatesFilter<"LiteratureGame"> | string
    lastMoveId?: StringWithAggregatesFilter<"LiteratureGame"> | string
  }

  export type WordleGameWhereInput = {
    AND?: WordleGameWhereInput | WordleGameWhereInput[]
    OR?: WordleGameWhereInput[]
    NOT?: WordleGameWhereInput | WordleGameWhereInput[]
    id?: StringFilter<"WordleGame"> | string
    playerId?: StringFilter<"WordleGame"> | string
    wordLength?: IntFilter<"WordleGame"> | number
    wordCount?: IntFilter<"WordleGame"> | number
    words?: StringNullableListFilter<"WordleGame">
    guesses?: StringNullableListFilter<"WordleGame">
    completedWords?: StringNullableListFilter<"WordleGame">
  }

  export type WordleGameOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    wordLength?: SortOrder
    wordCount?: SortOrder
    words?: SortOrder
    guesses?: SortOrder
    completedWords?: SortOrder
  }

  export type WordleGameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WordleGameWhereInput | WordleGameWhereInput[]
    OR?: WordleGameWhereInput[]
    NOT?: WordleGameWhereInput | WordleGameWhereInput[]
    playerId?: StringFilter<"WordleGame"> | string
    wordLength?: IntFilter<"WordleGame"> | number
    wordCount?: IntFilter<"WordleGame"> | number
    words?: StringNullableListFilter<"WordleGame">
    guesses?: StringNullableListFilter<"WordleGame">
    completedWords?: StringNullableListFilter<"WordleGame">
  }, "id">

  export type WordleGameOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    wordLength?: SortOrder
    wordCount?: SortOrder
    words?: SortOrder
    guesses?: SortOrder
    completedWords?: SortOrder
    _count?: WordleGameCountOrderByAggregateInput
    _avg?: WordleGameAvgOrderByAggregateInput
    _max?: WordleGameMaxOrderByAggregateInput
    _min?: WordleGameMinOrderByAggregateInput
    _sum?: WordleGameSumOrderByAggregateInput
  }

  export type WordleGameScalarWhereWithAggregatesInput = {
    AND?: WordleGameScalarWhereWithAggregatesInput | WordleGameScalarWhereWithAggregatesInput[]
    OR?: WordleGameScalarWhereWithAggregatesInput[]
    NOT?: WordleGameScalarWhereWithAggregatesInput | WordleGameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WordleGame"> | string
    playerId?: StringWithAggregatesFilter<"WordleGame"> | string
    wordLength?: IntWithAggregatesFilter<"WordleGame"> | number
    wordCount?: IntWithAggregatesFilter<"WordleGame"> | number
    words?: StringNullableListFilter<"WordleGame">
    guesses?: StringNullableListFilter<"WordleGame">
    completedWords?: StringNullableListFilter<"WordleGame">
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakGameCreateInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerCreateNestedManyWithoutGameInput
    deals?: CallBreakDealCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUncheckedCreateInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedCreateNestedManyWithoutGameInput
    deals?: CallBreakDealUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameCreateManyInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
  }

  export type CallBreakGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
  }

  export type CallBreakGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
  }

  export type CallBreakPlayerCreateInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: CallBreakGameCreateNestedOneWithoutPlayersInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutPlayerInput
  }

  export type CallBreakPlayerUncheckedCreateInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    isBot?: boolean
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type CallBreakPlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: CallBreakGameUpdateOneRequiredWithoutPlayersNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutPlayerNestedInput
  }

  export type CallBreakPlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type CallBreakPlayerCreateManyInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    isBot?: boolean
  }

  export type CallBreakPlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CallBreakPlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CallBreakDealCreateInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    game: CallBreakGameCreateNestedOneWithoutDealsInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutDealInput
    rounds?: CallBreakRoundCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealUncheckedCreateInput = {
    id?: string
    gameId: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutDealInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: CallBreakGameUpdateOneRequiredWithoutDealsNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutDealNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutDealNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealCreateManyInput = {
    id?: string
    gameId: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
  }

  export type CallBreakDealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakDealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakCardMappingCreateInput = {
    cardId: string
    deal: CallBreakDealCreateNestedOneWithoutCardMappingsInput
    game: CallBreakGameCreateNestedOneWithoutCardMappingsInput
    player: CallBreakPlayerCreateNestedOneWithoutCardMappingsInput
  }

  export type CallBreakCardMappingUncheckedCreateInput = {
    cardId: string
    dealId: string
    gameId: string
    playerId: string
  }

  export type CallBreakCardMappingUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    deal?: CallBreakDealUpdateOneRequiredWithoutCardMappingsNestedInput
    game?: CallBreakGameUpdateOneRequiredWithoutCardMappingsNestedInput
    player?: CallBreakPlayerUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type CallBreakCardMappingUncheckedUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingCreateManyInput = {
    cardId: string
    dealId: string
    gameId: string
    playerId: string
  }

  export type CallBreakCardMappingUpdateManyMutationInput = {
    cardId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingUncheckedUpdateManyInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakRoundCreateInput = {
    id?: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
    deal: CallBreakDealCreateNestedOneWithoutRoundsInput
    game: CallBreakGameCreateNestedOneWithoutRoundsInput
  }

  export type CallBreakRoundUncheckedCreateInput = {
    id?: string
    gameId: string
    dealId: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakRoundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: CallBreakDealUpdateOneRequiredWithoutRoundsNestedInput
    game?: CallBreakGameUpdateOneRequiredWithoutRoundsNestedInput
  }

  export type CallBreakRoundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakRoundCreateManyInput = {
    id?: string
    gameId: string
    dealId: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakRoundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakRoundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiteraturePlayerCreateInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerCreateManyInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
  }

  export type LiteraturePlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LiteraturePlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LiteratureTeamCreateInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    members?: LiteraturePlayerCreateNestedManyWithoutTeamInput
    game: LiteratureGameCreateNestedOneWithoutTeamsInput
  }

  export type LiteratureTeamUncheckedCreateInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    gameId: string
    members?: LiteraturePlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type LiteratureTeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    members?: LiteraturePlayerUpdateManyWithoutTeamNestedInput
    game?: LiteratureGameUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type LiteratureTeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    gameId?: StringFieldUpdateOperationsInput | string
    members?: LiteraturePlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type LiteratureTeamCreateManyInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    gameId: string
  }

  export type LiteratureTeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
  }

  export type LiteratureTeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingCreateInput = {
    cardId: string
    game: LiteratureGameCreateNestedOneWithoutCardMappingsInput
    player: LiteraturePlayerCreateNestedOneWithoutCardMappingsInput
  }

  export type LiteratureCardMappingUncheckedCreateInput = {
    cardId: string
    gameId: string
    playerId: string
  }

  export type LiteratureCardMappingUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutCardMappingsNestedInput
    player?: LiteraturePlayerUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type LiteratureCardMappingUncheckedUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingCreateManyInput = {
    cardId: string
    gameId: string
    playerId: string
  }

  export type LiteratureCardMappingUpdateManyMutationInput = {
    cardId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingUncheckedUpdateManyInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardLocationCreateInput = {
    cardId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
    game: LiteratureGameCreateNestedOneWithoutCardLocationsInput
    player: LiteraturePlayerCreateNestedOneWithoutCardLocationsInput
  }

  export type LiteratureCardLocationUncheckedCreateInput = {
    cardId: string
    gameId: string
    playerId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureCardLocationUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
    game?: LiteratureGameUpdateOneRequiredWithoutCardLocationsNestedInput
    player?: LiteraturePlayerUpdateOneRequiredWithoutCardLocationsNestedInput
  }

  export type LiteratureCardLocationUncheckedUpdateInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureCardLocationCreateManyInput = {
    cardId: string
    gameId: string
    playerId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureCardLocationUpdateManyMutationInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureCardLocationUncheckedUpdateManyInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureAskCreateInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
    game: LiteratureGameCreateNestedOneWithoutAsksInput
    player: LiteraturePlayerCreateNestedOneWithoutAsksInput
  }

  export type LiteratureAskUncheckedCreateInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureAskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutAsksNestedInput
    player?: LiteraturePlayerUpdateOneRequiredWithoutAsksNestedInput
  }

  export type LiteratureAskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureAskCreateManyInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureAskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureAskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCallCreateInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
    game: LiteratureGameCreateNestedOneWithoutCallsInput
    player: LiteraturePlayerCreateNestedOneWithoutCallsInput
  }

  export type LiteratureCallUncheckedCreateInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
    game?: LiteratureGameUpdateOneRequiredWithoutCallsNestedInput
    player?: LiteraturePlayerUpdateOneRequiredWithoutCallsNestedInput
  }

  export type LiteratureCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
  }

  export type LiteratureCallCreateManyInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
  }

  export type LiteratureCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
  }

  export type LiteratureTransferCreateInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
    game: LiteratureGameCreateNestedOneWithoutTransfersInput
    player: LiteraturePlayerCreateNestedOneWithoutTransfersInput
  }

  export type LiteratureTransferUncheckedCreateInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteratureTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutTransfersNestedInput
    player?: LiteraturePlayerUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type LiteratureTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureTransferCreateManyInput = {
    id?: string
    gameId: string
    playerId: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteratureTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureGameCreateInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameCreateManyInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
  }

  export type LiteratureGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
  }

  export type WordleGameCreateInput = {
    id?: string
    playerId: string
    wordLength?: number
    wordCount?: number
    words?: WordleGameCreatewordsInput | string[]
    guesses?: WordleGameCreateguessesInput | string[]
    completedWords?: WordleGameCreatecompletedWordsInput | string[]
  }

  export type WordleGameUncheckedCreateInput = {
    id?: string
    playerId: string
    wordLength?: number
    wordCount?: number
    words?: WordleGameCreatewordsInput | string[]
    guesses?: WordleGameCreateguessesInput | string[]
    completedWords?: WordleGameCreatecompletedWordsInput | string[]
  }

  export type WordleGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    wordLength?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    words?: WordleGameUpdatewordsInput | string[]
    guesses?: WordleGameUpdateguessesInput | string[]
    completedWords?: WordleGameUpdatecompletedWordsInput | string[]
  }

  export type WordleGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    wordLength?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    words?: WordleGameUpdatewordsInput | string[]
    guesses?: WordleGameUpdateguessesInput | string[]
    completedWords?: WordleGameUpdatecompletedWordsInput | string[]
  }

  export type WordleGameCreateManyInput = {
    id?: string
    playerId: string
    wordLength?: number
    wordCount?: number
    words?: WordleGameCreatewordsInput | string[]
    guesses?: WordleGameCreateguessesInput | string[]
    completedWords?: WordleGameCreatecompletedWordsInput | string[]
  }

  export type WordleGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    wordLength?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    words?: WordleGameUpdatewordsInput | string[]
    guesses?: WordleGameUpdateguessesInput | string[]
    completedWords?: WordleGameUpdatecompletedWordsInput | string[]
  }

  export type WordleGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    wordLength?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    words?: WordleGameUpdatewordsInput | string[]
    guesses?: WordleGameUpdateguessesInput | string[]
    completedWords?: WordleGameUpdatecompletedWordsInput | string[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    accountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    accountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    accountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCallBreakStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallBreakStatus | EnumCallBreakStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallBreakStatusFilter<$PrismaModel> | $Enums.CallBreakStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CallBreakPlayerListRelationFilter = {
    every?: CallBreakPlayerWhereInput
    some?: CallBreakPlayerWhereInput
    none?: CallBreakPlayerWhereInput
  }

  export type CallBreakDealListRelationFilter = {
    every?: CallBreakDealWhereInput
    some?: CallBreakDealWhereInput
    none?: CallBreakDealWhereInput
  }

  export type CallBreakCardMappingListRelationFilter = {
    every?: CallBreakCardMappingWhereInput
    some?: CallBreakCardMappingWhereInput
    none?: CallBreakCardMappingWhereInput
  }

  export type CallBreakRoundListRelationFilter = {
    every?: CallBreakRoundWhereInput
    some?: CallBreakRoundWhereInput
    none?: CallBreakRoundWhereInput
  }

  export type CallBreakPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallBreakDealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallBreakCardMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallBreakRoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallBreakGameCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dealCount?: SortOrder
    trumpSuit?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    scores?: SortOrder
  }

  export type CallBreakGameAvgOrderByAggregateInput = {
    dealCount?: SortOrder
  }

  export type CallBreakGameMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dealCount?: SortOrder
    trumpSuit?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
  }

  export type CallBreakGameMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dealCount?: SortOrder
    trumpSuit?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
  }

  export type CallBreakGameSumOrderByAggregateInput = {
    dealCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCallBreakStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallBreakStatus | EnumCallBreakStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallBreakStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallBreakStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallBreakStatusFilter<$PrismaModel>
    _max?: NestedEnumCallBreakStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CallBreakGameScalarRelationFilter = {
    is?: CallBreakGameWhereInput
    isNot?: CallBreakGameWhereInput
  }

  export type CallBreakPlayerIdGameIdCompoundUniqueInput = {
    id: string
    gameId: string
  }

  export type CallBreakPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    isBot?: SortOrder
  }

  export type CallBreakPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    isBot?: SortOrder
  }

  export type CallBreakPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    isBot?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CallBreakDealIdGameIdCompoundUniqueInput = {
    id: string
    gameId: string
  }

  export type CallBreakDealCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerOrder?: SortOrder
    declarations?: SortOrder
    wins?: SortOrder
    turnIdx?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakDealAvgOrderByAggregateInput = {
    turnIdx?: SortOrder
  }

  export type CallBreakDealMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    turnIdx?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakDealMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    turnIdx?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakDealSumOrderByAggregateInput = {
    turnIdx?: SortOrder
  }

  export type CallBreakDealScalarRelationFilter = {
    is?: CallBreakDealWhereInput
    isNot?: CallBreakDealWhereInput
  }

  export type CallBreakPlayerScalarRelationFilter = {
    is?: CallBreakPlayerWhereInput
    isNot?: CallBreakPlayerWhereInput
  }

  export type CallBreakCardMappingCardIdDealIdGameIdCompoundUniqueInput = {
    cardId: string
    dealId: string
    gameId: string
  }

  export type CallBreakCardMappingCountOrderByAggregateInput = {
    cardId?: SortOrder
    dealId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type CallBreakCardMappingMaxOrderByAggregateInput = {
    cardId?: SortOrder
    dealId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type CallBreakCardMappingMinOrderByAggregateInput = {
    cardId?: SortOrder
    dealId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type CallBreakRoundIdDealIdGameIdCompoundUniqueInput = {
    id: string
    dealId: string
    gameId: string
  }

  export type CallBreakRoundCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    dealId?: SortOrder
    winner?: SortOrder
    playerOrder?: SortOrder
    cards?: SortOrder
    turnIdx?: SortOrder
    suit?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakRoundAvgOrderByAggregateInput = {
    turnIdx?: SortOrder
  }

  export type CallBreakRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    dealId?: SortOrder
    winner?: SortOrder
    turnIdx?: SortOrder
    suit?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakRoundMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    dealId?: SortOrder
    winner?: SortOrder
    turnIdx?: SortOrder
    suit?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type CallBreakRoundSumOrderByAggregateInput = {
    turnIdx?: SortOrder
  }

  export type LiteratureGameScalarRelationFilter = {
    is?: LiteratureGameWhereInput
    isNot?: LiteratureGameWhereInput
  }

  export type LiteratureTeamNullableScalarRelationFilter = {
    is?: LiteratureTeamWhereInput | null
    isNot?: LiteratureTeamWhereInput | null
  }

  export type LiteratureCardMappingListRelationFilter = {
    every?: LiteratureCardMappingWhereInput
    some?: LiteratureCardMappingWhereInput
    none?: LiteratureCardMappingWhereInput
  }

  export type LiteratureCardLocationListRelationFilter = {
    every?: LiteratureCardLocationWhereInput
    some?: LiteratureCardLocationWhereInput
    none?: LiteratureCardLocationWhereInput
  }

  export type LiteratureAskListRelationFilter = {
    every?: LiteratureAskWhereInput
    some?: LiteratureAskWhereInput
    none?: LiteratureAskWhereInput
  }

  export type LiteratureCallListRelationFilter = {
    every?: LiteratureCallWhereInput
    some?: LiteratureCallWhereInput
    none?: LiteratureCallWhereInput
  }

  export type LiteratureTransferListRelationFilter = {
    every?: LiteratureTransferWhereInput
    some?: LiteratureTransferWhereInput
    none?: LiteratureTransferWhereInput
  }

  export type LiteratureCardMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureCardLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureAskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteraturePlayerIdGameIdCompoundUniqueInput = {
    id: string
    gameId: string
  }

  export type LiteraturePlayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    isBot?: SortOrder
  }

  export type LiteraturePlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    isBot?: SortOrder
  }

  export type LiteraturePlayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    isBot?: SortOrder
  }

  export type LiteraturePlayerListRelationFilter = {
    every?: LiteraturePlayerWhereInput
    some?: LiteraturePlayerWhereInput
    none?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureTeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    score?: SortOrder
    setsWon?: SortOrder
    memberIds?: SortOrder
    gameId?: SortOrder
  }

  export type LiteratureTeamAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type LiteratureTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    score?: SortOrder
    gameId?: SortOrder
  }

  export type LiteratureTeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    score?: SortOrder
    gameId?: SortOrder
  }

  export type LiteratureTeamSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type LiteraturePlayerScalarRelationFilter = {
    is?: LiteraturePlayerWhereInput
    isNot?: LiteraturePlayerWhereInput
  }

  export type LiteratureCardMappingGameIdCardIdCompoundUniqueInput = {
    gameId: string
    cardId: string
  }

  export type LiteratureCardMappingCountOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type LiteratureCardMappingMaxOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type LiteratureCardMappingMinOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
  }

  export type LiteratureCardLocationGameIdPlayerIdCardIdCompoundUniqueInput = {
    gameId: string
    playerId: string
    cardId: string
  }

  export type LiteratureCardLocationCountOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    playerIds?: SortOrder
    weight?: SortOrder
  }

  export type LiteratureCardLocationAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type LiteratureCardLocationMaxOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    weight?: SortOrder
  }

  export type LiteratureCardLocationMinOrderByAggregateInput = {
    cardId?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    weight?: SortOrder
  }

  export type LiteratureCardLocationSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type LiteratureAskCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardId?: SortOrder
    askedFrom?: SortOrder
  }

  export type LiteratureAskMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardId?: SortOrder
    askedFrom?: SortOrder
  }

  export type LiteratureAskMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardId?: SortOrder
    askedFrom?: SortOrder
  }

  export type LiteratureCallCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardSet?: SortOrder
    actualCall?: SortOrder
    correctCall?: SortOrder
  }

  export type LiteratureCallMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardSet?: SortOrder
  }

  export type LiteratureCallMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    cardSet?: SortOrder
  }

  export type LiteratureTransferCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    transferTo?: SortOrder
  }

  export type LiteratureTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    transferTo?: SortOrder
  }

  export type LiteratureTransferMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    playerId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    success?: SortOrder
    transferTo?: SortOrder
  }

  export type EnumLiteratureGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LiteratureGameStatus | EnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiteratureGameStatusFilter<$PrismaModel> | $Enums.LiteratureGameStatus
  }

  export type LiteratureTeamListRelationFilter = {
    every?: LiteratureTeamWhereInput
    some?: LiteratureTeamWhereInput
    none?: LiteratureTeamWhereInput
  }

  export type LiteratureTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiteratureGameCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    playerCount?: SortOrder
    currentTurn?: SortOrder
    lastMoveId?: SortOrder
  }

  export type LiteratureGameAvgOrderByAggregateInput = {
    playerCount?: SortOrder
  }

  export type LiteratureGameMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    playerCount?: SortOrder
    currentTurn?: SortOrder
    lastMoveId?: SortOrder
  }

  export type LiteratureGameMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    playerCount?: SortOrder
    currentTurn?: SortOrder
    lastMoveId?: SortOrder
  }

  export type LiteratureGameSumOrderByAggregateInput = {
    playerCount?: SortOrder
  }

  export type EnumLiteratureGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LiteratureGameStatus | EnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiteratureGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.LiteratureGameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiteratureGameStatusFilter<$PrismaModel>
    _max?: NestedEnumLiteratureGameStatusFilter<$PrismaModel>
  }

  export type WordleGameCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    wordLength?: SortOrder
    wordCount?: SortOrder
    words?: SortOrder
    guesses?: SortOrder
    completedWords?: SortOrder
  }

  export type WordleGameAvgOrderByAggregateInput = {
    wordLength?: SortOrder
    wordCount?: SortOrder
  }

  export type WordleGameMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    wordLength?: SortOrder
    wordCount?: SortOrder
  }

  export type WordleGameMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    wordLength?: SortOrder
    wordCount?: SortOrder
  }

  export type WordleGameSumOrderByAggregateInput = {
    wordLength?: SortOrder
    wordCount?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type CallBreakPlayerCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput> | CallBreakPlayerCreateWithoutGameInput[] | CallBreakPlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutGameInput | CallBreakPlayerCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakPlayerCreateManyGameInputEnvelope
    connect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
  }

  export type CallBreakDealCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput> | CallBreakDealCreateWithoutGameInput[] | CallBreakDealUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutGameInput | CallBreakDealCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakDealCreateManyGameInputEnvelope
    connect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
  }

  export type CallBreakCardMappingCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput> | CallBreakCardMappingCreateWithoutGameInput[] | CallBreakCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutGameInput | CallBreakCardMappingCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakCardMappingCreateManyGameInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakRoundCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput> | CallBreakRoundCreateWithoutGameInput[] | CallBreakRoundUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutGameInput | CallBreakRoundCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakRoundCreateManyGameInputEnvelope
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
  }

  export type CallBreakPlayerUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput> | CallBreakPlayerCreateWithoutGameInput[] | CallBreakPlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutGameInput | CallBreakPlayerCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakPlayerCreateManyGameInputEnvelope
    connect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
  }

  export type CallBreakDealUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput> | CallBreakDealCreateWithoutGameInput[] | CallBreakDealUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutGameInput | CallBreakDealCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakDealCreateManyGameInputEnvelope
    connect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
  }

  export type CallBreakCardMappingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput> | CallBreakCardMappingCreateWithoutGameInput[] | CallBreakCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutGameInput | CallBreakCardMappingCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakCardMappingCreateManyGameInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakRoundUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput> | CallBreakRoundCreateWithoutGameInput[] | CallBreakRoundUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutGameInput | CallBreakRoundCreateOrConnectWithoutGameInput[]
    createMany?: CallBreakRoundCreateManyGameInputEnvelope
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCallBreakStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallBreakStatus
  }

  export type CallBreakPlayerUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput> | CallBreakPlayerCreateWithoutGameInput[] | CallBreakPlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutGameInput | CallBreakPlayerCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakPlayerUpsertWithWhereUniqueWithoutGameInput | CallBreakPlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakPlayerCreateManyGameInputEnvelope
    set?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    disconnect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    delete?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    connect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    update?: CallBreakPlayerUpdateWithWhereUniqueWithoutGameInput | CallBreakPlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakPlayerUpdateManyWithWhereWithoutGameInput | CallBreakPlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakPlayerScalarWhereInput | CallBreakPlayerScalarWhereInput[]
  }

  export type CallBreakDealUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput> | CallBreakDealCreateWithoutGameInput[] | CallBreakDealUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutGameInput | CallBreakDealCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakDealUpsertWithWhereUniqueWithoutGameInput | CallBreakDealUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakDealCreateManyGameInputEnvelope
    set?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    disconnect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    delete?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    connect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    update?: CallBreakDealUpdateWithWhereUniqueWithoutGameInput | CallBreakDealUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakDealUpdateManyWithWhereWithoutGameInput | CallBreakDealUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakDealScalarWhereInput | CallBreakDealScalarWhereInput[]
  }

  export type CallBreakCardMappingUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput> | CallBreakCardMappingCreateWithoutGameInput[] | CallBreakCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutGameInput | CallBreakCardMappingCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutGameInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakCardMappingCreateManyGameInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutGameInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutGameInput | CallBreakCardMappingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakRoundUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput> | CallBreakRoundCreateWithoutGameInput[] | CallBreakRoundUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutGameInput | CallBreakRoundCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakRoundUpsertWithWhereUniqueWithoutGameInput | CallBreakRoundUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakRoundCreateManyGameInputEnvelope
    set?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    disconnect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    delete?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    update?: CallBreakRoundUpdateWithWhereUniqueWithoutGameInput | CallBreakRoundUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakRoundUpdateManyWithWhereWithoutGameInput | CallBreakRoundUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
  }

  export type CallBreakPlayerUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput> | CallBreakPlayerCreateWithoutGameInput[] | CallBreakPlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutGameInput | CallBreakPlayerCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakPlayerUpsertWithWhereUniqueWithoutGameInput | CallBreakPlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakPlayerCreateManyGameInputEnvelope
    set?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    disconnect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    delete?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    connect?: CallBreakPlayerWhereUniqueInput | CallBreakPlayerWhereUniqueInput[]
    update?: CallBreakPlayerUpdateWithWhereUniqueWithoutGameInput | CallBreakPlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakPlayerUpdateManyWithWhereWithoutGameInput | CallBreakPlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakPlayerScalarWhereInput | CallBreakPlayerScalarWhereInput[]
  }

  export type CallBreakDealUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput> | CallBreakDealCreateWithoutGameInput[] | CallBreakDealUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutGameInput | CallBreakDealCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakDealUpsertWithWhereUniqueWithoutGameInput | CallBreakDealUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakDealCreateManyGameInputEnvelope
    set?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    disconnect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    delete?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    connect?: CallBreakDealWhereUniqueInput | CallBreakDealWhereUniqueInput[]
    update?: CallBreakDealUpdateWithWhereUniqueWithoutGameInput | CallBreakDealUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakDealUpdateManyWithWhereWithoutGameInput | CallBreakDealUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakDealScalarWhereInput | CallBreakDealScalarWhereInput[]
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput> | CallBreakCardMappingCreateWithoutGameInput[] | CallBreakCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutGameInput | CallBreakCardMappingCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutGameInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakCardMappingCreateManyGameInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutGameInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutGameInput | CallBreakCardMappingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakRoundUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput> | CallBreakRoundCreateWithoutGameInput[] | CallBreakRoundUncheckedCreateWithoutGameInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutGameInput | CallBreakRoundCreateOrConnectWithoutGameInput[]
    upsert?: CallBreakRoundUpsertWithWhereUniqueWithoutGameInput | CallBreakRoundUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: CallBreakRoundCreateManyGameInputEnvelope
    set?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    disconnect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    delete?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    update?: CallBreakRoundUpdateWithWhereUniqueWithoutGameInput | CallBreakRoundUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: CallBreakRoundUpdateManyWithWhereWithoutGameInput | CallBreakRoundUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
  }

  export type CallBreakGameCreateNestedOneWithoutPlayersInput = {
    create?: XOR<CallBreakGameCreateWithoutPlayersInput, CallBreakGameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutPlayersInput
    connect?: CallBreakGameWhereUniqueInput
  }

  export type CallBreakCardMappingCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput> | CallBreakCardMappingCreateWithoutPlayerInput[] | CallBreakCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutPlayerInput | CallBreakCardMappingCreateOrConnectWithoutPlayerInput[]
    createMany?: CallBreakCardMappingCreateManyPlayerInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakCardMappingUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput> | CallBreakCardMappingCreateWithoutPlayerInput[] | CallBreakCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutPlayerInput | CallBreakCardMappingCreateOrConnectWithoutPlayerInput[]
    createMany?: CallBreakCardMappingCreateManyPlayerInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakGameUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<CallBreakGameCreateWithoutPlayersInput, CallBreakGameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutPlayersInput
    upsert?: CallBreakGameUpsertWithoutPlayersInput
    connect?: CallBreakGameWhereUniqueInput
    update?: XOR<XOR<CallBreakGameUpdateToOneWithWhereWithoutPlayersInput, CallBreakGameUpdateWithoutPlayersInput>, CallBreakGameUncheckedUpdateWithoutPlayersInput>
  }

  export type CallBreakCardMappingUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput> | CallBreakCardMappingCreateWithoutPlayerInput[] | CallBreakCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutPlayerInput | CallBreakCardMappingCreateOrConnectWithoutPlayerInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutPlayerInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CallBreakCardMappingCreateManyPlayerInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutPlayerInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutPlayerInput | CallBreakCardMappingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput> | CallBreakCardMappingCreateWithoutPlayerInput[] | CallBreakCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutPlayerInput | CallBreakCardMappingCreateOrConnectWithoutPlayerInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutPlayerInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CallBreakCardMappingCreateManyPlayerInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutPlayerInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutPlayerInput | CallBreakCardMappingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakDealCreateplayerOrderInput = {
    set: string[]
  }

  export type CallBreakGameCreateNestedOneWithoutDealsInput = {
    create?: XOR<CallBreakGameCreateWithoutDealsInput, CallBreakGameUncheckedCreateWithoutDealsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutDealsInput
    connect?: CallBreakGameWhereUniqueInput
  }

  export type CallBreakCardMappingCreateNestedManyWithoutDealInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput> | CallBreakCardMappingCreateWithoutDealInput[] | CallBreakCardMappingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutDealInput | CallBreakCardMappingCreateOrConnectWithoutDealInput[]
    createMany?: CallBreakCardMappingCreateManyDealInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakRoundCreateNestedManyWithoutDealInput = {
    create?: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput> | CallBreakRoundCreateWithoutDealInput[] | CallBreakRoundUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutDealInput | CallBreakRoundCreateOrConnectWithoutDealInput[]
    createMany?: CallBreakRoundCreateManyDealInputEnvelope
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
  }

  export type CallBreakCardMappingUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput> | CallBreakCardMappingCreateWithoutDealInput[] | CallBreakCardMappingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutDealInput | CallBreakCardMappingCreateOrConnectWithoutDealInput[]
    createMany?: CallBreakCardMappingCreateManyDealInputEnvelope
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
  }

  export type CallBreakRoundUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput> | CallBreakRoundCreateWithoutDealInput[] | CallBreakRoundUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutDealInput | CallBreakRoundCreateOrConnectWithoutDealInput[]
    createMany?: CallBreakRoundCreateManyDealInputEnvelope
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
  }

  export type CallBreakDealUpdateplayerOrderInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CallBreakGameUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<CallBreakGameCreateWithoutDealsInput, CallBreakGameUncheckedCreateWithoutDealsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutDealsInput
    upsert?: CallBreakGameUpsertWithoutDealsInput
    connect?: CallBreakGameWhereUniqueInput
    update?: XOR<XOR<CallBreakGameUpdateToOneWithWhereWithoutDealsInput, CallBreakGameUpdateWithoutDealsInput>, CallBreakGameUncheckedUpdateWithoutDealsInput>
  }

  export type CallBreakCardMappingUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput> | CallBreakCardMappingCreateWithoutDealInput[] | CallBreakCardMappingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutDealInput | CallBreakCardMappingCreateOrConnectWithoutDealInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutDealInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallBreakCardMappingCreateManyDealInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutDealInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutDealInput | CallBreakCardMappingUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakRoundUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput> | CallBreakRoundCreateWithoutDealInput[] | CallBreakRoundUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutDealInput | CallBreakRoundCreateOrConnectWithoutDealInput[]
    upsert?: CallBreakRoundUpsertWithWhereUniqueWithoutDealInput | CallBreakRoundUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallBreakRoundCreateManyDealInputEnvelope
    set?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    disconnect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    delete?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    update?: CallBreakRoundUpdateWithWhereUniqueWithoutDealInput | CallBreakRoundUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallBreakRoundUpdateManyWithWhereWithoutDealInput | CallBreakRoundUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput> | CallBreakCardMappingCreateWithoutDealInput[] | CallBreakCardMappingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakCardMappingCreateOrConnectWithoutDealInput | CallBreakCardMappingCreateOrConnectWithoutDealInput[]
    upsert?: CallBreakCardMappingUpsertWithWhereUniqueWithoutDealInput | CallBreakCardMappingUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallBreakCardMappingCreateManyDealInputEnvelope
    set?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    disconnect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    delete?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    connect?: CallBreakCardMappingWhereUniqueInput | CallBreakCardMappingWhereUniqueInput[]
    update?: CallBreakCardMappingUpdateWithWhereUniqueWithoutDealInput | CallBreakCardMappingUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallBreakCardMappingUpdateManyWithWhereWithoutDealInput | CallBreakCardMappingUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
  }

  export type CallBreakRoundUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput> | CallBreakRoundCreateWithoutDealInput[] | CallBreakRoundUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallBreakRoundCreateOrConnectWithoutDealInput | CallBreakRoundCreateOrConnectWithoutDealInput[]
    upsert?: CallBreakRoundUpsertWithWhereUniqueWithoutDealInput | CallBreakRoundUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallBreakRoundCreateManyDealInputEnvelope
    set?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    disconnect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    delete?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    connect?: CallBreakRoundWhereUniqueInput | CallBreakRoundWhereUniqueInput[]
    update?: CallBreakRoundUpdateWithWhereUniqueWithoutDealInput | CallBreakRoundUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallBreakRoundUpdateManyWithWhereWithoutDealInput | CallBreakRoundUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
  }

  export type CallBreakDealCreateNestedOneWithoutCardMappingsInput = {
    create?: XOR<CallBreakDealCreateWithoutCardMappingsInput, CallBreakDealUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutCardMappingsInput
    connect?: CallBreakDealWhereUniqueInput
  }

  export type CallBreakGameCreateNestedOneWithoutCardMappingsInput = {
    create?: XOR<CallBreakGameCreateWithoutCardMappingsInput, CallBreakGameUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutCardMappingsInput
    connect?: CallBreakGameWhereUniqueInput
  }

  export type CallBreakPlayerCreateNestedOneWithoutCardMappingsInput = {
    create?: XOR<CallBreakPlayerCreateWithoutCardMappingsInput, CallBreakPlayerUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutCardMappingsInput
    connect?: CallBreakPlayerWhereUniqueInput
  }

  export type CallBreakDealUpdateOneRequiredWithoutCardMappingsNestedInput = {
    create?: XOR<CallBreakDealCreateWithoutCardMappingsInput, CallBreakDealUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutCardMappingsInput
    upsert?: CallBreakDealUpsertWithoutCardMappingsInput
    connect?: CallBreakDealWhereUniqueInput
    update?: XOR<XOR<CallBreakDealUpdateToOneWithWhereWithoutCardMappingsInput, CallBreakDealUpdateWithoutCardMappingsInput>, CallBreakDealUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakGameUpdateOneRequiredWithoutCardMappingsNestedInput = {
    create?: XOR<CallBreakGameCreateWithoutCardMappingsInput, CallBreakGameUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutCardMappingsInput
    upsert?: CallBreakGameUpsertWithoutCardMappingsInput
    connect?: CallBreakGameWhereUniqueInput
    update?: XOR<XOR<CallBreakGameUpdateToOneWithWhereWithoutCardMappingsInput, CallBreakGameUpdateWithoutCardMappingsInput>, CallBreakGameUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakPlayerUpdateOneRequiredWithoutCardMappingsNestedInput = {
    create?: XOR<CallBreakPlayerCreateWithoutCardMappingsInput, CallBreakPlayerUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: CallBreakPlayerCreateOrConnectWithoutCardMappingsInput
    upsert?: CallBreakPlayerUpsertWithoutCardMappingsInput
    connect?: CallBreakPlayerWhereUniqueInput
    update?: XOR<XOR<CallBreakPlayerUpdateToOneWithWhereWithoutCardMappingsInput, CallBreakPlayerUpdateWithoutCardMappingsInput>, CallBreakPlayerUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakRoundCreateplayerOrderInput = {
    set: string[]
  }

  export type CallBreakDealCreateNestedOneWithoutRoundsInput = {
    create?: XOR<CallBreakDealCreateWithoutRoundsInput, CallBreakDealUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutRoundsInput
    connect?: CallBreakDealWhereUniqueInput
  }

  export type CallBreakGameCreateNestedOneWithoutRoundsInput = {
    create?: XOR<CallBreakGameCreateWithoutRoundsInput, CallBreakGameUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutRoundsInput
    connect?: CallBreakGameWhereUniqueInput
  }

  export type CallBreakRoundUpdateplayerOrderInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CallBreakDealUpdateOneRequiredWithoutRoundsNestedInput = {
    create?: XOR<CallBreakDealCreateWithoutRoundsInput, CallBreakDealUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: CallBreakDealCreateOrConnectWithoutRoundsInput
    upsert?: CallBreakDealUpsertWithoutRoundsInput
    connect?: CallBreakDealWhereUniqueInput
    update?: XOR<XOR<CallBreakDealUpdateToOneWithWhereWithoutRoundsInput, CallBreakDealUpdateWithoutRoundsInput>, CallBreakDealUncheckedUpdateWithoutRoundsInput>
  }

  export type CallBreakGameUpdateOneRequiredWithoutRoundsNestedInput = {
    create?: XOR<CallBreakGameCreateWithoutRoundsInput, CallBreakGameUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: CallBreakGameCreateOrConnectWithoutRoundsInput
    upsert?: CallBreakGameUpsertWithoutRoundsInput
    connect?: CallBreakGameWhereUniqueInput
    update?: XOR<XOR<CallBreakGameUpdateToOneWithWhereWithoutRoundsInput, CallBreakGameUpdateWithoutRoundsInput>, CallBreakGameUncheckedUpdateWithoutRoundsInput>
  }

  export type LiteratureGameCreateNestedOneWithoutPlayersInput = {
    create?: XOR<LiteratureGameCreateWithoutPlayersInput, LiteratureGameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutPlayersInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteratureTeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<LiteratureTeamCreateWithoutMembersInput, LiteratureTeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutMembersInput
    connect?: LiteratureTeamWhereUniqueInput
  }

  export type LiteratureCardMappingCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput> | LiteratureCardMappingCreateWithoutPlayerInput[] | LiteratureCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutPlayerInput | LiteratureCardMappingCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCardMappingCreateManyPlayerInputEnvelope
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
  }

  export type LiteratureCardLocationCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput> | LiteratureCardLocationCreateWithoutPlayerInput[] | LiteratureCardLocationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutPlayerInput | LiteratureCardLocationCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCardLocationCreateManyPlayerInputEnvelope
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
  }

  export type LiteratureAskCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput> | LiteratureAskCreateWithoutPlayerInput[] | LiteratureAskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutPlayerInput | LiteratureAskCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureAskCreateManyPlayerInputEnvelope
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
  }

  export type LiteratureCallCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput> | LiteratureCallCreateWithoutPlayerInput[] | LiteratureCallUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutPlayerInput | LiteratureCallCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCallCreateManyPlayerInputEnvelope
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
  }

  export type LiteratureTransferCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput> | LiteratureTransferCreateWithoutPlayerInput[] | LiteratureTransferUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutPlayerInput | LiteratureTransferCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureTransferCreateManyPlayerInputEnvelope
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
  }

  export type LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput> | LiteratureCardMappingCreateWithoutPlayerInput[] | LiteratureCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutPlayerInput | LiteratureCardMappingCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCardMappingCreateManyPlayerInputEnvelope
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
  }

  export type LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput> | LiteratureCardLocationCreateWithoutPlayerInput[] | LiteratureCardLocationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutPlayerInput | LiteratureCardLocationCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCardLocationCreateManyPlayerInputEnvelope
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
  }

  export type LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput> | LiteratureAskCreateWithoutPlayerInput[] | LiteratureAskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutPlayerInput | LiteratureAskCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureAskCreateManyPlayerInputEnvelope
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
  }

  export type LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput> | LiteratureCallCreateWithoutPlayerInput[] | LiteratureCallUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutPlayerInput | LiteratureCallCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureCallCreateManyPlayerInputEnvelope
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
  }

  export type LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput> | LiteratureTransferCreateWithoutPlayerInput[] | LiteratureTransferUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutPlayerInput | LiteratureTransferCreateOrConnectWithoutPlayerInput[]
    createMany?: LiteratureTransferCreateManyPlayerInputEnvelope
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
  }

  export type LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutPlayersInput, LiteratureGameUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutPlayersInput
    upsert?: LiteratureGameUpsertWithoutPlayersInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutPlayersInput, LiteratureGameUpdateWithoutPlayersInput>, LiteratureGameUncheckedUpdateWithoutPlayersInput>
  }

  export type LiteratureTeamUpdateOneWithoutMembersNestedInput = {
    create?: XOR<LiteratureTeamCreateWithoutMembersInput, LiteratureTeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutMembersInput
    upsert?: LiteratureTeamUpsertWithoutMembersInput
    disconnect?: LiteratureTeamWhereInput | boolean
    delete?: LiteratureTeamWhereInput | boolean
    connect?: LiteratureTeamWhereUniqueInput
    update?: XOR<XOR<LiteratureTeamUpdateToOneWithWhereWithoutMembersInput, LiteratureTeamUpdateWithoutMembersInput>, LiteratureTeamUncheckedUpdateWithoutMembersInput>
  }

  export type LiteratureCardMappingUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput> | LiteratureCardMappingCreateWithoutPlayerInput[] | LiteratureCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutPlayerInput | LiteratureCardMappingCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCardMappingUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCardMappingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCardMappingCreateManyPlayerInputEnvelope
    set?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    disconnect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    delete?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    update?: LiteratureCardMappingUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCardMappingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCardMappingUpdateManyWithWhereWithoutPlayerInput | LiteratureCardMappingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
  }

  export type LiteratureCardLocationUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput> | LiteratureCardLocationCreateWithoutPlayerInput[] | LiteratureCardLocationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutPlayerInput | LiteratureCardLocationCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCardLocationUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCardLocationUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCardLocationCreateManyPlayerInputEnvelope
    set?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    disconnect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    delete?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    update?: LiteratureCardLocationUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCardLocationUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCardLocationUpdateManyWithWhereWithoutPlayerInput | LiteratureCardLocationUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
  }

  export type LiteratureAskUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput> | LiteratureAskCreateWithoutPlayerInput[] | LiteratureAskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutPlayerInput | LiteratureAskCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureAskUpsertWithWhereUniqueWithoutPlayerInput | LiteratureAskUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureAskCreateManyPlayerInputEnvelope
    set?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    disconnect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    delete?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    update?: LiteratureAskUpdateWithWhereUniqueWithoutPlayerInput | LiteratureAskUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureAskUpdateManyWithWhereWithoutPlayerInput | LiteratureAskUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
  }

  export type LiteratureCallUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput> | LiteratureCallCreateWithoutPlayerInput[] | LiteratureCallUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutPlayerInput | LiteratureCallCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCallUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCallUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCallCreateManyPlayerInputEnvelope
    set?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    disconnect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    delete?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    update?: LiteratureCallUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCallUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCallUpdateManyWithWhereWithoutPlayerInput | LiteratureCallUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
  }

  export type LiteratureTransferUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput> | LiteratureTransferCreateWithoutPlayerInput[] | LiteratureTransferUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutPlayerInput | LiteratureTransferCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureTransferUpsertWithWhereUniqueWithoutPlayerInput | LiteratureTransferUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureTransferCreateManyPlayerInputEnvelope
    set?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    disconnect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    delete?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    update?: LiteratureTransferUpdateWithWhereUniqueWithoutPlayerInput | LiteratureTransferUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureTransferUpdateManyWithWhereWithoutPlayerInput | LiteratureTransferUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
  }

  export type LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput> | LiteratureCardMappingCreateWithoutPlayerInput[] | LiteratureCardMappingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutPlayerInput | LiteratureCardMappingCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCardMappingUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCardMappingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCardMappingCreateManyPlayerInputEnvelope
    set?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    disconnect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    delete?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    update?: LiteratureCardMappingUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCardMappingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCardMappingUpdateManyWithWhereWithoutPlayerInput | LiteratureCardMappingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
  }

  export type LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput> | LiteratureCardLocationCreateWithoutPlayerInput[] | LiteratureCardLocationUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutPlayerInput | LiteratureCardLocationCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCardLocationUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCardLocationUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCardLocationCreateManyPlayerInputEnvelope
    set?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    disconnect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    delete?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    update?: LiteratureCardLocationUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCardLocationUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCardLocationUpdateManyWithWhereWithoutPlayerInput | LiteratureCardLocationUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
  }

  export type LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput> | LiteratureAskCreateWithoutPlayerInput[] | LiteratureAskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutPlayerInput | LiteratureAskCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureAskUpsertWithWhereUniqueWithoutPlayerInput | LiteratureAskUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureAskCreateManyPlayerInputEnvelope
    set?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    disconnect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    delete?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    update?: LiteratureAskUpdateWithWhereUniqueWithoutPlayerInput | LiteratureAskUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureAskUpdateManyWithWhereWithoutPlayerInput | LiteratureAskUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
  }

  export type LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput> | LiteratureCallCreateWithoutPlayerInput[] | LiteratureCallUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutPlayerInput | LiteratureCallCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureCallUpsertWithWhereUniqueWithoutPlayerInput | LiteratureCallUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureCallCreateManyPlayerInputEnvelope
    set?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    disconnect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    delete?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    update?: LiteratureCallUpdateWithWhereUniqueWithoutPlayerInput | LiteratureCallUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureCallUpdateManyWithWhereWithoutPlayerInput | LiteratureCallUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
  }

  export type LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput> | LiteratureTransferCreateWithoutPlayerInput[] | LiteratureTransferUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutPlayerInput | LiteratureTransferCreateOrConnectWithoutPlayerInput[]
    upsert?: LiteratureTransferUpsertWithWhereUniqueWithoutPlayerInput | LiteratureTransferUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: LiteratureTransferCreateManyPlayerInputEnvelope
    set?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    disconnect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    delete?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    update?: LiteratureTransferUpdateWithWhereUniqueWithoutPlayerInput | LiteratureTransferUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: LiteratureTransferUpdateManyWithWhereWithoutPlayerInput | LiteratureTransferUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
  }

  export type LiteratureTeamCreatesetsWonInput = {
    set: string[]
  }

  export type LiteratureTeamCreatememberIdsInput = {
    set: string[]
  }

  export type LiteraturePlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput> | LiteraturePlayerCreateWithoutTeamInput[] | LiteraturePlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTeamInput | LiteraturePlayerCreateOrConnectWithoutTeamInput[]
    createMany?: LiteraturePlayerCreateManyTeamInputEnvelope
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
  }

  export type LiteratureGameCreateNestedOneWithoutTeamsInput = {
    create?: XOR<LiteratureGameCreateWithoutTeamsInput, LiteratureGameUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutTeamsInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput> | LiteraturePlayerCreateWithoutTeamInput[] | LiteraturePlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTeamInput | LiteraturePlayerCreateOrConnectWithoutTeamInput[]
    createMany?: LiteraturePlayerCreateManyTeamInputEnvelope
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
  }

  export type LiteratureTeamUpdatesetsWonInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LiteratureTeamUpdatememberIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LiteraturePlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput> | LiteraturePlayerCreateWithoutTeamInput[] | LiteraturePlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTeamInput | LiteraturePlayerCreateOrConnectWithoutTeamInput[]
    upsert?: LiteraturePlayerUpsertWithWhereUniqueWithoutTeamInput | LiteraturePlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: LiteraturePlayerCreateManyTeamInputEnvelope
    set?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    disconnect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    delete?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    update?: LiteraturePlayerUpdateWithWhereUniqueWithoutTeamInput | LiteraturePlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: LiteraturePlayerUpdateManyWithWhereWithoutTeamInput | LiteraturePlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
  }

  export type LiteratureGameUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutTeamsInput, LiteratureGameUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutTeamsInput
    upsert?: LiteratureGameUpsertWithoutTeamsInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutTeamsInput, LiteratureGameUpdateWithoutTeamsInput>, LiteratureGameUncheckedUpdateWithoutTeamsInput>
  }

  export type LiteraturePlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput> | LiteraturePlayerCreateWithoutTeamInput[] | LiteraturePlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTeamInput | LiteraturePlayerCreateOrConnectWithoutTeamInput[]
    upsert?: LiteraturePlayerUpsertWithWhereUniqueWithoutTeamInput | LiteraturePlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: LiteraturePlayerCreateManyTeamInputEnvelope
    set?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    disconnect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    delete?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    update?: LiteraturePlayerUpdateWithWhereUniqueWithoutTeamInput | LiteraturePlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: LiteraturePlayerUpdateManyWithWhereWithoutTeamInput | LiteraturePlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
  }

  export type LiteratureGameCreateNestedOneWithoutCardMappingsInput = {
    create?: XOR<LiteratureGameCreateWithoutCardMappingsInput, LiteratureGameUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCardMappingsInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerCreateNestedOneWithoutCardMappingsInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCardMappingsInput, LiteraturePlayerUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCardMappingsInput
    connect?: LiteraturePlayerWhereUniqueInput
  }

  export type LiteratureGameUpdateOneRequiredWithoutCardMappingsNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutCardMappingsInput, LiteratureGameUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCardMappingsInput
    upsert?: LiteratureGameUpsertWithoutCardMappingsInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutCardMappingsInput, LiteratureGameUpdateWithoutCardMappingsInput>, LiteratureGameUncheckedUpdateWithoutCardMappingsInput>
  }

  export type LiteraturePlayerUpdateOneRequiredWithoutCardMappingsNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCardMappingsInput, LiteraturePlayerUncheckedCreateWithoutCardMappingsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCardMappingsInput
    upsert?: LiteraturePlayerUpsertWithoutCardMappingsInput
    connect?: LiteraturePlayerWhereUniqueInput
    update?: XOR<XOR<LiteraturePlayerUpdateToOneWithWhereWithoutCardMappingsInput, LiteraturePlayerUpdateWithoutCardMappingsInput>, LiteraturePlayerUncheckedUpdateWithoutCardMappingsInput>
  }

  export type LiteratureCardLocationCreateplayerIdsInput = {
    set: string[]
  }

  export type LiteratureGameCreateNestedOneWithoutCardLocationsInput = {
    create?: XOR<LiteratureGameCreateWithoutCardLocationsInput, LiteratureGameUncheckedCreateWithoutCardLocationsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCardLocationsInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerCreateNestedOneWithoutCardLocationsInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCardLocationsInput, LiteraturePlayerUncheckedCreateWithoutCardLocationsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCardLocationsInput
    connect?: LiteraturePlayerWhereUniqueInput
  }

  export type LiteratureCardLocationUpdateplayerIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LiteratureGameUpdateOneRequiredWithoutCardLocationsNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutCardLocationsInput, LiteratureGameUncheckedCreateWithoutCardLocationsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCardLocationsInput
    upsert?: LiteratureGameUpsertWithoutCardLocationsInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutCardLocationsInput, LiteratureGameUpdateWithoutCardLocationsInput>, LiteratureGameUncheckedUpdateWithoutCardLocationsInput>
  }

  export type LiteraturePlayerUpdateOneRequiredWithoutCardLocationsNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCardLocationsInput, LiteraturePlayerUncheckedCreateWithoutCardLocationsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCardLocationsInput
    upsert?: LiteraturePlayerUpsertWithoutCardLocationsInput
    connect?: LiteraturePlayerWhereUniqueInput
    update?: XOR<XOR<LiteraturePlayerUpdateToOneWithWhereWithoutCardLocationsInput, LiteraturePlayerUpdateWithoutCardLocationsInput>, LiteraturePlayerUncheckedUpdateWithoutCardLocationsInput>
  }

  export type LiteratureGameCreateNestedOneWithoutAsksInput = {
    create?: XOR<LiteratureGameCreateWithoutAsksInput, LiteratureGameUncheckedCreateWithoutAsksInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutAsksInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerCreateNestedOneWithoutAsksInput = {
    create?: XOR<LiteraturePlayerCreateWithoutAsksInput, LiteraturePlayerUncheckedCreateWithoutAsksInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutAsksInput
    connect?: LiteraturePlayerWhereUniqueInput
  }

  export type LiteratureGameUpdateOneRequiredWithoutAsksNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutAsksInput, LiteratureGameUncheckedCreateWithoutAsksInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutAsksInput
    upsert?: LiteratureGameUpsertWithoutAsksInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutAsksInput, LiteratureGameUpdateWithoutAsksInput>, LiteratureGameUncheckedUpdateWithoutAsksInput>
  }

  export type LiteraturePlayerUpdateOneRequiredWithoutAsksNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutAsksInput, LiteraturePlayerUncheckedCreateWithoutAsksInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutAsksInput
    upsert?: LiteraturePlayerUpsertWithoutAsksInput
    connect?: LiteraturePlayerWhereUniqueInput
    update?: XOR<XOR<LiteraturePlayerUpdateToOneWithWhereWithoutAsksInput, LiteraturePlayerUpdateWithoutAsksInput>, LiteraturePlayerUncheckedUpdateWithoutAsksInput>
  }

  export type LiteratureGameCreateNestedOneWithoutCallsInput = {
    create?: XOR<LiteratureGameCreateWithoutCallsInput, LiteratureGameUncheckedCreateWithoutCallsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCallsInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerCreateNestedOneWithoutCallsInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCallsInput, LiteraturePlayerUncheckedCreateWithoutCallsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCallsInput
    connect?: LiteraturePlayerWhereUniqueInput
  }

  export type LiteratureGameUpdateOneRequiredWithoutCallsNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutCallsInput, LiteratureGameUncheckedCreateWithoutCallsInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutCallsInput
    upsert?: LiteratureGameUpsertWithoutCallsInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutCallsInput, LiteratureGameUpdateWithoutCallsInput>, LiteratureGameUncheckedUpdateWithoutCallsInput>
  }

  export type LiteraturePlayerUpdateOneRequiredWithoutCallsNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutCallsInput, LiteraturePlayerUncheckedCreateWithoutCallsInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutCallsInput
    upsert?: LiteraturePlayerUpsertWithoutCallsInput
    connect?: LiteraturePlayerWhereUniqueInput
    update?: XOR<XOR<LiteraturePlayerUpdateToOneWithWhereWithoutCallsInput, LiteraturePlayerUpdateWithoutCallsInput>, LiteraturePlayerUncheckedUpdateWithoutCallsInput>
  }

  export type LiteratureGameCreateNestedOneWithoutTransfersInput = {
    create?: XOR<LiteratureGameCreateWithoutTransfersInput, LiteratureGameUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutTransfersInput
    connect?: LiteratureGameWhereUniqueInput
  }

  export type LiteraturePlayerCreateNestedOneWithoutTransfersInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTransfersInput, LiteraturePlayerUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTransfersInput
    connect?: LiteraturePlayerWhereUniqueInput
  }

  export type LiteratureGameUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<LiteratureGameCreateWithoutTransfersInput, LiteratureGameUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LiteratureGameCreateOrConnectWithoutTransfersInput
    upsert?: LiteratureGameUpsertWithoutTransfersInput
    connect?: LiteratureGameWhereUniqueInput
    update?: XOR<XOR<LiteratureGameUpdateToOneWithWhereWithoutTransfersInput, LiteratureGameUpdateWithoutTransfersInput>, LiteratureGameUncheckedUpdateWithoutTransfersInput>
  }

  export type LiteraturePlayerUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutTransfersInput, LiteraturePlayerUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutTransfersInput
    upsert?: LiteraturePlayerUpsertWithoutTransfersInput
    connect?: LiteraturePlayerWhereUniqueInput
    update?: XOR<XOR<LiteraturePlayerUpdateToOneWithWhereWithoutTransfersInput, LiteraturePlayerUpdateWithoutTransfersInput>, LiteraturePlayerUncheckedUpdateWithoutTransfersInput>
  }

  export type LiteraturePlayerCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput> | LiteraturePlayerCreateWithoutGameInput[] | LiteraturePlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutGameInput | LiteraturePlayerCreateOrConnectWithoutGameInput[]
    createMany?: LiteraturePlayerCreateManyGameInputEnvelope
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
  }

  export type LiteratureTeamCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput> | LiteratureTeamCreateWithoutGameInput[] | LiteratureTeamUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutGameInput | LiteratureTeamCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureTeamCreateManyGameInputEnvelope
    connect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
  }

  export type LiteratureCardMappingCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput> | LiteratureCardMappingCreateWithoutGameInput[] | LiteratureCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutGameInput | LiteratureCardMappingCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCardMappingCreateManyGameInputEnvelope
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
  }

  export type LiteratureCardLocationCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput> | LiteratureCardLocationCreateWithoutGameInput[] | LiteratureCardLocationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutGameInput | LiteratureCardLocationCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCardLocationCreateManyGameInputEnvelope
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
  }

  export type LiteratureAskCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput> | LiteratureAskCreateWithoutGameInput[] | LiteratureAskUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutGameInput | LiteratureAskCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureAskCreateManyGameInputEnvelope
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
  }

  export type LiteratureCallCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput> | LiteratureCallCreateWithoutGameInput[] | LiteratureCallUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutGameInput | LiteratureCallCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCallCreateManyGameInputEnvelope
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
  }

  export type LiteratureTransferCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput> | LiteratureTransferCreateWithoutGameInput[] | LiteratureTransferUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutGameInput | LiteratureTransferCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureTransferCreateManyGameInputEnvelope
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
  }

  export type LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput> | LiteraturePlayerCreateWithoutGameInput[] | LiteraturePlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutGameInput | LiteraturePlayerCreateOrConnectWithoutGameInput[]
    createMany?: LiteraturePlayerCreateManyGameInputEnvelope
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
  }

  export type LiteratureTeamUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput> | LiteratureTeamCreateWithoutGameInput[] | LiteratureTeamUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutGameInput | LiteratureTeamCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureTeamCreateManyGameInputEnvelope
    connect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
  }

  export type LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput> | LiteratureCardMappingCreateWithoutGameInput[] | LiteratureCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutGameInput | LiteratureCardMappingCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCardMappingCreateManyGameInputEnvelope
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
  }

  export type LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput> | LiteratureCardLocationCreateWithoutGameInput[] | LiteratureCardLocationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutGameInput | LiteratureCardLocationCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCardLocationCreateManyGameInputEnvelope
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
  }

  export type LiteratureAskUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput> | LiteratureAskCreateWithoutGameInput[] | LiteratureAskUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutGameInput | LiteratureAskCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureAskCreateManyGameInputEnvelope
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
  }

  export type LiteratureCallUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput> | LiteratureCallCreateWithoutGameInput[] | LiteratureCallUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutGameInput | LiteratureCallCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureCallCreateManyGameInputEnvelope
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
  }

  export type LiteratureTransferUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput> | LiteratureTransferCreateWithoutGameInput[] | LiteratureTransferUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutGameInput | LiteratureTransferCreateOrConnectWithoutGameInput[]
    createMany?: LiteratureTransferCreateManyGameInputEnvelope
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
  }

  export type EnumLiteratureGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.LiteratureGameStatus
  }

  export type LiteraturePlayerUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput> | LiteraturePlayerCreateWithoutGameInput[] | LiteraturePlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutGameInput | LiteraturePlayerCreateOrConnectWithoutGameInput[]
    upsert?: LiteraturePlayerUpsertWithWhereUniqueWithoutGameInput | LiteraturePlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteraturePlayerCreateManyGameInputEnvelope
    set?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    disconnect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    delete?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    update?: LiteraturePlayerUpdateWithWhereUniqueWithoutGameInput | LiteraturePlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteraturePlayerUpdateManyWithWhereWithoutGameInput | LiteraturePlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
  }

  export type LiteratureTeamUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput> | LiteratureTeamCreateWithoutGameInput[] | LiteratureTeamUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutGameInput | LiteratureTeamCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureTeamUpsertWithWhereUniqueWithoutGameInput | LiteratureTeamUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureTeamCreateManyGameInputEnvelope
    set?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    disconnect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    delete?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    connect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    update?: LiteratureTeamUpdateWithWhereUniqueWithoutGameInput | LiteratureTeamUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureTeamUpdateManyWithWhereWithoutGameInput | LiteratureTeamUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureTeamScalarWhereInput | LiteratureTeamScalarWhereInput[]
  }

  export type LiteratureCardMappingUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput> | LiteratureCardMappingCreateWithoutGameInput[] | LiteratureCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutGameInput | LiteratureCardMappingCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCardMappingUpsertWithWhereUniqueWithoutGameInput | LiteratureCardMappingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCardMappingCreateManyGameInputEnvelope
    set?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    disconnect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    delete?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    update?: LiteratureCardMappingUpdateWithWhereUniqueWithoutGameInput | LiteratureCardMappingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCardMappingUpdateManyWithWhereWithoutGameInput | LiteratureCardMappingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
  }

  export type LiteratureCardLocationUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput> | LiteratureCardLocationCreateWithoutGameInput[] | LiteratureCardLocationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutGameInput | LiteratureCardLocationCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCardLocationUpsertWithWhereUniqueWithoutGameInput | LiteratureCardLocationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCardLocationCreateManyGameInputEnvelope
    set?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    disconnect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    delete?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    update?: LiteratureCardLocationUpdateWithWhereUniqueWithoutGameInput | LiteratureCardLocationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCardLocationUpdateManyWithWhereWithoutGameInput | LiteratureCardLocationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
  }

  export type LiteratureAskUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput> | LiteratureAskCreateWithoutGameInput[] | LiteratureAskUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutGameInput | LiteratureAskCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureAskUpsertWithWhereUniqueWithoutGameInput | LiteratureAskUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureAskCreateManyGameInputEnvelope
    set?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    disconnect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    delete?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    update?: LiteratureAskUpdateWithWhereUniqueWithoutGameInput | LiteratureAskUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureAskUpdateManyWithWhereWithoutGameInput | LiteratureAskUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
  }

  export type LiteratureCallUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput> | LiteratureCallCreateWithoutGameInput[] | LiteratureCallUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutGameInput | LiteratureCallCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCallUpsertWithWhereUniqueWithoutGameInput | LiteratureCallUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCallCreateManyGameInputEnvelope
    set?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    disconnect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    delete?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    update?: LiteratureCallUpdateWithWhereUniqueWithoutGameInput | LiteratureCallUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCallUpdateManyWithWhereWithoutGameInput | LiteratureCallUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
  }

  export type LiteratureTransferUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput> | LiteratureTransferCreateWithoutGameInput[] | LiteratureTransferUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutGameInput | LiteratureTransferCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureTransferUpsertWithWhereUniqueWithoutGameInput | LiteratureTransferUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureTransferCreateManyGameInputEnvelope
    set?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    disconnect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    delete?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    update?: LiteratureTransferUpdateWithWhereUniqueWithoutGameInput | LiteratureTransferUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureTransferUpdateManyWithWhereWithoutGameInput | LiteratureTransferUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
  }

  export type LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput> | LiteraturePlayerCreateWithoutGameInput[] | LiteraturePlayerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteraturePlayerCreateOrConnectWithoutGameInput | LiteraturePlayerCreateOrConnectWithoutGameInput[]
    upsert?: LiteraturePlayerUpsertWithWhereUniqueWithoutGameInput | LiteraturePlayerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteraturePlayerCreateManyGameInputEnvelope
    set?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    disconnect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    delete?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    connect?: LiteraturePlayerWhereUniqueInput | LiteraturePlayerWhereUniqueInput[]
    update?: LiteraturePlayerUpdateWithWhereUniqueWithoutGameInput | LiteraturePlayerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteraturePlayerUpdateManyWithWhereWithoutGameInput | LiteraturePlayerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
  }

  export type LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput> | LiteratureTeamCreateWithoutGameInput[] | LiteratureTeamUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTeamCreateOrConnectWithoutGameInput | LiteratureTeamCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureTeamUpsertWithWhereUniqueWithoutGameInput | LiteratureTeamUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureTeamCreateManyGameInputEnvelope
    set?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    disconnect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    delete?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    connect?: LiteratureTeamWhereUniqueInput | LiteratureTeamWhereUniqueInput[]
    update?: LiteratureTeamUpdateWithWhereUniqueWithoutGameInput | LiteratureTeamUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureTeamUpdateManyWithWhereWithoutGameInput | LiteratureTeamUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureTeamScalarWhereInput | LiteratureTeamScalarWhereInput[]
  }

  export type LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput> | LiteratureCardMappingCreateWithoutGameInput[] | LiteratureCardMappingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardMappingCreateOrConnectWithoutGameInput | LiteratureCardMappingCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCardMappingUpsertWithWhereUniqueWithoutGameInput | LiteratureCardMappingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCardMappingCreateManyGameInputEnvelope
    set?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    disconnect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    delete?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    connect?: LiteratureCardMappingWhereUniqueInput | LiteratureCardMappingWhereUniqueInput[]
    update?: LiteratureCardMappingUpdateWithWhereUniqueWithoutGameInput | LiteratureCardMappingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCardMappingUpdateManyWithWhereWithoutGameInput | LiteratureCardMappingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
  }

  export type LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput> | LiteratureCardLocationCreateWithoutGameInput[] | LiteratureCardLocationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCardLocationCreateOrConnectWithoutGameInput | LiteratureCardLocationCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCardLocationUpsertWithWhereUniqueWithoutGameInput | LiteratureCardLocationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCardLocationCreateManyGameInputEnvelope
    set?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    disconnect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    delete?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    connect?: LiteratureCardLocationWhereUniqueInput | LiteratureCardLocationWhereUniqueInput[]
    update?: LiteratureCardLocationUpdateWithWhereUniqueWithoutGameInput | LiteratureCardLocationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCardLocationUpdateManyWithWhereWithoutGameInput | LiteratureCardLocationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
  }

  export type LiteratureAskUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput> | LiteratureAskCreateWithoutGameInput[] | LiteratureAskUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureAskCreateOrConnectWithoutGameInput | LiteratureAskCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureAskUpsertWithWhereUniqueWithoutGameInput | LiteratureAskUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureAskCreateManyGameInputEnvelope
    set?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    disconnect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    delete?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    connect?: LiteratureAskWhereUniqueInput | LiteratureAskWhereUniqueInput[]
    update?: LiteratureAskUpdateWithWhereUniqueWithoutGameInput | LiteratureAskUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureAskUpdateManyWithWhereWithoutGameInput | LiteratureAskUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
  }

  export type LiteratureCallUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput> | LiteratureCallCreateWithoutGameInput[] | LiteratureCallUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureCallCreateOrConnectWithoutGameInput | LiteratureCallCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureCallUpsertWithWhereUniqueWithoutGameInput | LiteratureCallUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureCallCreateManyGameInputEnvelope
    set?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    disconnect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    delete?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    connect?: LiteratureCallWhereUniqueInput | LiteratureCallWhereUniqueInput[]
    update?: LiteratureCallUpdateWithWhereUniqueWithoutGameInput | LiteratureCallUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureCallUpdateManyWithWhereWithoutGameInput | LiteratureCallUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
  }

  export type LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput> | LiteratureTransferCreateWithoutGameInput[] | LiteratureTransferUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LiteratureTransferCreateOrConnectWithoutGameInput | LiteratureTransferCreateOrConnectWithoutGameInput[]
    upsert?: LiteratureTransferUpsertWithWhereUniqueWithoutGameInput | LiteratureTransferUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LiteratureTransferCreateManyGameInputEnvelope
    set?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    disconnect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    delete?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    connect?: LiteratureTransferWhereUniqueInput | LiteratureTransferWhereUniqueInput[]
    update?: LiteratureTransferUpdateWithWhereUniqueWithoutGameInput | LiteratureTransferUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LiteratureTransferUpdateManyWithWhereWithoutGameInput | LiteratureTransferUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
  }

  export type WordleGameCreatewordsInput = {
    set: string[]
  }

  export type WordleGameCreateguessesInput = {
    set: string[]
  }

  export type WordleGameCreatecompletedWordsInput = {
    set: string[]
  }

  export type WordleGameUpdatewordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WordleGameUpdateguessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WordleGameUpdatecompletedWordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCallBreakStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallBreakStatus | EnumCallBreakStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallBreakStatusFilter<$PrismaModel> | $Enums.CallBreakStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCallBreakStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallBreakStatus | EnumCallBreakStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallBreakStatus[] | ListEnumCallBreakStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallBreakStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallBreakStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallBreakStatusFilter<$PrismaModel>
    _max?: NestedEnumCallBreakStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLiteratureGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LiteratureGameStatus | EnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiteratureGameStatusFilter<$PrismaModel> | $Enums.LiteratureGameStatus
  }

  export type NestedEnumLiteratureGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LiteratureGameStatus | EnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiteratureGameStatus[] | ListEnumLiteratureGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiteratureGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.LiteratureGameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiteratureGameStatusFilter<$PrismaModel>
    _max?: NestedEnumLiteratureGameStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CallBreakPlayerCreateWithoutGameInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutPlayerInput
  }

  export type CallBreakPlayerUncheckedCreateWithoutGameInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type CallBreakPlayerCreateOrConnectWithoutGameInput = {
    where: CallBreakPlayerWhereUniqueInput
    create: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput>
  }

  export type CallBreakPlayerCreateManyGameInputEnvelope = {
    data: CallBreakPlayerCreateManyGameInput | CallBreakPlayerCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakDealCreateWithoutGameInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutDealInput
    rounds?: CallBreakRoundCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealUncheckedCreateWithoutGameInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutDealInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealCreateOrConnectWithoutGameInput = {
    where: CallBreakDealWhereUniqueInput
    create: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput>
  }

  export type CallBreakDealCreateManyGameInputEnvelope = {
    data: CallBreakDealCreateManyGameInput | CallBreakDealCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakCardMappingCreateWithoutGameInput = {
    cardId: string
    deal: CallBreakDealCreateNestedOneWithoutCardMappingsInput
    player: CallBreakPlayerCreateNestedOneWithoutCardMappingsInput
  }

  export type CallBreakCardMappingUncheckedCreateWithoutGameInput = {
    cardId: string
    dealId: string
    playerId: string
  }

  export type CallBreakCardMappingCreateOrConnectWithoutGameInput = {
    where: CallBreakCardMappingWhereUniqueInput
    create: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput>
  }

  export type CallBreakCardMappingCreateManyGameInputEnvelope = {
    data: CallBreakCardMappingCreateManyGameInput | CallBreakCardMappingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakRoundCreateWithoutGameInput = {
    id?: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
    deal: CallBreakDealCreateNestedOneWithoutRoundsInput
  }

  export type CallBreakRoundUncheckedCreateWithoutGameInput = {
    id?: string
    dealId: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakRoundCreateOrConnectWithoutGameInput = {
    where: CallBreakRoundWhereUniqueInput
    create: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput>
  }

  export type CallBreakRoundCreateManyGameInputEnvelope = {
    data: CallBreakRoundCreateManyGameInput | CallBreakRoundCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakPlayerUpsertWithWhereUniqueWithoutGameInput = {
    where: CallBreakPlayerWhereUniqueInput
    update: XOR<CallBreakPlayerUpdateWithoutGameInput, CallBreakPlayerUncheckedUpdateWithoutGameInput>
    create: XOR<CallBreakPlayerCreateWithoutGameInput, CallBreakPlayerUncheckedCreateWithoutGameInput>
  }

  export type CallBreakPlayerUpdateWithWhereUniqueWithoutGameInput = {
    where: CallBreakPlayerWhereUniqueInput
    data: XOR<CallBreakPlayerUpdateWithoutGameInput, CallBreakPlayerUncheckedUpdateWithoutGameInput>
  }

  export type CallBreakPlayerUpdateManyWithWhereWithoutGameInput = {
    where: CallBreakPlayerScalarWhereInput
    data: XOR<CallBreakPlayerUpdateManyMutationInput, CallBreakPlayerUncheckedUpdateManyWithoutGameInput>
  }

  export type CallBreakPlayerScalarWhereInput = {
    AND?: CallBreakPlayerScalarWhereInput | CallBreakPlayerScalarWhereInput[]
    OR?: CallBreakPlayerScalarWhereInput[]
    NOT?: CallBreakPlayerScalarWhereInput | CallBreakPlayerScalarWhereInput[]
    id?: StringFilter<"CallBreakPlayer"> | string
    name?: StringFilter<"CallBreakPlayer"> | string
    avatar?: StringFilter<"CallBreakPlayer"> | string
    gameId?: StringFilter<"CallBreakPlayer"> | string
    isBot?: BoolFilter<"CallBreakPlayer"> | boolean
  }

  export type CallBreakDealUpsertWithWhereUniqueWithoutGameInput = {
    where: CallBreakDealWhereUniqueInput
    update: XOR<CallBreakDealUpdateWithoutGameInput, CallBreakDealUncheckedUpdateWithoutGameInput>
    create: XOR<CallBreakDealCreateWithoutGameInput, CallBreakDealUncheckedCreateWithoutGameInput>
  }

  export type CallBreakDealUpdateWithWhereUniqueWithoutGameInput = {
    where: CallBreakDealWhereUniqueInput
    data: XOR<CallBreakDealUpdateWithoutGameInput, CallBreakDealUncheckedUpdateWithoutGameInput>
  }

  export type CallBreakDealUpdateManyWithWhereWithoutGameInput = {
    where: CallBreakDealScalarWhereInput
    data: XOR<CallBreakDealUpdateManyMutationInput, CallBreakDealUncheckedUpdateManyWithoutGameInput>
  }

  export type CallBreakDealScalarWhereInput = {
    AND?: CallBreakDealScalarWhereInput | CallBreakDealScalarWhereInput[]
    OR?: CallBreakDealScalarWhereInput[]
    NOT?: CallBreakDealScalarWhereInput | CallBreakDealScalarWhereInput[]
    id?: StringFilter<"CallBreakDeal"> | string
    gameId?: StringFilter<"CallBreakDeal"> | string
    playerOrder?: StringNullableListFilter<"CallBreakDeal">
    declarations?: JsonFilter<"CallBreakDeal">
    wins?: JsonFilter<"CallBreakDeal">
    turnIdx?: IntFilter<"CallBreakDeal"> | number
    status?: EnumCallBreakStatusFilter<"CallBreakDeal"> | $Enums.CallBreakStatus
    createdAt?: DateTimeFilter<"CallBreakDeal"> | Date | string
  }

  export type CallBreakCardMappingUpsertWithWhereUniqueWithoutGameInput = {
    where: CallBreakCardMappingWhereUniqueInput
    update: XOR<CallBreakCardMappingUpdateWithoutGameInput, CallBreakCardMappingUncheckedUpdateWithoutGameInput>
    create: XOR<CallBreakCardMappingCreateWithoutGameInput, CallBreakCardMappingUncheckedCreateWithoutGameInput>
  }

  export type CallBreakCardMappingUpdateWithWhereUniqueWithoutGameInput = {
    where: CallBreakCardMappingWhereUniqueInput
    data: XOR<CallBreakCardMappingUpdateWithoutGameInput, CallBreakCardMappingUncheckedUpdateWithoutGameInput>
  }

  export type CallBreakCardMappingUpdateManyWithWhereWithoutGameInput = {
    where: CallBreakCardMappingScalarWhereInput
    data: XOR<CallBreakCardMappingUpdateManyMutationInput, CallBreakCardMappingUncheckedUpdateManyWithoutGameInput>
  }

  export type CallBreakCardMappingScalarWhereInput = {
    AND?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
    OR?: CallBreakCardMappingScalarWhereInput[]
    NOT?: CallBreakCardMappingScalarWhereInput | CallBreakCardMappingScalarWhereInput[]
    cardId?: StringFilter<"CallBreakCardMapping"> | string
    dealId?: StringFilter<"CallBreakCardMapping"> | string
    gameId?: StringFilter<"CallBreakCardMapping"> | string
    playerId?: StringFilter<"CallBreakCardMapping"> | string
  }

  export type CallBreakRoundUpsertWithWhereUniqueWithoutGameInput = {
    where: CallBreakRoundWhereUniqueInput
    update: XOR<CallBreakRoundUpdateWithoutGameInput, CallBreakRoundUncheckedUpdateWithoutGameInput>
    create: XOR<CallBreakRoundCreateWithoutGameInput, CallBreakRoundUncheckedCreateWithoutGameInput>
  }

  export type CallBreakRoundUpdateWithWhereUniqueWithoutGameInput = {
    where: CallBreakRoundWhereUniqueInput
    data: XOR<CallBreakRoundUpdateWithoutGameInput, CallBreakRoundUncheckedUpdateWithoutGameInput>
  }

  export type CallBreakRoundUpdateManyWithWhereWithoutGameInput = {
    where: CallBreakRoundScalarWhereInput
    data: XOR<CallBreakRoundUpdateManyMutationInput, CallBreakRoundUncheckedUpdateManyWithoutGameInput>
  }

  export type CallBreakRoundScalarWhereInput = {
    AND?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
    OR?: CallBreakRoundScalarWhereInput[]
    NOT?: CallBreakRoundScalarWhereInput | CallBreakRoundScalarWhereInput[]
    id?: StringFilter<"CallBreakRound"> | string
    gameId?: StringFilter<"CallBreakRound"> | string
    dealId?: StringFilter<"CallBreakRound"> | string
    winner?: StringNullableFilter<"CallBreakRound"> | string | null
    playerOrder?: StringNullableListFilter<"CallBreakRound">
    cards?: JsonFilter<"CallBreakRound">
    turnIdx?: IntFilter<"CallBreakRound"> | number
    suit?: StringNullableFilter<"CallBreakRound"> | string | null
    completed?: BoolFilter<"CallBreakRound"> | boolean
    createdAt?: DateTimeFilter<"CallBreakRound"> | Date | string
  }

  export type CallBreakGameCreateWithoutPlayersInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    deals?: CallBreakDealCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUncheckedCreateWithoutPlayersInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    deals?: CallBreakDealUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameCreateOrConnectWithoutPlayersInput = {
    where: CallBreakGameWhereUniqueInput
    create: XOR<CallBreakGameCreateWithoutPlayersInput, CallBreakGameUncheckedCreateWithoutPlayersInput>
  }

  export type CallBreakCardMappingCreateWithoutPlayerInput = {
    cardId: string
    deal: CallBreakDealCreateNestedOneWithoutCardMappingsInput
    game: CallBreakGameCreateNestedOneWithoutCardMappingsInput
  }

  export type CallBreakCardMappingUncheckedCreateWithoutPlayerInput = {
    cardId: string
    dealId: string
  }

  export type CallBreakCardMappingCreateOrConnectWithoutPlayerInput = {
    where: CallBreakCardMappingWhereUniqueInput
    create: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput>
  }

  export type CallBreakCardMappingCreateManyPlayerInputEnvelope = {
    data: CallBreakCardMappingCreateManyPlayerInput | CallBreakCardMappingCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakGameUpsertWithoutPlayersInput = {
    update: XOR<CallBreakGameUpdateWithoutPlayersInput, CallBreakGameUncheckedUpdateWithoutPlayersInput>
    create: XOR<CallBreakGameCreateWithoutPlayersInput, CallBreakGameUncheckedCreateWithoutPlayersInput>
    where?: CallBreakGameWhereInput
  }

  export type CallBreakGameUpdateToOneWithWhereWithoutPlayersInput = {
    where?: CallBreakGameWhereInput
    data: XOR<CallBreakGameUpdateWithoutPlayersInput, CallBreakGameUncheckedUpdateWithoutPlayersInput>
  }

  export type CallBreakGameUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    deals?: CallBreakDealUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    deals?: CallBreakDealUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CallBreakCardMappingUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CallBreakCardMappingWhereUniqueInput
    update: XOR<CallBreakCardMappingUpdateWithoutPlayerInput, CallBreakCardMappingUncheckedUpdateWithoutPlayerInput>
    create: XOR<CallBreakCardMappingCreateWithoutPlayerInput, CallBreakCardMappingUncheckedCreateWithoutPlayerInput>
  }

  export type CallBreakCardMappingUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CallBreakCardMappingWhereUniqueInput
    data: XOR<CallBreakCardMappingUpdateWithoutPlayerInput, CallBreakCardMappingUncheckedUpdateWithoutPlayerInput>
  }

  export type CallBreakCardMappingUpdateManyWithWhereWithoutPlayerInput = {
    where: CallBreakCardMappingScalarWhereInput
    data: XOR<CallBreakCardMappingUpdateManyMutationInput, CallBreakCardMappingUncheckedUpdateManyWithoutPlayerInput>
  }

  export type CallBreakGameCreateWithoutDealsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUncheckedCreateWithoutDealsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameCreateOrConnectWithoutDealsInput = {
    where: CallBreakGameWhereUniqueInput
    create: XOR<CallBreakGameCreateWithoutDealsInput, CallBreakGameUncheckedCreateWithoutDealsInput>
  }

  export type CallBreakCardMappingCreateWithoutDealInput = {
    cardId: string
    game: CallBreakGameCreateNestedOneWithoutCardMappingsInput
    player: CallBreakPlayerCreateNestedOneWithoutCardMappingsInput
  }

  export type CallBreakCardMappingUncheckedCreateWithoutDealInput = {
    cardId: string
    playerId: string
  }

  export type CallBreakCardMappingCreateOrConnectWithoutDealInput = {
    where: CallBreakCardMappingWhereUniqueInput
    create: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput>
  }

  export type CallBreakCardMappingCreateManyDealInputEnvelope = {
    data: CallBreakCardMappingCreateManyDealInput | CallBreakCardMappingCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakRoundCreateWithoutDealInput = {
    id?: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
    game: CallBreakGameCreateNestedOneWithoutRoundsInput
  }

  export type CallBreakRoundUncheckedCreateWithoutDealInput = {
    id?: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakRoundCreateOrConnectWithoutDealInput = {
    where: CallBreakRoundWhereUniqueInput
    create: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput>
  }

  export type CallBreakRoundCreateManyDealInputEnvelope = {
    data: CallBreakRoundCreateManyDealInput | CallBreakRoundCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type CallBreakGameUpsertWithoutDealsInput = {
    update: XOR<CallBreakGameUpdateWithoutDealsInput, CallBreakGameUncheckedUpdateWithoutDealsInput>
    create: XOR<CallBreakGameCreateWithoutDealsInput, CallBreakGameUncheckedCreateWithoutDealsInput>
    where?: CallBreakGameWhereInput
  }

  export type CallBreakGameUpdateToOneWithWhereWithoutDealsInput = {
    where?: CallBreakGameWhereInput
    data: XOR<CallBreakGameUpdateWithoutDealsInput, CallBreakGameUncheckedUpdateWithoutDealsInput>
  }

  export type CallBreakGameUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CallBreakCardMappingUpsertWithWhereUniqueWithoutDealInput = {
    where: CallBreakCardMappingWhereUniqueInput
    update: XOR<CallBreakCardMappingUpdateWithoutDealInput, CallBreakCardMappingUncheckedUpdateWithoutDealInput>
    create: XOR<CallBreakCardMappingCreateWithoutDealInput, CallBreakCardMappingUncheckedCreateWithoutDealInput>
  }

  export type CallBreakCardMappingUpdateWithWhereUniqueWithoutDealInput = {
    where: CallBreakCardMappingWhereUniqueInput
    data: XOR<CallBreakCardMappingUpdateWithoutDealInput, CallBreakCardMappingUncheckedUpdateWithoutDealInput>
  }

  export type CallBreakCardMappingUpdateManyWithWhereWithoutDealInput = {
    where: CallBreakCardMappingScalarWhereInput
    data: XOR<CallBreakCardMappingUpdateManyMutationInput, CallBreakCardMappingUncheckedUpdateManyWithoutDealInput>
  }

  export type CallBreakRoundUpsertWithWhereUniqueWithoutDealInput = {
    where: CallBreakRoundWhereUniqueInput
    update: XOR<CallBreakRoundUpdateWithoutDealInput, CallBreakRoundUncheckedUpdateWithoutDealInput>
    create: XOR<CallBreakRoundCreateWithoutDealInput, CallBreakRoundUncheckedCreateWithoutDealInput>
  }

  export type CallBreakRoundUpdateWithWhereUniqueWithoutDealInput = {
    where: CallBreakRoundWhereUniqueInput
    data: XOR<CallBreakRoundUpdateWithoutDealInput, CallBreakRoundUncheckedUpdateWithoutDealInput>
  }

  export type CallBreakRoundUpdateManyWithWhereWithoutDealInput = {
    where: CallBreakRoundScalarWhereInput
    data: XOR<CallBreakRoundUpdateManyMutationInput, CallBreakRoundUncheckedUpdateManyWithoutDealInput>
  }

  export type CallBreakDealCreateWithoutCardMappingsInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    game: CallBreakGameCreateNestedOneWithoutDealsInput
    rounds?: CallBreakRoundCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealUncheckedCreateWithoutCardMappingsInput = {
    id?: string
    gameId: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealCreateOrConnectWithoutCardMappingsInput = {
    where: CallBreakDealWhereUniqueInput
    create: XOR<CallBreakDealCreateWithoutCardMappingsInput, CallBreakDealUncheckedCreateWithoutCardMappingsInput>
  }

  export type CallBreakGameCreateWithoutCardMappingsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerCreateNestedManyWithoutGameInput
    deals?: CallBreakDealCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUncheckedCreateWithoutCardMappingsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedCreateNestedManyWithoutGameInput
    deals?: CallBreakDealUncheckedCreateNestedManyWithoutGameInput
    rounds?: CallBreakRoundUncheckedCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameCreateOrConnectWithoutCardMappingsInput = {
    where: CallBreakGameWhereUniqueInput
    create: XOR<CallBreakGameCreateWithoutCardMappingsInput, CallBreakGameUncheckedCreateWithoutCardMappingsInput>
  }

  export type CallBreakPlayerCreateWithoutCardMappingsInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: CallBreakGameCreateNestedOneWithoutPlayersInput
  }

  export type CallBreakPlayerUncheckedCreateWithoutCardMappingsInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    isBot?: boolean
  }

  export type CallBreakPlayerCreateOrConnectWithoutCardMappingsInput = {
    where: CallBreakPlayerWhereUniqueInput
    create: XOR<CallBreakPlayerCreateWithoutCardMappingsInput, CallBreakPlayerUncheckedCreateWithoutCardMappingsInput>
  }

  export type CallBreakDealUpsertWithoutCardMappingsInput = {
    update: XOR<CallBreakDealUpdateWithoutCardMappingsInput, CallBreakDealUncheckedUpdateWithoutCardMappingsInput>
    create: XOR<CallBreakDealCreateWithoutCardMappingsInput, CallBreakDealUncheckedCreateWithoutCardMappingsInput>
    where?: CallBreakDealWhereInput
  }

  export type CallBreakDealUpdateToOneWithWhereWithoutCardMappingsInput = {
    where?: CallBreakDealWhereInput
    data: XOR<CallBreakDealUpdateWithoutCardMappingsInput, CallBreakDealUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakDealUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: CallBreakGameUpdateOneRequiredWithoutDealsNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealUncheckedUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutDealNestedInput
  }

  export type CallBreakGameUpsertWithoutCardMappingsInput = {
    update: XOR<CallBreakGameUpdateWithoutCardMappingsInput, CallBreakGameUncheckedUpdateWithoutCardMappingsInput>
    create: XOR<CallBreakGameCreateWithoutCardMappingsInput, CallBreakGameUncheckedCreateWithoutCardMappingsInput>
    where?: CallBreakGameWhereInput
  }

  export type CallBreakGameUpdateToOneWithWhereWithoutCardMappingsInput = {
    where?: CallBreakGameWhereInput
    data: XOR<CallBreakGameUpdateWithoutCardMappingsInput, CallBreakGameUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakGameUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameUncheckedUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUncheckedUpdateManyWithoutGameNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CallBreakPlayerUpsertWithoutCardMappingsInput = {
    update: XOR<CallBreakPlayerUpdateWithoutCardMappingsInput, CallBreakPlayerUncheckedUpdateWithoutCardMappingsInput>
    create: XOR<CallBreakPlayerCreateWithoutCardMappingsInput, CallBreakPlayerUncheckedCreateWithoutCardMappingsInput>
    where?: CallBreakPlayerWhereInput
  }

  export type CallBreakPlayerUpdateToOneWithWhereWithoutCardMappingsInput = {
    where?: CallBreakPlayerWhereInput
    data: XOR<CallBreakPlayerUpdateWithoutCardMappingsInput, CallBreakPlayerUncheckedUpdateWithoutCardMappingsInput>
  }

  export type CallBreakPlayerUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: CallBreakGameUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type CallBreakPlayerUncheckedUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CallBreakDealCreateWithoutRoundsInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    game: CallBreakGameCreateNestedOneWithoutDealsInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealUncheckedCreateWithoutRoundsInput = {
    id?: string
    gameId: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutDealInput
  }

  export type CallBreakDealCreateOrConnectWithoutRoundsInput = {
    where: CallBreakDealWhereUniqueInput
    create: XOR<CallBreakDealCreateWithoutRoundsInput, CallBreakDealUncheckedCreateWithoutRoundsInput>
  }

  export type CallBreakGameCreateWithoutRoundsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerCreateNestedManyWithoutGameInput
    deals?: CallBreakDealCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameUncheckedCreateWithoutRoundsInput = {
    id?: string
    code: string
    dealCount?: number
    trumpSuit: string
    status?: $Enums.CallBreakStatus
    createdBy: string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedCreateNestedManyWithoutGameInput
    deals?: CallBreakDealUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: CallBreakCardMappingUncheckedCreateNestedManyWithoutGameInput
  }

  export type CallBreakGameCreateOrConnectWithoutRoundsInput = {
    where: CallBreakGameWhereUniqueInput
    create: XOR<CallBreakGameCreateWithoutRoundsInput, CallBreakGameUncheckedCreateWithoutRoundsInput>
  }

  export type CallBreakDealUpsertWithoutRoundsInput = {
    update: XOR<CallBreakDealUpdateWithoutRoundsInput, CallBreakDealUncheckedUpdateWithoutRoundsInput>
    create: XOR<CallBreakDealCreateWithoutRoundsInput, CallBreakDealUncheckedCreateWithoutRoundsInput>
    where?: CallBreakDealWhereInput
  }

  export type CallBreakDealUpdateToOneWithWhereWithoutRoundsInput = {
    where?: CallBreakDealWhereInput
    data: XOR<CallBreakDealUpdateWithoutRoundsInput, CallBreakDealUncheckedUpdateWithoutRoundsInput>
  }

  export type CallBreakDealUpdateWithoutRoundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: CallBreakGameUpdateOneRequiredWithoutDealsNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealUncheckedUpdateWithoutRoundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutDealNestedInput
  }

  export type CallBreakGameUpsertWithoutRoundsInput = {
    update: XOR<CallBreakGameUpdateWithoutRoundsInput, CallBreakGameUncheckedUpdateWithoutRoundsInput>
    create: XOR<CallBreakGameCreateWithoutRoundsInput, CallBreakGameUncheckedCreateWithoutRoundsInput>
    where?: CallBreakGameWhereInput
  }

  export type CallBreakGameUpdateToOneWithWhereWithoutRoundsInput = {
    where?: CallBreakGameWhereInput
    data: XOR<CallBreakGameUpdateWithoutRoundsInput, CallBreakGameUncheckedUpdateWithoutRoundsInput>
  }

  export type CallBreakGameUpdateWithoutRoundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUpdateManyWithoutGameNestedInput
  }

  export type CallBreakGameUncheckedUpdateWithoutRoundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dealCount?: IntFieldUpdateOperationsInput | number
    trumpSuit?: StringFieldUpdateOperationsInput | string
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    scores?: (Array<Record<string, number>>)
    players?: CallBreakPlayerUncheckedUpdateManyWithoutGameNestedInput
    deals?: CallBreakDealUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameCreateWithoutPlayersInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutPlayersInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutPlayersInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutPlayersInput, LiteratureGameUncheckedCreateWithoutPlayersInput>
  }

  export type LiteratureTeamCreateWithoutMembersInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    game: LiteratureGameCreateNestedOneWithoutTeamsInput
  }

  export type LiteratureTeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    gameId: string
  }

  export type LiteratureTeamCreateOrConnectWithoutMembersInput = {
    where: LiteratureTeamWhereUniqueInput
    create: XOR<LiteratureTeamCreateWithoutMembersInput, LiteratureTeamUncheckedCreateWithoutMembersInput>
  }

  export type LiteratureCardMappingCreateWithoutPlayerInput = {
    cardId: string
    game: LiteratureGameCreateNestedOneWithoutCardMappingsInput
  }

  export type LiteratureCardMappingUncheckedCreateWithoutPlayerInput = {
    cardId: string
  }

  export type LiteratureCardMappingCreateOrConnectWithoutPlayerInput = {
    where: LiteratureCardMappingWhereUniqueInput
    create: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCardMappingCreateManyPlayerInputEnvelope = {
    data: LiteratureCardMappingCreateManyPlayerInput | LiteratureCardMappingCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureCardLocationCreateWithoutPlayerInput = {
    cardId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
    game: LiteratureGameCreateNestedOneWithoutCardLocationsInput
  }

  export type LiteratureCardLocationUncheckedCreateWithoutPlayerInput = {
    cardId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureCardLocationCreateOrConnectWithoutPlayerInput = {
    where: LiteratureCardLocationWhereUniqueInput
    create: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCardLocationCreateManyPlayerInputEnvelope = {
    data: LiteratureCardLocationCreateManyPlayerInput | LiteratureCardLocationCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureAskCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
    game: LiteratureGameCreateNestedOneWithoutAsksInput
  }

  export type LiteratureAskUncheckedCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureAskCreateOrConnectWithoutPlayerInput = {
    where: LiteratureAskWhereUniqueInput
    create: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureAskCreateManyPlayerInputEnvelope = {
    data: LiteratureAskCreateManyPlayerInput | LiteratureAskCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureCallCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
    game: LiteratureGameCreateNestedOneWithoutCallsInput
  }

  export type LiteratureCallUncheckedCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureCallCreateOrConnectWithoutPlayerInput = {
    where: LiteratureCallWhereUniqueInput
    create: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCallCreateManyPlayerInputEnvelope = {
    data: LiteratureCallCreateManyPlayerInput | LiteratureCallCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureTransferCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
    game: LiteratureGameCreateNestedOneWithoutTransfersInput
  }

  export type LiteratureTransferUncheckedCreateWithoutPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteratureTransferCreateOrConnectWithoutPlayerInput = {
    where: LiteratureTransferWhereUniqueInput
    create: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureTransferCreateManyPlayerInputEnvelope = {
    data: LiteratureTransferCreateManyPlayerInput | LiteratureTransferCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureGameUpsertWithoutPlayersInput = {
    update: XOR<LiteratureGameUpdateWithoutPlayersInput, LiteratureGameUncheckedUpdateWithoutPlayersInput>
    create: XOR<LiteratureGameCreateWithoutPlayersInput, LiteratureGameUncheckedCreateWithoutPlayersInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutPlayersInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutPlayersInput, LiteratureGameUncheckedUpdateWithoutPlayersInput>
  }

  export type LiteratureGameUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteratureTeamUpsertWithoutMembersInput = {
    update: XOR<LiteratureTeamUpdateWithoutMembersInput, LiteratureTeamUncheckedUpdateWithoutMembersInput>
    create: XOR<LiteratureTeamCreateWithoutMembersInput, LiteratureTeamUncheckedCreateWithoutMembersInput>
    where?: LiteratureTeamWhereInput
  }

  export type LiteratureTeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: LiteratureTeamWhereInput
    data: XOR<LiteratureTeamUpdateWithoutMembersInput, LiteratureTeamUncheckedUpdateWithoutMembersInput>
  }

  export type LiteratureTeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    game?: LiteratureGameUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type LiteratureTeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingUpsertWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCardMappingWhereUniqueInput
    update: XOR<LiteratureCardMappingUpdateWithoutPlayerInput, LiteratureCardMappingUncheckedUpdateWithoutPlayerInput>
    create: XOR<LiteratureCardMappingCreateWithoutPlayerInput, LiteratureCardMappingUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCardMappingUpdateWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCardMappingWhereUniqueInput
    data: XOR<LiteratureCardMappingUpdateWithoutPlayerInput, LiteratureCardMappingUncheckedUpdateWithoutPlayerInput>
  }

  export type LiteratureCardMappingUpdateManyWithWhereWithoutPlayerInput = {
    where: LiteratureCardMappingScalarWhereInput
    data: XOR<LiteratureCardMappingUpdateManyMutationInput, LiteratureCardMappingUncheckedUpdateManyWithoutPlayerInput>
  }

  export type LiteratureCardMappingScalarWhereInput = {
    AND?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
    OR?: LiteratureCardMappingScalarWhereInput[]
    NOT?: LiteratureCardMappingScalarWhereInput | LiteratureCardMappingScalarWhereInput[]
    cardId?: StringFilter<"LiteratureCardMapping"> | string
    gameId?: StringFilter<"LiteratureCardMapping"> | string
    playerId?: StringFilter<"LiteratureCardMapping"> | string
  }

  export type LiteratureCardLocationUpsertWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCardLocationWhereUniqueInput
    update: XOR<LiteratureCardLocationUpdateWithoutPlayerInput, LiteratureCardLocationUncheckedUpdateWithoutPlayerInput>
    create: XOR<LiteratureCardLocationCreateWithoutPlayerInput, LiteratureCardLocationUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCardLocationUpdateWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCardLocationWhereUniqueInput
    data: XOR<LiteratureCardLocationUpdateWithoutPlayerInput, LiteratureCardLocationUncheckedUpdateWithoutPlayerInput>
  }

  export type LiteratureCardLocationUpdateManyWithWhereWithoutPlayerInput = {
    where: LiteratureCardLocationScalarWhereInput
    data: XOR<LiteratureCardLocationUpdateManyMutationInput, LiteratureCardLocationUncheckedUpdateManyWithoutPlayerInput>
  }

  export type LiteratureCardLocationScalarWhereInput = {
    AND?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
    OR?: LiteratureCardLocationScalarWhereInput[]
    NOT?: LiteratureCardLocationScalarWhereInput | LiteratureCardLocationScalarWhereInput[]
    cardId?: StringFilter<"LiteratureCardLocation"> | string
    gameId?: StringFilter<"LiteratureCardLocation"> | string
    playerId?: StringFilter<"LiteratureCardLocation"> | string
    playerIds?: StringNullableListFilter<"LiteratureCardLocation">
    weight?: IntFilter<"LiteratureCardLocation"> | number
  }

  export type LiteratureAskUpsertWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureAskWhereUniqueInput
    update: XOR<LiteratureAskUpdateWithoutPlayerInput, LiteratureAskUncheckedUpdateWithoutPlayerInput>
    create: XOR<LiteratureAskCreateWithoutPlayerInput, LiteratureAskUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureAskUpdateWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureAskWhereUniqueInput
    data: XOR<LiteratureAskUpdateWithoutPlayerInput, LiteratureAskUncheckedUpdateWithoutPlayerInput>
  }

  export type LiteratureAskUpdateManyWithWhereWithoutPlayerInput = {
    where: LiteratureAskScalarWhereInput
    data: XOR<LiteratureAskUpdateManyMutationInput, LiteratureAskUncheckedUpdateManyWithoutPlayerInput>
  }

  export type LiteratureAskScalarWhereInput = {
    AND?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
    OR?: LiteratureAskScalarWhereInput[]
    NOT?: LiteratureAskScalarWhereInput | LiteratureAskScalarWhereInput[]
    id?: StringFilter<"LiteratureAsk"> | string
    gameId?: StringFilter<"LiteratureAsk"> | string
    playerId?: StringFilter<"LiteratureAsk"> | string
    timestamp?: DateTimeFilter<"LiteratureAsk"> | Date | string
    description?: StringFilter<"LiteratureAsk"> | string
    success?: BoolFilter<"LiteratureAsk"> | boolean
    cardId?: StringFilter<"LiteratureAsk"> | string
    askedFrom?: StringFilter<"LiteratureAsk"> | string
  }

  export type LiteratureCallUpsertWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCallWhereUniqueInput
    update: XOR<LiteratureCallUpdateWithoutPlayerInput, LiteratureCallUncheckedUpdateWithoutPlayerInput>
    create: XOR<LiteratureCallCreateWithoutPlayerInput, LiteratureCallUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureCallUpdateWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureCallWhereUniqueInput
    data: XOR<LiteratureCallUpdateWithoutPlayerInput, LiteratureCallUncheckedUpdateWithoutPlayerInput>
  }

  export type LiteratureCallUpdateManyWithWhereWithoutPlayerInput = {
    where: LiteratureCallScalarWhereInput
    data: XOR<LiteratureCallUpdateManyMutationInput, LiteratureCallUncheckedUpdateManyWithoutPlayerInput>
  }

  export type LiteratureCallScalarWhereInput = {
    AND?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
    OR?: LiteratureCallScalarWhereInput[]
    NOT?: LiteratureCallScalarWhereInput | LiteratureCallScalarWhereInput[]
    id?: StringFilter<"LiteratureCall"> | string
    gameId?: StringFilter<"LiteratureCall"> | string
    playerId?: StringFilter<"LiteratureCall"> | string
    timestamp?: DateTimeFilter<"LiteratureCall"> | Date | string
    description?: StringFilter<"LiteratureCall"> | string
    success?: BoolFilter<"LiteratureCall"> | boolean
    cardSet?: StringFilter<"LiteratureCall"> | string
    actualCall?: JsonFilter<"LiteratureCall">
    correctCall?: JsonFilter<"LiteratureCall">
  }

  export type LiteratureTransferUpsertWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureTransferWhereUniqueInput
    update: XOR<LiteratureTransferUpdateWithoutPlayerInput, LiteratureTransferUncheckedUpdateWithoutPlayerInput>
    create: XOR<LiteratureTransferCreateWithoutPlayerInput, LiteratureTransferUncheckedCreateWithoutPlayerInput>
  }

  export type LiteratureTransferUpdateWithWhereUniqueWithoutPlayerInput = {
    where: LiteratureTransferWhereUniqueInput
    data: XOR<LiteratureTransferUpdateWithoutPlayerInput, LiteratureTransferUncheckedUpdateWithoutPlayerInput>
  }

  export type LiteratureTransferUpdateManyWithWhereWithoutPlayerInput = {
    where: LiteratureTransferScalarWhereInput
    data: XOR<LiteratureTransferUpdateManyMutationInput, LiteratureTransferUncheckedUpdateManyWithoutPlayerInput>
  }

  export type LiteratureTransferScalarWhereInput = {
    AND?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
    OR?: LiteratureTransferScalarWhereInput[]
    NOT?: LiteratureTransferScalarWhereInput | LiteratureTransferScalarWhereInput[]
    id?: StringFilter<"LiteratureTransfer"> | string
    gameId?: StringFilter<"LiteratureTransfer"> | string
    playerId?: StringFilter<"LiteratureTransfer"> | string
    timestamp?: DateTimeFilter<"LiteratureTransfer"> | Date | string
    description?: StringFilter<"LiteratureTransfer"> | string
    success?: BoolFilter<"LiteratureTransfer"> | boolean
    transferTo?: StringFilter<"LiteratureTransfer"> | string
  }

  export type LiteraturePlayerCreateWithoutTeamInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutTeamInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput>
  }

  export type LiteraturePlayerCreateManyTeamInputEnvelope = {
    data: LiteraturePlayerCreateManyTeamInput | LiteraturePlayerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureGameCreateWithoutTeamsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutTeamsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutTeamsInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutTeamsInput, LiteratureGameUncheckedCreateWithoutTeamsInput>
  }

  export type LiteraturePlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: LiteraturePlayerWhereUniqueInput
    update: XOR<LiteraturePlayerUpdateWithoutTeamInput, LiteraturePlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<LiteraturePlayerCreateWithoutTeamInput, LiteraturePlayerUncheckedCreateWithoutTeamInput>
  }

  export type LiteraturePlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: LiteraturePlayerWhereUniqueInput
    data: XOR<LiteraturePlayerUpdateWithoutTeamInput, LiteraturePlayerUncheckedUpdateWithoutTeamInput>
  }

  export type LiteraturePlayerUpdateManyWithWhereWithoutTeamInput = {
    where: LiteraturePlayerScalarWhereInput
    data: XOR<LiteraturePlayerUpdateManyMutationInput, LiteraturePlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type LiteraturePlayerScalarWhereInput = {
    AND?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
    OR?: LiteraturePlayerScalarWhereInput[]
    NOT?: LiteraturePlayerScalarWhereInput | LiteraturePlayerScalarWhereInput[]
    id?: StringFilter<"LiteraturePlayer"> | string
    name?: StringFilter<"LiteraturePlayer"> | string
    avatar?: StringFilter<"LiteraturePlayer"> | string
    gameId?: StringFilter<"LiteraturePlayer"> | string
    teamId?: StringNullableFilter<"LiteraturePlayer"> | string | null
    isBot?: BoolFilter<"LiteraturePlayer"> | boolean
  }

  export type LiteratureGameUpsertWithoutTeamsInput = {
    update: XOR<LiteratureGameUpdateWithoutTeamsInput, LiteratureGameUncheckedUpdateWithoutTeamsInput>
    create: XOR<LiteratureGameCreateWithoutTeamsInput, LiteratureGameUncheckedCreateWithoutTeamsInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutTeamsInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutTeamsInput, LiteratureGameUncheckedUpdateWithoutTeamsInput>
  }

  export type LiteratureGameUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameCreateWithoutCardMappingsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutCardMappingsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutCardMappingsInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutCardMappingsInput, LiteratureGameUncheckedCreateWithoutCardMappingsInput>
  }

  export type LiteraturePlayerCreateWithoutCardMappingsInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutCardMappingsInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutCardMappingsInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutCardMappingsInput, LiteraturePlayerUncheckedCreateWithoutCardMappingsInput>
  }

  export type LiteratureGameUpsertWithoutCardMappingsInput = {
    update: XOR<LiteratureGameUpdateWithoutCardMappingsInput, LiteratureGameUncheckedUpdateWithoutCardMappingsInput>
    create: XOR<LiteratureGameCreateWithoutCardMappingsInput, LiteratureGameUncheckedCreateWithoutCardMappingsInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutCardMappingsInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutCardMappingsInput, LiteratureGameUncheckedUpdateWithoutCardMappingsInput>
  }

  export type LiteratureGameUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteraturePlayerUpsertWithoutCardMappingsInput = {
    update: XOR<LiteraturePlayerUpdateWithoutCardMappingsInput, LiteraturePlayerUncheckedUpdateWithoutCardMappingsInput>
    create: XOR<LiteraturePlayerCreateWithoutCardMappingsInput, LiteraturePlayerUncheckedCreateWithoutCardMappingsInput>
    where?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerUpdateToOneWithWhereWithoutCardMappingsInput = {
    where?: LiteraturePlayerWhereInput
    data: XOR<LiteraturePlayerUpdateWithoutCardMappingsInput, LiteraturePlayerUncheckedUpdateWithoutCardMappingsInput>
  }

  export type LiteraturePlayerUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutCardMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteratureGameCreateWithoutCardLocationsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutCardLocationsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutCardLocationsInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutCardLocationsInput, LiteratureGameUncheckedCreateWithoutCardLocationsInput>
  }

  export type LiteraturePlayerCreateWithoutCardLocationsInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutCardLocationsInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutCardLocationsInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutCardLocationsInput, LiteraturePlayerUncheckedCreateWithoutCardLocationsInput>
  }

  export type LiteratureGameUpsertWithoutCardLocationsInput = {
    update: XOR<LiteratureGameUpdateWithoutCardLocationsInput, LiteratureGameUncheckedUpdateWithoutCardLocationsInput>
    create: XOR<LiteratureGameCreateWithoutCardLocationsInput, LiteratureGameUncheckedCreateWithoutCardLocationsInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutCardLocationsInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutCardLocationsInput, LiteratureGameUncheckedUpdateWithoutCardLocationsInput>
  }

  export type LiteratureGameUpdateWithoutCardLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutCardLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteraturePlayerUpsertWithoutCardLocationsInput = {
    update: XOR<LiteraturePlayerUpdateWithoutCardLocationsInput, LiteraturePlayerUncheckedUpdateWithoutCardLocationsInput>
    create: XOR<LiteraturePlayerCreateWithoutCardLocationsInput, LiteraturePlayerUncheckedCreateWithoutCardLocationsInput>
    where?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerUpdateToOneWithWhereWithoutCardLocationsInput = {
    where?: LiteraturePlayerWhereInput
    data: XOR<LiteraturePlayerUpdateWithoutCardLocationsInput, LiteraturePlayerUncheckedUpdateWithoutCardLocationsInput>
  }

  export type LiteraturePlayerUpdateWithoutCardLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutCardLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteratureGameCreateWithoutAsksInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutAsksInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutAsksInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutAsksInput, LiteratureGameUncheckedCreateWithoutAsksInput>
  }

  export type LiteraturePlayerCreateWithoutAsksInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutAsksInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutAsksInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutAsksInput, LiteraturePlayerUncheckedCreateWithoutAsksInput>
  }

  export type LiteratureGameUpsertWithoutAsksInput = {
    update: XOR<LiteratureGameUpdateWithoutAsksInput, LiteratureGameUncheckedUpdateWithoutAsksInput>
    create: XOR<LiteratureGameCreateWithoutAsksInput, LiteratureGameUncheckedCreateWithoutAsksInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutAsksInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutAsksInput, LiteratureGameUncheckedUpdateWithoutAsksInput>
  }

  export type LiteratureGameUpdateWithoutAsksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutAsksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteraturePlayerUpsertWithoutAsksInput = {
    update: XOR<LiteraturePlayerUpdateWithoutAsksInput, LiteraturePlayerUncheckedUpdateWithoutAsksInput>
    create: XOR<LiteraturePlayerCreateWithoutAsksInput, LiteraturePlayerUncheckedCreateWithoutAsksInput>
    where?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerUpdateToOneWithWhereWithoutAsksInput = {
    where?: LiteraturePlayerWhereInput
    data: XOR<LiteraturePlayerUpdateWithoutAsksInput, LiteraturePlayerUncheckedUpdateWithoutAsksInput>
  }

  export type LiteraturePlayerUpdateWithoutAsksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutAsksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteratureGameCreateWithoutCallsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutCallsInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutCallsInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutCallsInput, LiteratureGameUncheckedCreateWithoutCallsInput>
  }

  export type LiteraturePlayerCreateWithoutCallsInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutCallsInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutCallsInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutCallsInput, LiteraturePlayerUncheckedCreateWithoutCallsInput>
  }

  export type LiteratureGameUpsertWithoutCallsInput = {
    update: XOR<LiteratureGameUpdateWithoutCallsInput, LiteratureGameUncheckedUpdateWithoutCallsInput>
    create: XOR<LiteratureGameCreateWithoutCallsInput, LiteratureGameUncheckedCreateWithoutCallsInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutCallsInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutCallsInput, LiteratureGameUncheckedUpdateWithoutCallsInput>
  }

  export type LiteratureGameUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteraturePlayerUpsertWithoutCallsInput = {
    update: XOR<LiteraturePlayerUpdateWithoutCallsInput, LiteraturePlayerUncheckedUpdateWithoutCallsInput>
    create: XOR<LiteraturePlayerCreateWithoutCallsInput, LiteraturePlayerUncheckedCreateWithoutCallsInput>
    where?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerUpdateToOneWithWhereWithoutCallsInput = {
    where?: LiteraturePlayerWhereInput
    data: XOR<LiteraturePlayerUpdateWithoutCallsInput, LiteraturePlayerUncheckedUpdateWithoutCallsInput>
  }

  export type LiteraturePlayerUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteratureGameCreateWithoutTransfersInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutGameInput
    asks?: LiteratureAskCreateNestedManyWithoutGameInput
    calls?: LiteratureCallCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameUncheckedCreateWithoutTransfersInput = {
    id?: string
    code: string
    status?: $Enums.LiteratureGameStatus
    playerCount?: number
    currentTurn: string
    lastMoveId?: string
    players?: LiteraturePlayerUncheckedCreateNestedManyWithoutGameInput
    teams?: LiteratureTeamUncheckedCreateNestedManyWithoutGameInput
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutGameInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutGameInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutGameInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutGameInput
  }

  export type LiteratureGameCreateOrConnectWithoutTransfersInput = {
    where: LiteratureGameWhereUniqueInput
    create: XOR<LiteratureGameCreateWithoutTransfersInput, LiteratureGameUncheckedCreateWithoutTransfersInput>
  }

  export type LiteraturePlayerCreateWithoutTransfersInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    game: LiteratureGameCreateNestedOneWithoutPlayersInput
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutTransfersInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutTransfersInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutTransfersInput, LiteraturePlayerUncheckedCreateWithoutTransfersInput>
  }

  export type LiteratureGameUpsertWithoutTransfersInput = {
    update: XOR<LiteratureGameUpdateWithoutTransfersInput, LiteratureGameUncheckedUpdateWithoutTransfersInput>
    create: XOR<LiteratureGameCreateWithoutTransfersInput, LiteratureGameUncheckedCreateWithoutTransfersInput>
    where?: LiteratureGameWhereInput
  }

  export type LiteratureGameUpdateToOneWithWhereWithoutTransfersInput = {
    where?: LiteratureGameWhereInput
    data: XOR<LiteratureGameUpdateWithoutTransfersInput, LiteratureGameUncheckedUpdateWithoutTransfersInput>
  }

  export type LiteratureGameUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUpdateManyWithoutGameNestedInput
  }

  export type LiteratureGameUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumLiteratureGameStatusFieldUpdateOperationsInput | $Enums.LiteratureGameStatus
    playerCount?: IntFieldUpdateOperationsInput | number
    currentTurn?: StringFieldUpdateOperationsInput | string
    lastMoveId?: StringFieldUpdateOperationsInput | string
    players?: LiteraturePlayerUncheckedUpdateManyWithoutGameNestedInput
    teams?: LiteratureTeamUncheckedUpdateManyWithoutGameNestedInput
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutGameNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutGameNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutGameNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutGameNestedInput
  }

  export type LiteraturePlayerUpsertWithoutTransfersInput = {
    update: XOR<LiteraturePlayerUpdateWithoutTransfersInput, LiteraturePlayerUncheckedUpdateWithoutTransfersInput>
    create: XOR<LiteraturePlayerCreateWithoutTransfersInput, LiteraturePlayerUncheckedCreateWithoutTransfersInput>
    where?: LiteraturePlayerWhereInput
  }

  export type LiteraturePlayerUpdateToOneWithWhereWithoutTransfersInput = {
    where?: LiteraturePlayerWhereInput
    data: XOR<LiteraturePlayerUpdateWithoutTransfersInput, LiteraturePlayerUncheckedUpdateWithoutTransfersInput>
  }

  export type LiteraturePlayerUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerCreateWithoutGameInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
    team?: LiteratureTeamCreateNestedOneWithoutMembersInput
    cardMappings?: LiteratureCardMappingCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerUncheckedCreateWithoutGameInput = {
    id?: string
    name: string
    avatar: string
    teamId?: string | null
    isBot?: boolean
    cardMappings?: LiteratureCardMappingUncheckedCreateNestedManyWithoutPlayerInput
    cardLocations?: LiteratureCardLocationUncheckedCreateNestedManyWithoutPlayerInput
    asks?: LiteratureAskUncheckedCreateNestedManyWithoutPlayerInput
    calls?: LiteratureCallUncheckedCreateNestedManyWithoutPlayerInput
    transfers?: LiteratureTransferUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type LiteraturePlayerCreateOrConnectWithoutGameInput = {
    where: LiteraturePlayerWhereUniqueInput
    create: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput>
  }

  export type LiteraturePlayerCreateManyGameInputEnvelope = {
    data: LiteraturePlayerCreateManyGameInput | LiteraturePlayerCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureTeamCreateWithoutGameInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    members?: LiteraturePlayerCreateNestedManyWithoutTeamInput
  }

  export type LiteratureTeamUncheckedCreateWithoutGameInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
    members?: LiteraturePlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type LiteratureTeamCreateOrConnectWithoutGameInput = {
    where: LiteratureTeamWhereUniqueInput
    create: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput>
  }

  export type LiteratureTeamCreateManyGameInputEnvelope = {
    data: LiteratureTeamCreateManyGameInput | LiteratureTeamCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureCardMappingCreateWithoutGameInput = {
    cardId: string
    player: LiteraturePlayerCreateNestedOneWithoutCardMappingsInput
  }

  export type LiteratureCardMappingUncheckedCreateWithoutGameInput = {
    cardId: string
    playerId: string
  }

  export type LiteratureCardMappingCreateOrConnectWithoutGameInput = {
    where: LiteratureCardMappingWhereUniqueInput
    create: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCardMappingCreateManyGameInputEnvelope = {
    data: LiteratureCardMappingCreateManyGameInput | LiteratureCardMappingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureCardLocationCreateWithoutGameInput = {
    cardId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
    player: LiteraturePlayerCreateNestedOneWithoutCardLocationsInput
  }

  export type LiteratureCardLocationUncheckedCreateWithoutGameInput = {
    cardId: string
    playerId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureCardLocationCreateOrConnectWithoutGameInput = {
    where: LiteratureCardLocationWhereUniqueInput
    create: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCardLocationCreateManyGameInputEnvelope = {
    data: LiteratureCardLocationCreateManyGameInput | LiteratureCardLocationCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureAskCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
    player: LiteraturePlayerCreateNestedOneWithoutAsksInput
  }

  export type LiteratureAskUncheckedCreateWithoutGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureAskCreateOrConnectWithoutGameInput = {
    where: LiteratureAskWhereUniqueInput
    create: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput>
  }

  export type LiteratureAskCreateManyGameInputEnvelope = {
    data: LiteratureAskCreateManyGameInput | LiteratureAskCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureCallCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
    player: LiteraturePlayerCreateNestedOneWithoutCallsInput
  }

  export type LiteratureCallUncheckedCreateWithoutGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureCallCreateOrConnectWithoutGameInput = {
    where: LiteratureCallWhereUniqueInput
    create: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCallCreateManyGameInputEnvelope = {
    data: LiteratureCallCreateManyGameInput | LiteratureCallCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteratureTransferCreateWithoutGameInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
    player: LiteraturePlayerCreateNestedOneWithoutTransfersInput
  }

  export type LiteratureTransferUncheckedCreateWithoutGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteratureTransferCreateOrConnectWithoutGameInput = {
    where: LiteratureTransferWhereUniqueInput
    create: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput>
  }

  export type LiteratureTransferCreateManyGameInputEnvelope = {
    data: LiteratureTransferCreateManyGameInput | LiteratureTransferCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LiteraturePlayerUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteraturePlayerWhereUniqueInput
    update: XOR<LiteraturePlayerUpdateWithoutGameInput, LiteraturePlayerUncheckedUpdateWithoutGameInput>
    create: XOR<LiteraturePlayerCreateWithoutGameInput, LiteraturePlayerUncheckedCreateWithoutGameInput>
  }

  export type LiteraturePlayerUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteraturePlayerWhereUniqueInput
    data: XOR<LiteraturePlayerUpdateWithoutGameInput, LiteraturePlayerUncheckedUpdateWithoutGameInput>
  }

  export type LiteraturePlayerUpdateManyWithWhereWithoutGameInput = {
    where: LiteraturePlayerScalarWhereInput
    data: XOR<LiteraturePlayerUpdateManyMutationInput, LiteraturePlayerUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureTeamUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureTeamWhereUniqueInput
    update: XOR<LiteratureTeamUpdateWithoutGameInput, LiteratureTeamUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureTeamCreateWithoutGameInput, LiteratureTeamUncheckedCreateWithoutGameInput>
  }

  export type LiteratureTeamUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureTeamWhereUniqueInput
    data: XOR<LiteratureTeamUpdateWithoutGameInput, LiteratureTeamUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureTeamUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureTeamScalarWhereInput
    data: XOR<LiteratureTeamUpdateManyMutationInput, LiteratureTeamUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureTeamScalarWhereInput = {
    AND?: LiteratureTeamScalarWhereInput | LiteratureTeamScalarWhereInput[]
    OR?: LiteratureTeamScalarWhereInput[]
    NOT?: LiteratureTeamScalarWhereInput | LiteratureTeamScalarWhereInput[]
    id?: StringFilter<"LiteratureTeam"> | string
    name?: StringFilter<"LiteratureTeam"> | string
    score?: IntFilter<"LiteratureTeam"> | number
    setsWon?: StringNullableListFilter<"LiteratureTeam">
    memberIds?: StringNullableListFilter<"LiteratureTeam">
    gameId?: StringFilter<"LiteratureTeam"> | string
  }

  export type LiteratureCardMappingUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureCardMappingWhereUniqueInput
    update: XOR<LiteratureCardMappingUpdateWithoutGameInput, LiteratureCardMappingUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureCardMappingCreateWithoutGameInput, LiteratureCardMappingUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCardMappingUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureCardMappingWhereUniqueInput
    data: XOR<LiteratureCardMappingUpdateWithoutGameInput, LiteratureCardMappingUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureCardMappingUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureCardMappingScalarWhereInput
    data: XOR<LiteratureCardMappingUpdateManyMutationInput, LiteratureCardMappingUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureCardLocationUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureCardLocationWhereUniqueInput
    update: XOR<LiteratureCardLocationUpdateWithoutGameInput, LiteratureCardLocationUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureCardLocationCreateWithoutGameInput, LiteratureCardLocationUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCardLocationUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureCardLocationWhereUniqueInput
    data: XOR<LiteratureCardLocationUpdateWithoutGameInput, LiteratureCardLocationUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureCardLocationUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureCardLocationScalarWhereInput
    data: XOR<LiteratureCardLocationUpdateManyMutationInput, LiteratureCardLocationUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureAskUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureAskWhereUniqueInput
    update: XOR<LiteratureAskUpdateWithoutGameInput, LiteratureAskUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureAskCreateWithoutGameInput, LiteratureAskUncheckedCreateWithoutGameInput>
  }

  export type LiteratureAskUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureAskWhereUniqueInput
    data: XOR<LiteratureAskUpdateWithoutGameInput, LiteratureAskUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureAskUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureAskScalarWhereInput
    data: XOR<LiteratureAskUpdateManyMutationInput, LiteratureAskUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureCallUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureCallWhereUniqueInput
    update: XOR<LiteratureCallUpdateWithoutGameInput, LiteratureCallUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureCallCreateWithoutGameInput, LiteratureCallUncheckedCreateWithoutGameInput>
  }

  export type LiteratureCallUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureCallWhereUniqueInput
    data: XOR<LiteratureCallUpdateWithoutGameInput, LiteratureCallUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureCallUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureCallScalarWhereInput
    data: XOR<LiteratureCallUpdateManyMutationInput, LiteratureCallUncheckedUpdateManyWithoutGameInput>
  }

  export type LiteratureTransferUpsertWithWhereUniqueWithoutGameInput = {
    where: LiteratureTransferWhereUniqueInput
    update: XOR<LiteratureTransferUpdateWithoutGameInput, LiteratureTransferUncheckedUpdateWithoutGameInput>
    create: XOR<LiteratureTransferCreateWithoutGameInput, LiteratureTransferUncheckedCreateWithoutGameInput>
  }

  export type LiteratureTransferUpdateWithWhereUniqueWithoutGameInput = {
    where: LiteratureTransferWhereUniqueInput
    data: XOR<LiteratureTransferUpdateWithoutGameInput, LiteratureTransferUncheckedUpdateWithoutGameInput>
  }

  export type LiteratureTransferUpdateManyWithWhereWithoutGameInput = {
    where: LiteratureTransferScalarWhereInput
    data: XOR<LiteratureTransferUpdateManyMutationInput, LiteratureTransferUncheckedUpdateManyWithoutGameInput>
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    providerId: string
    accountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakPlayerCreateManyGameInput = {
    id?: string
    name: string
    avatar: string
    isBot?: boolean
  }

  export type CallBreakDealCreateManyGameInput = {
    id?: string
    playerOrder?: CallBreakDealCreateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: number
    status?: $Enums.CallBreakStatus
    createdAt?: Date | string
  }

  export type CallBreakCardMappingCreateManyGameInput = {
    cardId: string
    dealId: string
    playerId: string
  }

  export type CallBreakRoundCreateManyGameInput = {
    id?: string
    dealId: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakPlayerUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: CallBreakCardMappingUpdateManyWithoutPlayerNestedInput
  }

  export type CallBreakPlayerUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type CallBreakPlayerUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CallBreakDealUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cardMappings?: CallBreakCardMappingUpdateManyWithoutDealNestedInput
    rounds?: CallBreakRoundUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: (Record<string, number>)
    wins?: (Record<string, number>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cardMappings?: CallBreakCardMappingUncheckedUpdateManyWithoutDealNestedInput
    rounds?: CallBreakRoundUncheckedUpdateManyWithoutDealNestedInput
  }

  export type CallBreakDealUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerOrder?: CallBreakDealUpdateplayerOrderInput | string[]
    declarations?: JsonNullValueInput | InputJsonValue
    wins?: JsonNullValueInput | InputJsonValue
    turnIdx?: IntFieldUpdateOperationsInput | number
    status?: EnumCallBreakStatusFieldUpdateOperationsInput | $Enums.CallBreakStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakCardMappingUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    deal?: CallBreakDealUpdateOneRequiredWithoutCardMappingsNestedInput
    player?: CallBreakPlayerUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type CallBreakCardMappingUncheckedUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakRoundUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: CallBreakDealUpdateOneRequiredWithoutRoundsNestedInput
  }

  export type CallBreakRoundUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakRoundUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: JsonNullValueInput | InputJsonValue
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakCardMappingCreateManyPlayerInput = {
    cardId: string
    dealId: string
  }

  export type CallBreakCardMappingUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    deal?: CallBreakDealUpdateOneRequiredWithoutCardMappingsNestedInput
    game?: CallBreakGameUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type CallBreakCardMappingUncheckedUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingCreateManyDealInput = {
    cardId: string
    playerId: string
  }

  export type CallBreakRoundCreateManyDealInput = {
    id?: string
    winner?: string | null
    playerOrder?: CallBreakRoundCreateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: number
    suit?: string | null
    completed?: boolean
    createdAt?: Date | string
  }

  export type CallBreakCardMappingUpdateWithoutDealInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    game?: CallBreakGameUpdateOneRequiredWithoutCardMappingsNestedInput
    player?: CallBreakPlayerUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type CallBreakCardMappingUncheckedUpdateWithoutDealInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakCardMappingUncheckedUpdateManyWithoutDealInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type CallBreakRoundUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: CallBreakGameUpdateOneRequiredWithoutRoundsNestedInput
  }

  export type CallBreakRoundUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: (Record<string, string>)
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallBreakRoundUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    playerOrder?: CallBreakRoundUpdateplayerOrderInput | string[]
    cards?: JsonNullValueInput | InputJsonValue
    turnIdx?: IntFieldUpdateOperationsInput | number
    suit?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiteratureCardMappingCreateManyPlayerInput = {
    cardId: string
  }

  export type LiteratureCardLocationCreateManyPlayerInput = {
    cardId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureAskCreateManyPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureCallCreateManyPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureTransferCreateManyPlayerInput = {
    id?: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteratureCardMappingUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type LiteratureCardMappingUncheckedUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingUncheckedUpdateManyWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardLocationUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
    game?: LiteratureGameUpdateOneRequiredWithoutCardLocationsNestedInput
  }

  export type LiteratureCardLocationUncheckedUpdateWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureCardLocationUncheckedUpdateManyWithoutPlayerInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureAskUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutAsksNestedInput
  }

  export type LiteratureAskUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureAskUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCallUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
    game?: LiteratureGameUpdateOneRequiredWithoutCallsNestedInput
  }

  export type LiteratureCallUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
  }

  export type LiteratureCallUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: JsonNullValueInput | InputJsonValue
    correctCall?: JsonNullValueInput | InputJsonValue
  }

  export type LiteratureTransferUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
    game?: LiteratureGameUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type LiteratureTransferUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureTransferUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteraturePlayerCreateManyTeamInput = {
    id?: string
    name: string
    avatar: string
    gameId: string
    isBot?: boolean
  }

  export type LiteraturePlayerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    game?: LiteratureGameUpdateOneRequiredWithoutPlayersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LiteraturePlayerCreateManyGameInput = {
    id?: string
    name: string
    avatar: string
    teamId?: string | null
    isBot?: boolean
  }

  export type LiteratureTeamCreateManyGameInput = {
    id?: string
    name: string
    score?: number
    setsWon?: LiteratureTeamCreatesetsWonInput | string[]
    memberIds?: LiteratureTeamCreatememberIdsInput | string[]
  }

  export type LiteratureCardMappingCreateManyGameInput = {
    cardId: string
    playerId: string
  }

  export type LiteratureCardLocationCreateManyGameInput = {
    cardId: string
    playerId: string
    playerIds?: LiteratureCardLocationCreateplayerIdsInput | string[]
    weight: number
  }

  export type LiteratureAskCreateManyGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardId: string
    askedFrom: string
  }

  export type LiteratureCallCreateManyGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success: boolean
    cardSet: string
    actualCall: (Record<string, string>)
    correctCall: (Record<string, string>)
  }

  export type LiteratureTransferCreateManyGameInput = {
    id?: string
    playerId: string
    timestamp?: Date | string
    description: string
    success?: boolean
    transferTo: string
  }

  export type LiteraturePlayerUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    team?: LiteratureTeamUpdateOneWithoutMembersNestedInput
    cardMappings?: LiteratureCardMappingUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
    cardMappings?: LiteratureCardMappingUncheckedUpdateManyWithoutPlayerNestedInput
    cardLocations?: LiteratureCardLocationUncheckedUpdateManyWithoutPlayerNestedInput
    asks?: LiteratureAskUncheckedUpdateManyWithoutPlayerNestedInput
    calls?: LiteratureCallUncheckedUpdateManyWithoutPlayerNestedInput
    transfers?: LiteratureTransferUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LiteraturePlayerUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isBot?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LiteratureTeamUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    members?: LiteraturePlayerUpdateManyWithoutTeamNestedInput
  }

  export type LiteratureTeamUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
    members?: LiteraturePlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type LiteratureTeamUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    setsWon?: LiteratureTeamUpdatesetsWonInput | string[]
    memberIds?: LiteratureTeamUpdatememberIdsInput | string[]
  }

  export type LiteratureCardMappingUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    player?: LiteraturePlayerUpdateOneRequiredWithoutCardMappingsNestedInput
  }

  export type LiteratureCardMappingUncheckedUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardMappingUncheckedUpdateManyWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCardLocationUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
    player?: LiteraturePlayerUpdateOneRequiredWithoutCardLocationsNestedInput
  }

  export type LiteratureCardLocationUncheckedUpdateWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureCardLocationUncheckedUpdateManyWithoutGameInput = {
    cardId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    playerIds?: LiteratureCardLocationUpdateplayerIdsInput | string[]
    weight?: IntFieldUpdateOperationsInput | number
  }

  export type LiteratureAskUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
    player?: LiteraturePlayerUpdateOneRequiredWithoutAsksNestedInput
  }

  export type LiteratureAskUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureAskUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardId?: StringFieldUpdateOperationsInput | string
    askedFrom?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureCallUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
    player?: LiteraturePlayerUpdateOneRequiredWithoutCallsNestedInput
  }

  export type LiteratureCallUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: (Record<string, string>)
    correctCall?: (Record<string, string>)
  }

  export type LiteratureCallUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    cardSet?: StringFieldUpdateOperationsInput | string
    actualCall?: JsonNullValueInput | InputJsonValue
    correctCall?: JsonNullValueInput | InputJsonValue
  }

  export type LiteratureTransferUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
    player?: LiteraturePlayerUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type LiteratureTransferUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }

  export type LiteratureTransferUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    transferTo?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}